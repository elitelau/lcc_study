        -:    0:Source:/home/coolbar/Desktop/tmp/lcc-4.1/lcc/x86.c
        -:    0:Graph:lcc/x86.gcno
        -:    0:Data:lcc/x86.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:enum { EAX=0, ECX=1, EDX=2, EBX=3, ESI=6, EDI=7 };
        -:    2:#include "c.h"
        -:    3:#define NODEPTR_TYPE Node
        -:    4:#define OP_LABEL(p) ((p)->op)
        -:    5:#define LEFT_CHILD(p) ((p)->kids[0])
        -:    6:#define RIGHT_CHILD(p) ((p)->kids[1])
        -:    7:#define STATE_LABEL(p) ((p)->x.state)
        -:    8:static void address(Symbol, Symbol, long);
        -:    9:static void blkfetch(int, int, int, int);
        -:   10:static void blkloop(int, int, int, int, int, int[]);
        -:   11:static void blkstore(int, int, int, int);
        -:   12:static void defaddress(Symbol);
        -:   13:static void defconst(int, int, Value);
        -:   14:static void defstring(int, char *);
        -:   15:static void defsymbol(Symbol);
        -:   16:static void doarg(Node);
        -:   17:static void emit2(Node);
        -:   18:static void export(Symbol);
        -:   19:static void clobber(Node);
        -:   20:static void function(Symbol, Symbol [], Symbol [], int);
        -:   21:static void global(Symbol);
        -:   22:static void import(Symbol);
        -:   23:static void local(Symbol);
        -:   24:static void progbeg(int, char **);
        -:   25:static void progend(void);
        -:   26:static void segment(int);
        -:   27:static void space(int);
        -:   28:static void target(Node);
        -:   29:extern int ckstack(Node, int);
        -:   30:extern int memop(Node);
        -:   31:extern int sametree(Node, Node);
        -:   32:static Symbol charreg[32], shortreg[32], intreg[32];
        -:   33:static Symbol fltreg[32];
        -:   34:
        -:   35:static Symbol charregw, shortregw, intregw, fltregw;
        -:   36:
        -:   37:static int cseg;
        -:   38:
        -:   39:static Symbol quo, rem;
        -:   40:
        -:   41:/*
        -:   42:generated at Tue Dec 13 00:36:42 2011
        -:   43:by $Id: lburg.c,v 2.8 1997/10/30 23:41:10 drh Exp $
        -:   44:*/
        -:   45:static void _kids(NODEPTR_TYPE, int, NODEPTR_TYPE[]);
        -:   46:static void _label(NODEPTR_TYPE);
        -:   47:static int _rule(void*, int);
        -:   48:
        -:   49:#define _stmt_NT 1
        -:   50:#define _reg_NT 2
        -:   51:#define _con_NT 3
        -:   52:#define _acon_NT 4
        -:   53:#define _base_NT 5
        -:   54:#define _index_NT 6
        -:   55:#define _con1_NT 7
        -:   56:#define _con2_NT 8
        -:   57:#define _con3_NT 9
        -:   58:#define _addr_NT 10
        -:   59:#define _mem_NT 11
        -:   60:#define _rc_NT 12
        -:   61:#define _mr_NT 13
        -:   62:#define _mrc0_NT 14
        -:   63:#define _mrc1_NT 15
        -:   64:#define _mrc3_NT 16
        -:   65:#define _con5_NT 17
        -:   66:#define _memf_NT 18
        -:   67:#define _flt_NT 19
        -:   68:#define _addrj_NT 20
        -:   69:#define _cmpf_NT 21
        -:   70:
        -:   71:static char *_ntname[] = {
        -:   72:	0,
        -:   73:	"stmt",
        -:   74:	"reg",
        -:   75:	"con",
        -:   76:	"acon",
        -:   77:	"base",
        -:   78:	"index",
        -:   79:	"con1",
        -:   80:	"con2",
        -:   81:	"con3",
        -:   82:	"addr",
        -:   83:	"mem",
        -:   84:	"rc",
        -:   85:	"mr",
        -:   86:	"mrc0",
        -:   87:	"mrc1",
        -:   88:	"mrc3",
        -:   89:	"con5",
        -:   90:	"memf",
        -:   91:	"flt",
        -:   92:	"addrj",
        -:   93:	"cmpf",
        -:   94:	0
        -:   95:};
        -:   96:
        -:   97:struct _state {
        -:   98:	short cost[22];
        -:   99:	struct {
        -:  100:		unsigned int _stmt:7;
        -:  101:		unsigned int _reg:7;
        -:  102:		unsigned int _con:4;
        -:  103:		unsigned int _acon:2;
        -:  104:		unsigned int _base:3;
        -:  105:		unsigned int _index:3;
        -:  106:		unsigned int _con1:2;
        -:  107:		unsigned int _con2:2;
        -:  108:		unsigned int _con3:2;
        -:  109:		unsigned int _addr:3;
        -:  110:		unsigned int _mem:3;
        -:  111:		unsigned int _rc:2;
        -:  112:		unsigned int _mr:2;
        -:  113:		unsigned int _mrc0:2;
        -:  114:		unsigned int _mrc1:2;
        -:  115:		unsigned int _mrc3:2;
        -:  116:		unsigned int _con5:1;
        -:  117:		unsigned int _memf:2;
        -:  118:		unsigned int _flt:2;
        -:  119:		unsigned int _addrj:2;
        -:  120:		unsigned int _cmpf:2;
        -:  121:	} rule;
        -:  122:};
        -:  123:
        -:  124:static short _nts_0[] = { 0 };
        -:  125:static short _nts_1[] = { _reg_NT, 0 };
        -:  126:static short _nts_2[] = { _con_NT, 0 };
        -:  127:static short _nts_3[] = { _reg_NT, _acon_NT, 0 };
        -:  128:static short _nts_4[] = { _reg_NT, _con1_NT, 0 };
        -:  129:static short _nts_5[] = { _reg_NT, _con2_NT, 0 };
        -:  130:static short _nts_6[] = { _reg_NT, _con3_NT, 0 };
        -:  131:static short _nts_7[] = { _base_NT, 0 };
        -:  132:static short _nts_8[] = { _index_NT, _base_NT, 0 };
        -:  133:static short _nts_9[] = { _index_NT, 0 };
        -:  134:static short _nts_10[] = { _addr_NT, 0 };
        -:  135:static short _nts_11[] = { _mem_NT, 0 };
        -:  136:static short _nts_12[] = { _rc_NT, 0 };
        -:  137:static short _nts_13[] = { _mrc0_NT, 0 };
        -:  138:static short _nts_14[] = { _reg_NT, _mrc1_NT, 0 };
        -:  139:static short _nts_15[] = { _addr_NT, _mem_NT, _con1_NT, 0 };
        -:  140:static short _nts_16[] = { _addr_NT, _mem_NT, _rc_NT, 0 };
        -:  141:static short _nts_17[] = { _addr_NT, _mem_NT, 0 };
        -:  142:static short _nts_18[] = { _reg_NT, _con5_NT, 0 };
        -:  143:static short _nts_19[] = { _addr_NT, _mem_NT, _con5_NT, 0 };
        -:  144:static short _nts_20[] = { _reg_NT, _reg_NT, 0 };
        -:  145:static short _nts_21[] = { _reg_NT, _mrc3_NT, 0 };
        -:  146:static short _nts_22[] = { _con_NT, _mr_NT, 0 };
        -:  147:static short _nts_23[] = { _reg_NT, _mr_NT, 0 };
        -:  148:static short _nts_24[] = { _addr_NT, _rc_NT, 0 };
        -:  149:static short _nts_25[] = { _mrc3_NT, 0 };
        -:  150:static short _nts_26[] = { _memf_NT, 0 };
        -:  151:static short _nts_27[] = { _addr_NT, _reg_NT, 0 };
        -:  152:static short _nts_28[] = { _reg_NT, _flt_NT, 0 };
        -:  153:static short _nts_29[] = { _addrj_NT, 0 };
        -:  154:static short _nts_30[] = { _mem_NT, _rc_NT, 0 };
        -:  155:static short _nts_31[] = { _cmpf_NT, _reg_NT, 0 };
        -:  156:
        -:  157:static short *_nts[] = {
        -:  158:	0,	/* 0 */
        -:  159:	_nts_0,	/* 1 */
        -:  160:	_nts_0,	/* 2 */
        -:  161:	_nts_0,	/* 3 */
        -:  162:	_nts_0,	/* 4 */
        -:  163:	_nts_0,	/* 5 */
        -:  164:	_nts_0,	/* 6 */
        -:  165:	_nts_0,	/* 7 */
        -:  166:	_nts_0,	/* 8 */
        -:  167:	_nts_0,	/* 9 */
        -:  168:	_nts_0,	/* 10 */
        -:  169:	_nts_0,	/* 11 */
        -:  170:	_nts_0,	/* 12 */
        -:  171:	_nts_1,	/* 13 */
        -:  172:	_nts_1,	/* 14 */
        -:  173:	_nts_1,	/* 15 */
        -:  174:	_nts_1,	/* 16 */
        -:  175:	_nts_1,	/* 17 */
        -:  176:	_nts_1,	/* 18 */
        -:  177:	_nts_1,	/* 19 */
        -:  178:	_nts_1,	/* 20 */
        -:  179:	_nts_1,	/* 21 */
        -:  180:	_nts_1,	/* 22 */
        -:  181:	_nts_1,	/* 23 */
        -:  182:	_nts_1,	/* 24 */
        -:  183:	_nts_0,	/* 25 */
        -:  184:	_nts_0,	/* 26 */
        -:  185:	_nts_0,	/* 27 */
        -:  186:	_nts_0,	/* 28 */
        -:  187:	_nts_0,	/* 29 */
        -:  188:	_nts_0,	/* 30 */
        -:  189:	_nts_0,	/* 31 */
        -:  190:	_nts_0,	/* 32 */
        -:  191:	_nts_0,	/* 33 */
        -:  192:	_nts_0,	/* 34 */
        -:  193:	_nts_1,	/* 35 */
        -:  194:	_nts_0,	/* 36 */
        -:  195:	_nts_2,	/* 37 */
        -:  196:	_nts_0,	/* 38 */
        -:  197:	_nts_1,	/* 39 */
        -:  198:	_nts_3,	/* 40 */
        -:  199:	_nts_3,	/* 41 */
        -:  200:	_nts_3,	/* 42 */
        -:  201:	_nts_0,	/* 43 */
        -:  202:	_nts_0,	/* 44 */
        -:  203:	_nts_1,	/* 45 */
        -:  204:	_nts_4,	/* 46 */
        -:  205:	_nts_5,	/* 47 */
        -:  206:	_nts_6,	/* 48 */
        -:  207:	_nts_0,	/* 49 */
        -:  208:	_nts_0,	/* 50 */
        -:  209:	_nts_0,	/* 51 */
        -:  210:	_nts_0,	/* 52 */
        -:  211:	_nts_0,	/* 53 */
        -:  212:	_nts_0,	/* 54 */
        -:  213:	_nts_4,	/* 55 */
        -:  214:	_nts_5,	/* 56 */
        -:  215:	_nts_6,	/* 57 */
        -:  216:	_nts_7,	/* 58 */
        -:  217:	_nts_8,	/* 59 */
        -:  218:	_nts_8,	/* 60 */
        -:  219:	_nts_8,	/* 61 */
        -:  220:	_nts_9,	/* 62 */
        -:  221:	_nts_10,	/* 63 */
        -:  222:	_nts_10,	/* 64 */
        -:  223:	_nts_10,	/* 65 */
        -:  224:	_nts_10,	/* 66 */
        -:  225:	_nts_10,	/* 67 */
        -:  226:	_nts_10,	/* 68 */
        -:  227:	_nts_10,	/* 69 */
        -:  228:	_nts_1,	/* 70 */
        -:  229:	_nts_2,	/* 71 */
        -:  230:	_nts_1,	/* 72 */
        -:  231:	_nts_11,	/* 73 */
        -:  232:	_nts_11,	/* 74 */
        -:  233:	_nts_12,	/* 75 */
        -:  234:	_nts_11,	/* 76 */
        -:  235:	_nts_12,	/* 77 */
        -:  236:	_nts_11,	/* 78 */
        -:  237:	_nts_12,	/* 79 */
        -:  238:	_nts_10,	/* 80 */
        -:  239:	_nts_13,	/* 81 */
        -:  240:	_nts_1,	/* 82 */
        -:  241:	_nts_1,	/* 83 */
        -:  242:	_nts_1,	/* 84 */
        -:  243:	_nts_1,	/* 85 */
        -:  244:	_nts_1,	/* 86 */
        -:  245:	_nts_1,	/* 87 */
        -:  246:	_nts_1,	/* 88 */
        -:  247:	_nts_14,	/* 89 */
        -:  248:	_nts_14,	/* 90 */
        -:  249:	_nts_14,	/* 91 */
        -:  250:	_nts_14,	/* 92 */
        -:  251:	_nts_14,	/* 93 */
        -:  252:	_nts_14,	/* 94 */
        -:  253:	_nts_14,	/* 95 */
        -:  254:	_nts_14,	/* 96 */
        -:  255:	_nts_14,	/* 97 */
        -:  256:	_nts_14,	/* 98 */
        -:  257:	_nts_14,	/* 99 */
        -:  258:	_nts_14,	/* 100 */
        -:  259:	_nts_15,	/* 101 */
        -:  260:	_nts_15,	/* 102 */
        -:  261:	_nts_15,	/* 103 */
        -:  262:	_nts_15,	/* 104 */
        -:  263:	_nts_15,	/* 105 */
        -:  264:	_nts_15,	/* 106 */
        -:  265:	_nts_16,	/* 107 */
        -:  266:	_nts_16,	/* 108 */
        -:  267:	_nts_16,	/* 109 */
        -:  268:	_nts_16,	/* 110 */
        -:  269:	_nts_16,	/* 111 */
        -:  270:	_nts_16,	/* 112 */
        -:  271:	_nts_16,	/* 113 */
        -:  272:	_nts_16,	/* 114 */
        -:  273:	_nts_16,	/* 115 */
        -:  274:	_nts_16,	/* 116 */
        -:  275:	_nts_1,	/* 117 */
        -:  276:	_nts_1,	/* 118 */
        -:  277:	_nts_1,	/* 119 */
        -:  278:	_nts_17,	/* 120 */
        -:  279:	_nts_17,	/* 121 */
        -:  280:	_nts_17,	/* 122 */
        -:  281:	_nts_18,	/* 123 */
        -:  282:	_nts_18,	/* 124 */
        -:  283:	_nts_18,	/* 125 */
        -:  284:	_nts_18,	/* 126 */
        -:  285:	_nts_19,	/* 127 */
        -:  286:	_nts_19,	/* 128 */
        -:  287:	_nts_19,	/* 129 */
        -:  288:	_nts_19,	/* 130 */
        -:  289:	_nts_0,	/* 131 */
        -:  290:	_nts_20,	/* 132 */
        -:  291:	_nts_20,	/* 133 */
        -:  292:	_nts_20,	/* 134 */
        -:  293:	_nts_20,	/* 135 */
        -:  294:	_nts_21,	/* 136 */
        -:  295:	_nts_22,	/* 137 */
        -:  296:	_nts_23,	/* 138 */
        -:  297:	_nts_20,	/* 139 */
        -:  298:	_nts_20,	/* 140 */
        -:  299:	_nts_20,	/* 141 */
        -:  300:	_nts_20,	/* 142 */
        -:  301:	_nts_1,	/* 143 */
        -:  302:	_nts_1,	/* 144 */
        -:  303:	_nts_10,	/* 145 */
        -:  304:	_nts_10,	/* 146 */
        -:  305:	_nts_10,	/* 147 */
        -:  306:	_nts_10,	/* 148 */
        -:  307:	_nts_1,	/* 149 */
        -:  308:	_nts_1,	/* 150 */
        -:  309:	_nts_1,	/* 151 */
        -:  310:	_nts_1,	/* 152 */
        -:  311:	_nts_1,	/* 153 */
        -:  312:	_nts_1,	/* 154 */
        -:  313:	_nts_1,	/* 155 */
        -:  314:	_nts_1,	/* 156 */
        -:  315:	_nts_24,	/* 157 */
        -:  316:	_nts_24,	/* 158 */
        -:  317:	_nts_24,	/* 159 */
        -:  318:	_nts_24,	/* 160 */
        -:  319:	_nts_24,	/* 161 */
        -:  320:	_nts_24,	/* 162 */
        -:  321:	_nts_24,	/* 163 */
        -:  322:	_nts_25,	/* 164 */
        -:  323:	_nts_25,	/* 165 */
        -:  324:	_nts_25,	/* 166 */
        -:  325:	_nts_20,	/* 167 */
        -:  326:	_nts_1,	/* 168 */
        -:  327:	_nts_10,	/* 169 */
        -:  328:	_nts_10,	/* 170 */
        -:  329:	_nts_10,	/* 171 */
        -:  330:	_nts_26,	/* 172 */
        -:  331:	_nts_27,	/* 173 */
        -:  332:	_nts_27,	/* 174 */
        -:  333:	_nts_27,	/* 175 */
        -:  334:	_nts_1,	/* 176 */
        -:  335:	_nts_1,	/* 177 */
        -:  336:	_nts_1,	/* 178 */
        -:  337:	_nts_1,	/* 179 */
        -:  338:	_nts_26,	/* 180 */
        -:  339:	_nts_1,	/* 181 */
        -:  340:	_nts_28,	/* 182 */
        -:  341:	_nts_28,	/* 183 */
        -:  342:	_nts_28,	/* 184 */
        -:  343:	_nts_28,	/* 185 */
        -:  344:	_nts_28,	/* 186 */
        -:  345:	_nts_28,	/* 187 */
        -:  346:	_nts_28,	/* 188 */
        -:  347:	_nts_28,	/* 189 */
        -:  348:	_nts_1,	/* 190 */
        -:  349:	_nts_1,	/* 191 */
        -:  350:	_nts_1,	/* 192 */
        -:  351:	_nts_10,	/* 193 */
        -:  352:	_nts_1,	/* 194 */
        -:  353:	_nts_1,	/* 195 */
        -:  354:	_nts_0,	/* 196 */
        -:  355:	_nts_1,	/* 197 */
        -:  356:	_nts_11,	/* 198 */
        -:  357:	_nts_29,	/* 199 */
        -:  358:	_nts_0,	/* 200 */
        -:  359:	_nts_30,	/* 201 */
        -:  360:	_nts_30,	/* 202 */
        -:  361:	_nts_30,	/* 203 */
        -:  362:	_nts_30,	/* 204 */
        -:  363:	_nts_30,	/* 205 */
        -:  364:	_nts_30,	/* 206 */
        -:  365:	_nts_30,	/* 207 */
        -:  366:	_nts_30,	/* 208 */
        -:  367:	_nts_30,	/* 209 */
        -:  368:	_nts_30,	/* 210 */
        -:  369:	_nts_14,	/* 211 */
        -:  370:	_nts_14,	/* 212 */
        -:  371:	_nts_14,	/* 213 */
        -:  372:	_nts_14,	/* 214 */
        -:  373:	_nts_14,	/* 215 */
        -:  374:	_nts_14,	/* 216 */
        -:  375:	_nts_14,	/* 217 */
        -:  376:	_nts_14,	/* 218 */
        -:  377:	_nts_14,	/* 219 */
        -:  378:	_nts_14,	/* 220 */
        -:  379:	_nts_14,	/* 221 */
        -:  380:	_nts_14,	/* 222 */
        -:  381:	_nts_26,	/* 223 */
        -:  382:	_nts_1,	/* 224 */
        -:  383:	_nts_31,	/* 225 */
        -:  384:	_nts_31,	/* 226 */
        -:  385:	_nts_31,	/* 227 */
        -:  386:	_nts_31,	/* 228 */
        -:  387:	_nts_31,	/* 229 */
        -:  388:	_nts_31,	/* 230 */
        -:  389:	_nts_31,	/* 231 */
        -:  390:	_nts_31,	/* 232 */
        -:  391:	_nts_31,	/* 233 */
        -:  392:	_nts_31,	/* 234 */
        -:  393:	_nts_31,	/* 235 */
        -:  394:	_nts_31,	/* 236 */
        -:  395:	_nts_29,	/* 237 */
        -:  396:	_nts_29,	/* 238 */
        -:  397:	_nts_29,	/* 239 */
        -:  398:	_nts_29,	/* 240 */
        -:  399:	_nts_29,	/* 241 */
        -:  400:	_nts_29,	/* 242 */
        -:  401:	_nts_29,	/* 243 */
        -:  402:	_nts_29,	/* 244 */
        -:  403:	_nts_1,	/* 245 */
        -:  404:	_nts_1,	/* 246 */
        -:  405:	_nts_1,	/* 247 */
        -:  406:	_nts_1,	/* 248 */
        -:  407:	_nts_1,	/* 249 */
        -:  408:};
        -:  409:
        -:  410:static char *_templates[] = {
        -:  411:/* 0 */	0,
        -:  412:/* 1 */	"# read register\n",	/* reg: INDIRI1(VREGP) */
        -:  413:/* 2 */	"# read register\n",	/* reg: INDIRU1(VREGP) */
        -:  414:/* 3 */	"# read register\n",	/* reg: INDIRI2(VREGP) */
        -:  415:/* 4 */	"# read register\n",	/* reg: INDIRU2(VREGP) */
        -:  416:/* 5 */	"# read register\n",	/* reg: INDIRF4(VREGP) */
        -:  417:/* 6 */	"# read register\n",	/* reg: INDIRI4(VREGP) */
        -:  418:/* 7 */	"# read register\n",	/* reg: INDIRP4(VREGP) */
        -:  419:/* 8 */	"# read register\n",	/* reg: INDIRU4(VREGP) */
        -:  420:/* 9 */	"# read register\n",	/* reg: INDIRF8(VREGP) */
        -:  421:/* 10 */	"# read register\n",	/* reg: INDIRI8(VREGP) */
        -:  422:/* 11 */	"# read register\n",	/* reg: INDIRP8(VREGP) */
        -:  423:/* 12 */	"# read register\n",	/* reg: INDIRU8(VREGP) */
        -:  424:/* 13 */	"# write register\n",	/* stmt: ASGNI1(VREGP,reg) */
        -:  425:/* 14 */	"# write register\n",	/* stmt: ASGNU1(VREGP,reg) */
        -:  426:/* 15 */	"# write register\n",	/* stmt: ASGNI2(VREGP,reg) */
        -:  427:/* 16 */	"# write register\n",	/* stmt: ASGNU2(VREGP,reg) */
        -:  428:/* 17 */	"# write register\n",	/* stmt: ASGNF4(VREGP,reg) */
        -:  429:/* 18 */	"# write register\n",	/* stmt: ASGNI4(VREGP,reg) */
        -:  430:/* 19 */	"# write register\n",	/* stmt: ASGNP4(VREGP,reg) */
        -:  431:/* 20 */	"# write register\n",	/* stmt: ASGNU4(VREGP,reg) */
        -:  432:/* 21 */	"# write register\n",	/* stmt: ASGNF8(VREGP,reg) */
        -:  433:/* 22 */	"# write register\n",	/* stmt: ASGNI8(VREGP,reg) */
        -:  434:/* 23 */	"# write register\n",	/* stmt: ASGNP8(VREGP,reg) */
        -:  435:/* 24 */	"# write register\n",	/* stmt: ASGNU8(VREGP,reg) */
        -:  436:/* 25 */	"%a",	/* con: CNSTI1 */
        -:  437:/* 26 */	"%a",	/* con: CNSTU1 */
        -:  438:/* 27 */	"%a",	/* con: CNSTI2 */
        -:  439:/* 28 */	"%a",	/* con: CNSTU2 */
        -:  440:/* 29 */	"%a",	/* con: CNSTI4 */
        -:  441:/* 30 */	"%a",	/* con: CNSTU4 */
        -:  442:/* 31 */	"%a",	/* con: CNSTP4 */
        -:  443:/* 32 */	"%a",	/* con: CNSTI8 */
        -:  444:/* 33 */	"%a",	/* con: CNSTU8 */
        -:  445:/* 34 */	"%a",	/* con: CNSTP8 */
        -:  446:/* 35 */	"",	/* stmt: reg */
        -:  447:/* 36 */	"(%a)",	/* acon: ADDRGP4 */
        -:  448:/* 37 */	"(%0)",	/* acon: con */
        -:  449:/* 38 */	"(%a)",	/* base: ADDRGP4 */
        -:  450:/* 39 */	"[%0]",	/* base: reg */
        -:  451:/* 40 */	"%1[%0]",	/* base: ADDI4(reg,acon) */
        -:  452:/* 41 */	"%1[%0]",	/* base: ADDP4(reg,acon) */
        -:  453:/* 42 */	"%1[%0]",	/* base: ADDU4(reg,acon) */
        -:  454:/* 43 */	"(%a)[ebp]",	/* base: ADDRFP4 */
        -:  455:/* 44 */	"(%a)[ebp]",	/* base: ADDRLP4 */
        -:  456:/* 45 */	"%0",	/* index: reg */
        -:  457:/* 46 */	"%0*2",	/* index: LSHI4(reg,con1) */
        -:  458:/* 47 */	"%0*4",	/* index: LSHI4(reg,con2) */
        -:  459:/* 48 */	"%0*8",	/* index: LSHI4(reg,con3) */
        -:  460:/* 49 */	"1",	/* con1: CNSTI4 */
        -:  461:/* 50 */	"1",	/* con1: CNSTU4 */
        -:  462:/* 51 */	"2",	/* con2: CNSTI4 */
        -:  463:/* 52 */	"2",	/* con2: CNSTU4 */
        -:  464:/* 53 */	"3",	/* con3: CNSTI4 */
        -:  465:/* 54 */	"3",	/* con3: CNSTU4 */
        -:  466:/* 55 */	"%0*2",	/* index: LSHU4(reg,con1) */
        -:  467:/* 56 */	"%0*4",	/* index: LSHU4(reg,con2) */
        -:  468:/* 57 */	"%0*8",	/* index: LSHU4(reg,con3) */
        -:  469:/* 58 */	"%0",	/* addr: base */
        -:  470:/* 59 */	"%1[%0]",	/* addr: ADDI4(index,base) */
        -:  471:/* 60 */	"%1[%0]",	/* addr: ADDP4(index,base) */
        -:  472:/* 61 */	"%1[%0]",	/* addr: ADDU4(index,base) */
        -:  473:/* 62 */	"[%0]",	/* addr: index */
        -:  474:/* 63 */	"byte ptr %0",	/* mem: INDIRI1(addr) */
        -:  475:/* 64 */	"word ptr %0",	/* mem: INDIRI2(addr) */
        -:  476:/* 65 */	"dword ptr %0",	/* mem: INDIRI4(addr) */
        -:  477:/* 66 */	"byte ptr %0",	/* mem: INDIRU1(addr) */
        -:  478:/* 67 */	"word ptr %0",	/* mem: INDIRU2(addr) */
        -:  479:/* 68 */	"dword ptr %0",	/* mem: INDIRU4(addr) */
        -:  480:/* 69 */	"dword ptr %0",	/* mem: INDIRP4(addr) */
        -:  481:/* 70 */	"%0",	/* rc: reg */
        -:  482:/* 71 */	"%0",	/* rc: con */
        -:  483:/* 72 */	"%0",	/* mr: reg */
        -:  484:/* 73 */	"%0",	/* mr: mem */
        -:  485:/* 74 */	"%0",	/* mrc0: mem */
        -:  486:/* 75 */	"%0",	/* mrc0: rc */
        -:  487:/* 76 */	"%0",	/* mrc1: mem */
        -:  488:/* 77 */	"%0",	/* mrc1: rc */
        -:  489:/* 78 */	"%0",	/* mrc3: mem */
        -:  490:/* 79 */	"%0",	/* mrc3: rc */
        -:  491:/* 80 */	"lea %c,%0\n",	/* reg: addr */
        -:  492:/* 81 */	"mov %c,%0\n",	/* reg: mrc0 */
        -:  493:/* 82 */	"# move\n",	/* reg: LOADI1(reg) */
        -:  494:/* 83 */	"# move\n",	/* reg: LOADI2(reg) */
        -:  495:/* 84 */	"# move\n",	/* reg: LOADI4(reg) */
        -:  496:/* 85 */	"# move\n",	/* reg: LOADU1(reg) */
        -:  497:/* 86 */	"# move\n",	/* reg: LOADU2(reg) */
        -:  498:/* 87 */	"# move\n",	/* reg: LOADU4(reg) */
        -:  499:/* 88 */	"# move\n",	/* reg: LOADP4(reg) */
        -:  500:/* 89 */	"?mov %c,%0\nadd %c,%1\n",	/* reg: ADDI4(reg,mrc1) */
        -:  501:/* 90 */	"?mov %c,%0\nadd %c,%1\n",	/* reg: ADDP4(reg,mrc1) */
        -:  502:/* 91 */	"?mov %c,%0\nadd %c,%1\n",	/* reg: ADDU4(reg,mrc1) */
        -:  503:/* 92 */	"?mov %c,%0\nsub %c,%1\n",	/* reg: SUBI4(reg,mrc1) */
        -:  504:/* 93 */	"?mov %c,%0\nsub %c,%1\n",	/* reg: SUBP4(reg,mrc1) */
        -:  505:/* 94 */	"?mov %c,%0\nsub %c,%1\n",	/* reg: SUBU4(reg,mrc1) */
        -:  506:/* 95 */	"?mov %c,%0\nand %c,%1\n",	/* reg: BANDI4(reg,mrc1) */
        -:  507:/* 96 */	"?mov %c,%0\nor %c,%1\n",	/* reg: BORI4(reg,mrc1) */
        -:  508:/* 97 */	"?mov %c,%0\nxor %c,%1\n",	/* reg: BXORI4(reg,mrc1) */
        -:  509:/* 98 */	"?mov %c,%0\nand %c,%1\n",	/* reg: BANDU4(reg,mrc1) */
        -:  510:/* 99 */	"?mov %c,%0\nor %c,%1\n",	/* reg: BORU4(reg,mrc1) */
        -:  511:/* 100 */	"?mov %c,%0\nxor %c,%1\n",	/* reg: BXORU4(reg,mrc1) */
        -:  512:/* 101 */	"inc %1\n",	/* stmt: ASGNI4(addr,ADDI4(mem,con1)) */
        -:  513:/* 102 */	"inc %1\n",	/* stmt: ASGNI4(addr,ADDU4(mem,con1)) */
        -:  514:/* 103 */	"inc %1\n",	/* stmt: ASGNP4(addr,ADDP4(mem,con1)) */
        -:  515:/* 104 */	"dec %1\n",	/* stmt: ASGNI4(addr,SUBI4(mem,con1)) */
        -:  516:/* 105 */	"dec %1\n",	/* stmt: ASGNI4(addr,SUBU4(mem,con1)) */
        -:  517:/* 106 */	"dec %1\n",	/* stmt: ASGNP4(addr,SUBP4(mem,con1)) */
        -:  518:/* 107 */	"add %1,%2\n",	/* stmt: ASGNI4(addr,ADDI4(mem,rc)) */
        -:  519:/* 108 */	"sub %1,%2\n",	/* stmt: ASGNI4(addr,SUBI4(mem,rc)) */
        -:  520:/* 109 */	"add %1,%2\n",	/* stmt: ASGNU4(addr,ADDU4(mem,rc)) */
        -:  521:/* 110 */	"sub %1,%2\n",	/* stmt: ASGNU4(addr,SUBU4(mem,rc)) */
        -:  522:/* 111 */	"and %1,%2\n",	/* stmt: ASGNI4(addr,BANDI4(mem,rc)) */
        -:  523:/* 112 */	"or %1,%2\n",	/* stmt: ASGNI4(addr,BORI4(mem,rc)) */
        -:  524:/* 113 */	"xor %1,%2\n",	/* stmt: ASGNI4(addr,BXORI4(mem,rc)) */
        -:  525:/* 114 */	"and %1,%2\n",	/* stmt: ASGNU4(addr,BANDU4(mem,rc)) */
        -:  526:/* 115 */	"or %1,%2\n",	/* stmt: ASGNU4(addr,BORU4(mem,rc)) */
        -:  527:/* 116 */	"xor %1,%2\n",	/* stmt: ASGNU4(addr,BXORU4(mem,rc)) */
        -:  528:/* 117 */	"?mov %c,%0\nnot %c\n",	/* reg: BCOMI4(reg) */
        -:  529:/* 118 */	"?mov %c,%0\nnot %c\n",	/* reg: BCOMU4(reg) */
        -:  530:/* 119 */	"?mov %c,%0\nneg %c\n",	/* reg: NEGI4(reg) */
        -:  531:/* 120 */	"not %1\n",	/* stmt: ASGNI4(addr,BCOMI4(mem)) */
        -:  532:/* 121 */	"not %1\n",	/* stmt: ASGNU4(addr,BCOMU4(mem)) */
        -:  533:/* 122 */	"neg %1\n",	/* stmt: ASGNI4(addr,NEGI4(mem)) */
        -:  534:/* 123 */	"?mov %c,%0\nsal %c,%1\n",	/* reg: LSHI4(reg,con5) */
        -:  535:/* 124 */	"?mov %c,%0\nshl %c,%1\n",	/* reg: LSHU4(reg,con5) */
        -:  536:/* 125 */	"?mov %c,%0\nsar %c,%1\n",	/* reg: RSHI4(reg,con5) */
        -:  537:/* 126 */	"?mov %c,%0\nshr %c,%1\n",	/* reg: RSHU4(reg,con5) */
        -:  538:/* 127 */	"sal %1,%2\n",	/* stmt: ASGNI4(addr,LSHI4(mem,con5)) */
        -:  539:/* 128 */	"shl %1,%2\n",	/* stmt: ASGNI4(addr,LSHU4(mem,con5)) */
        -:  540:/* 129 */	"sar %1,%2\n",	/* stmt: ASGNI4(addr,RSHI4(mem,con5)) */
        -:  541:/* 130 */	"shr %1,%2\n",	/* stmt: ASGNI4(addr,RSHU4(mem,con5)) */
        -:  542:/* 131 */	"%a",	/* con5: CNSTI4 */
        -:  543:/* 132 */	"?mov %c,%0\nmov ecx,%1\nsal %c,cl\n",	/* reg: LSHI4(reg,reg) */
        -:  544:/* 133 */	"?mov %c,%0\nmov ecx,%1\nshl %c,cl\n",	/* reg: LSHU4(reg,reg) */
        -:  545:/* 134 */	"?mov %c,%0\nmov ecx,%1\nsar %c,cl\n",	/* reg: RSHI4(reg,reg) */
        -:  546:/* 135 */	"?mov %c,%0\nmov ecx,%1\nshr %c,cl\n",	/* reg: RSHU4(reg,reg) */
        -:  547:/* 136 */	"?mov %c,%0\nimul %c,%1\n",	/* reg: MULI4(reg,mrc3) */
        -:  548:/* 137 */	"imul %c,%1,%0\n",	/* reg: MULI4(con,mr) */
        -:  549:/* 138 */	"mul %1\n",	/* reg: MULU4(reg,mr) */
        -:  550:/* 139 */	"xor edx,edx\ndiv %1\n",	/* reg: DIVU4(reg,reg) */
        -:  551:/* 140 */	"xor edx,edx\ndiv %1\n",	/* reg: MODU4(reg,reg) */
        -:  552:/* 141 */	"cdq\nidiv %1\n",	/* reg: DIVI4(reg,reg) */
        -:  553:/* 142 */	"cdq\nidiv %1\n",	/* reg: MODI4(reg,reg) */
        -:  554:/* 143 */	"mov %c,%0\n",	/* reg: CVPU4(reg) */
        -:  555:/* 144 */	"mov %c,%0\n",	/* reg: CVUP4(reg) */
        -:  556:/* 145 */	"movsx %c,byte ptr %0\n",	/* reg: CVII4(INDIRI1(addr)) */
        -:  557:/* 146 */	"movsx %c,word ptr %0\n",	/* reg: CVII4(INDIRI2(addr)) */
        -:  558:/* 147 */	"movzx %c,byte ptr %0\n",	/* reg: CVUU4(INDIRU1(addr)) */
        -:  559:/* 148 */	"movzx %c,word ptr %0\n",	/* reg: CVUU4(INDIRU2(addr)) */
        -:  560:/* 149 */	"# extend\n",	/* reg: CVII4(reg) */
        -:  561:/* 150 */	"# extend\n",	/* reg: CVIU4(reg) */
        -:  562:/* 151 */	"# extend\n",	/* reg: CVUI4(reg) */
        -:  563:/* 152 */	"# extend\n",	/* reg: CVUU4(reg) */
        -:  564:/* 153 */	"# truncate\n",	/* reg: CVII1(reg) */
        -:  565:/* 154 */	"# truncate\n",	/* reg: CVII2(reg) */
        -:  566:/* 155 */	"# truncate\n",	/* reg: CVUU1(reg) */
        -:  567:/* 156 */	"# truncate\n",	/* reg: CVUU2(reg) */
        -:  568:/* 157 */	"mov byte ptr %0,%1\n",	/* stmt: ASGNI1(addr,rc) */
        -:  569:/* 158 */	"mov word ptr %0,%1\n",	/* stmt: ASGNI2(addr,rc) */
        -:  570:/* 159 */	"mov dword ptr %0,%1\n",	/* stmt: ASGNI4(addr,rc) */
        -:  571:/* 160 */	"mov byte ptr %0,%1\n",	/* stmt: ASGNU1(addr,rc) */
        -:  572:/* 161 */	"mov word ptr %0,%1\n",	/* stmt: ASGNU2(addr,rc) */
        -:  573:/* 162 */	"mov dword ptr %0,%1\n",	/* stmt: ASGNU4(addr,rc) */
        -:  574:/* 163 */	"mov dword ptr %0,%1\n",	/* stmt: ASGNP4(addr,rc) */
        -:  575:/* 164 */	"push %0\n",	/* stmt: ARGI4(mrc3) */
        -:  576:/* 165 */	"push %0\n",	/* stmt: ARGU4(mrc3) */
        -:  577:/* 166 */	"push %0\n",	/* stmt: ARGP4(mrc3) */
        -:  578:/* 167 */	"mov ecx,%a\nrep movsb\n",	/* stmt: ASGNB(reg,INDIRB(reg)) */
        -:  579:/* 168 */	"sub esp,%a\nmov edi,esp\nmov ecx,%a\nrep movsb\n",	/* stmt: ARGB(INDIRB(reg)) */
        -:  580:/* 169 */	"qword ptr %0",	/* memf: INDIRF8(addr) */
        -:  581:/* 170 */	"dword ptr %0",	/* memf: INDIRF4(addr) */
        -:  582:/* 171 */	"dword ptr %0",	/* memf: CVFF8(INDIRF4(addr)) */
        -:  583:/* 172 */	"fld %0\n",	/* reg: memf */
        -:  584:/* 173 */	"fstp qword ptr %0\n",	/* stmt: ASGNF8(addr,reg) */
        -:  585:/* 174 */	"fstp dword ptr %0\n",	/* stmt: ASGNF4(addr,reg) */
        -:  586:/* 175 */	"fstp dword ptr %0\n",	/* stmt: ASGNF4(addr,CVFF4(reg)) */
        -:  587:/* 176 */	"sub esp,8\nfstp qword ptr [esp]\n",	/* stmt: ARGF8(reg) */
        -:  588:/* 177 */	"sub esp,4\nfstp dword ptr [esp]\n",	/* stmt: ARGF4(reg) */
        -:  589:/* 178 */	"fchs\n",	/* reg: NEGF8(reg) */
        -:  590:/* 179 */	"fchs\n",	/* reg: NEGF4(reg) */
        -:  591:/* 180 */	" %0",	/* flt: memf */
        -:  592:/* 181 */	"p st(1),st",	/* flt: reg */
        -:  593:/* 182 */	"fadd%1\n",	/* reg: ADDF8(reg,flt) */
        -:  594:/* 183 */	"fadd%1\n",	/* reg: ADDF4(reg,flt) */
        -:  595:/* 184 */	"fdiv%1\n",	/* reg: DIVF8(reg,flt) */
        -:  596:/* 185 */	"fdiv%1\n",	/* reg: DIVF4(reg,flt) */
        -:  597:/* 186 */	"fmul%1\n",	/* reg: MULF8(reg,flt) */
        -:  598:/* 187 */	"fmul%1\n",	/* reg: MULF4(reg,flt) */
        -:  599:/* 188 */	"fsub%1\n",	/* reg: SUBF8(reg,flt) */
        -:  600:/* 189 */	"fsub%1\n",	/* reg: SUBF4(reg,flt) */
        -:  601:/* 190 */	"# CVFF8\n",	/* reg: CVFF8(reg) */
        -:  602:/* 191 */	"sub esp,4\nfstp dword ptr 0[esp]\nfld dword ptr 0[esp]\nadd esp,4\n",	/* reg: CVFF4(reg) */
        -:  603:/* 192 */	"call __ftol\n",	/* reg: CVFI4(reg) */
        -:  604:/* 193 */	"fild dword ptr %0\n",	/* reg: CVIF8(INDIRI4(addr)) */
        -:  605:/* 194 */	"push %0\nfild dword ptr 0[esp]\nadd esp,4\n",	/* reg: CVIF4(reg) */
        -:  606:/* 195 */	"push %0\nfild dword ptr 0[esp]\nadd esp,4\n",	/* reg: CVIF8(reg) */
        -:  607:/* 196 */	"%a",	/* addrj: ADDRGP4 */
        -:  608:/* 197 */	"%0",	/* addrj: reg */
        -:  609:/* 198 */	"%0",	/* addrj: mem */
        -:  610:/* 199 */	"jmp %0\n",	/* stmt: JUMPV(addrj) */
        -:  611:/* 200 */	"%a:\n",	/* stmt: LABELV */
        -:  612:/* 201 */	"cmp %0,%1\nje %a\n",	/* stmt: EQI4(mem,rc) */
        -:  613:/* 202 */	"cmp %0,%1\njge %a\n",	/* stmt: GEI4(mem,rc) */
        -:  614:/* 203 */	"cmp %0,%1\njg %a\n",	/* stmt: GTI4(mem,rc) */
        -:  615:/* 204 */	"cmp %0,%1\njle %a\n",	/* stmt: LEI4(mem,rc) */
        -:  616:/* 205 */	"cmp %0,%1\njl %a\n",	/* stmt: LTI4(mem,rc) */
        -:  617:/* 206 */	"cmp %0,%1\njne %a\n",	/* stmt: NEI4(mem,rc) */
        -:  618:/* 207 */	"cmp %0,%1\njae %a\n",	/* stmt: GEU4(mem,rc) */
        -:  619:/* 208 */	"cmp %0,%1\nja  %a\n",	/* stmt: GTU4(mem,rc) */
        -:  620:/* 209 */	"cmp %0,%1\njbe %a\n",	/* stmt: LEU4(mem,rc) */
        -:  621:/* 210 */	"cmp %0,%1\njb  %a\n",	/* stmt: LTU4(mem,rc) */
        -:  622:/* 211 */	"cmp %0,%1\nje %a\n",	/* stmt: EQI4(reg,mrc1) */
        -:  623:/* 212 */	"cmp %0,%1\njge %a\n",	/* stmt: GEI4(reg,mrc1) */
        -:  624:/* 213 */	"cmp %0,%1\njg %a\n",	/* stmt: GTI4(reg,mrc1) */
        -:  625:/* 214 */	"cmp %0,%1\njle %a\n",	/* stmt: LEI4(reg,mrc1) */
        -:  626:/* 215 */	"cmp %0,%1\njl %a\n",	/* stmt: LTI4(reg,mrc1) */
        -:  627:/* 216 */	"cmp %0,%1\njne %a\n",	/* stmt: NEI4(reg,mrc1) */
        -:  628:/* 217 */	"cmp %0,%1\nje %a\n",	/* stmt: EQU4(reg,mrc1) */
        -:  629:/* 218 */	"cmp %0,%1\njae %a\n",	/* stmt: GEU4(reg,mrc1) */
        -:  630:/* 219 */	"cmp %0,%1\nja %a\n",	/* stmt: GTU4(reg,mrc1) */
        -:  631:/* 220 */	"cmp %0,%1\njbe %a\n",	/* stmt: LEU4(reg,mrc1) */
        -:  632:/* 221 */	"cmp %0,%1\njb %a\n",	/* stmt: LTU4(reg,mrc1) */
        -:  633:/* 222 */	"cmp %0,%1\njne %a\n",	/* stmt: NEU4(reg,mrc1) */
        -:  634:/* 223 */	" %0",	/* cmpf: memf */
        -:  635:/* 224 */	"p",	/* cmpf: reg */
        -:  636:/* 225 */	"fcomp%0\nfstsw ax\nsahf\nje %a\n",	/* stmt: EQF8(cmpf,reg) */
        -:  637:/* 226 */	"fcomp%0\nfstsw ax\nsahf\njbe %a\n",	/* stmt: GEF8(cmpf,reg) */
        -:  638:/* 227 */	"fcomp%0\nfstsw ax\nsahf\njb %a\n",	/* stmt: GTF8(cmpf,reg) */
        -:  639:/* 228 */	"fcomp%0\nfstsw ax\nsahf\njae %a\n",	/* stmt: LEF8(cmpf,reg) */
        -:  640:/* 229 */	"fcomp%0\nfstsw ax\nsahf\nja %a\n",	/* stmt: LTF8(cmpf,reg) */
        -:  641:/* 230 */	"fcomp%0\nfstsw ax\nsahf\njne %a\n",	/* stmt: NEF8(cmpf,reg) */
        -:  642:/* 231 */	"fcomp%0\nfstsw ax\nsahf\nje %a\n",	/* stmt: EQF4(cmpf,reg) */
        -:  643:/* 232 */	"fcomp%0\nfstsw ax\nsahf\njbe %a\n",	/* stmt: GEF4(cmpf,reg) */
        -:  644:/* 233 */	"fcomp%0\nfstsw ax\nsahf\njb %a\n",	/* stmt: GTF4(cmpf,reg) */
        -:  645:/* 234 */	"fcomp%0\nfstsw ax\nsahf\njae %a\n",	/* stmt: LEF4(cmpf,reg) */
        -:  646:/* 235 */	"fcomp%0\nfstsw ax\nsahf\nja %a\n",	/* stmt: LTF4(cmpf,reg) */
        -:  647:/* 236 */	"fcomp%0\nfstsw ax\nsahf\njne %a\n",	/* stmt: NEF4(cmpf,reg) */
        -:  648:/* 237 */	"call %0\nadd esp,%a\n",	/* reg: CALLI4(addrj) */
        -:  649:/* 238 */	"call %0\nadd esp,%a\n",	/* reg: CALLU4(addrj) */
        -:  650:/* 239 */	"call %0\nadd esp,%a\n",	/* reg: CALLP4(addrj) */
        -:  651:/* 240 */	"call %0\nadd esp,%a\n",	/* stmt: CALLV(addrj) */
        -:  652:/* 241 */	"call %0\nadd esp,%a\n",	/* reg: CALLF4(addrj) */
        -:  653:/* 242 */	"call %0\nadd esp,%a\n",	/* reg: CALLF8(addrj) */
        -:  654:/* 243 */	"call %0\nadd esp,%a\nfstp\n",	/* stmt: CALLF4(addrj) */
        -:  655:/* 244 */	"call %0\nadd esp,%a\nfstp\n",	/* stmt: CALLF8(addrj) */
        -:  656:/* 245 */	"# ret\n",	/* stmt: RETI4(reg) */
        -:  657:/* 246 */	"# ret\n",	/* stmt: RETU4(reg) */
        -:  658:/* 247 */	"# ret\n",	/* stmt: RETP4(reg) */
        -:  659:/* 248 */	"# ret\n",	/* stmt: RETF4(reg) */
        -:  660:/* 249 */	"# ret\n",	/* stmt: RETF8(reg) */
        -:  661:};
        -:  662:
        -:  663:static char _isinstruction[] = {
        -:  664:/* 0 */	0,
        -:  665:/* 1 */	1,	/* # read register\n */
        -:  666:/* 2 */	1,	/* # read register\n */
        -:  667:/* 3 */	1,	/* # read register\n */
        -:  668:/* 4 */	1,	/* # read register\n */
        -:  669:/* 5 */	1,	/* # read register\n */
        -:  670:/* 6 */	1,	/* # read register\n */
        -:  671:/* 7 */	1,	/* # read register\n */
        -:  672:/* 8 */	1,	/* # read register\n */
        -:  673:/* 9 */	1,	/* # read register\n */
        -:  674:/* 10 */	1,	/* # read register\n */
        -:  675:/* 11 */	1,	/* # read register\n */
        -:  676:/* 12 */	1,	/* # read register\n */
        -:  677:/* 13 */	1,	/* # write register\n */
        -:  678:/* 14 */	1,	/* # write register\n */
        -:  679:/* 15 */	1,	/* # write register\n */
        -:  680:/* 16 */	1,	/* # write register\n */
        -:  681:/* 17 */	1,	/* # write register\n */
        -:  682:/* 18 */	1,	/* # write register\n */
        -:  683:/* 19 */	1,	/* # write register\n */
        -:  684:/* 20 */	1,	/* # write register\n */
        -:  685:/* 21 */	1,	/* # write register\n */
        -:  686:/* 22 */	1,	/* # write register\n */
        -:  687:/* 23 */	1,	/* # write register\n */
        -:  688:/* 24 */	1,	/* # write register\n */
        -:  689:/* 25 */	0,	/* %a */
        -:  690:/* 26 */	0,	/* %a */
        -:  691:/* 27 */	0,	/* %a */
        -:  692:/* 28 */	0,	/* %a */
        -:  693:/* 29 */	0,	/* %a */
        -:  694:/* 30 */	0,	/* %a */
        -:  695:/* 31 */	0,	/* %a */
        -:  696:/* 32 */	0,	/* %a */
        -:  697:/* 33 */	0,	/* %a */
        -:  698:/* 34 */	0,	/* %a */
        -:  699:/* 35 */	0,	/*  */
        -:  700:/* 36 */	0,	/* (%a) */
        -:  701:/* 37 */	0,	/* (%0) */
        -:  702:/* 38 */	0,	/* (%a) */
        -:  703:/* 39 */	0,	/* [%0] */
        -:  704:/* 40 */	0,	/* %1[%0] */
        -:  705:/* 41 */	0,	/* %1[%0] */
        -:  706:/* 42 */	0,	/* %1[%0] */
        -:  707:/* 43 */	0,	/* (%a)[ebp] */
        -:  708:/* 44 */	0,	/* (%a)[ebp] */
        -:  709:/* 45 */	0,	/* %0 */
        -:  710:/* 46 */	0,	/* %0*2 */
        -:  711:/* 47 */	0,	/* %0*4 */
        -:  712:/* 48 */	0,	/* %0*8 */
        -:  713:/* 49 */	0,	/* 1 */
        -:  714:/* 50 */	0,	/* 1 */
        -:  715:/* 51 */	0,	/* 2 */
        -:  716:/* 52 */	0,	/* 2 */
        -:  717:/* 53 */	0,	/* 3 */
        -:  718:/* 54 */	0,	/* 3 */
        -:  719:/* 55 */	0,	/* %0*2 */
        -:  720:/* 56 */	0,	/* %0*4 */
        -:  721:/* 57 */	0,	/* %0*8 */
        -:  722:/* 58 */	0,	/* %0 */
        -:  723:/* 59 */	0,	/* %1[%0] */
        -:  724:/* 60 */	0,	/* %1[%0] */
        -:  725:/* 61 */	0,	/* %1[%0] */
        -:  726:/* 62 */	0,	/* [%0] */
        -:  727:/* 63 */	0,	/* byte ptr %0 */
        -:  728:/* 64 */	0,	/* word ptr %0 */
        -:  729:/* 65 */	0,	/* dword ptr %0 */
        -:  730:/* 66 */	0,	/* byte ptr %0 */
        -:  731:/* 67 */	0,	/* word ptr %0 */
        -:  732:/* 68 */	0,	/* dword ptr %0 */
        -:  733:/* 69 */	0,	/* dword ptr %0 */
        -:  734:/* 70 */	0,	/* %0 */
        -:  735:/* 71 */	0,	/* %0 */
        -:  736:/* 72 */	0,	/* %0 */
        -:  737:/* 73 */	0,	/* %0 */
        -:  738:/* 74 */	0,	/* %0 */
        -:  739:/* 75 */	0,	/* %0 */
        -:  740:/* 76 */	0,	/* %0 */
        -:  741:/* 77 */	0,	/* %0 */
        -:  742:/* 78 */	0,	/* %0 */
        -:  743:/* 79 */	0,	/* %0 */
        -:  744:/* 80 */	1,	/* lea %c,%0\n */
        -:  745:/* 81 */	1,	/* mov %c,%0\n */
        -:  746:/* 82 */	1,	/* # move\n */
        -:  747:/* 83 */	1,	/* # move\n */
        -:  748:/* 84 */	1,	/* # move\n */
        -:  749:/* 85 */	1,	/* # move\n */
        -:  750:/* 86 */	1,	/* # move\n */
        -:  751:/* 87 */	1,	/* # move\n */
        -:  752:/* 88 */	1,	/* # move\n */
        -:  753:/* 89 */	1,	/* ?mov %c,%0\nadd %c,%1\n */
        -:  754:/* 90 */	1,	/* ?mov %c,%0\nadd %c,%1\n */
        -:  755:/* 91 */	1,	/* ?mov %c,%0\nadd %c,%1\n */
        -:  756:/* 92 */	1,	/* ?mov %c,%0\nsub %c,%1\n */
        -:  757:/* 93 */	1,	/* ?mov %c,%0\nsub %c,%1\n */
        -:  758:/* 94 */	1,	/* ?mov %c,%0\nsub %c,%1\n */
        -:  759:/* 95 */	1,	/* ?mov %c,%0\nand %c,%1\n */
        -:  760:/* 96 */	1,	/* ?mov %c,%0\nor %c,%1\n */
        -:  761:/* 97 */	1,	/* ?mov %c,%0\nxor %c,%1\n */
        -:  762:/* 98 */	1,	/* ?mov %c,%0\nand %c,%1\n */
        -:  763:/* 99 */	1,	/* ?mov %c,%0\nor %c,%1\n */
        -:  764:/* 100 */	1,	/* ?mov %c,%0\nxor %c,%1\n */
        -:  765:/* 101 */	1,	/* inc %1\n */
        -:  766:/* 102 */	1,	/* inc %1\n */
        -:  767:/* 103 */	1,	/* inc %1\n */
        -:  768:/* 104 */	1,	/* dec %1\n */
        -:  769:/* 105 */	1,	/* dec %1\n */
        -:  770:/* 106 */	1,	/* dec %1\n */
        -:  771:/* 107 */	1,	/* add %1,%2\n */
        -:  772:/* 108 */	1,	/* sub %1,%2\n */
        -:  773:/* 109 */	1,	/* add %1,%2\n */
        -:  774:/* 110 */	1,	/* sub %1,%2\n */
        -:  775:/* 111 */	1,	/* and %1,%2\n */
        -:  776:/* 112 */	1,	/* or %1,%2\n */
        -:  777:/* 113 */	1,	/* xor %1,%2\n */
        -:  778:/* 114 */	1,	/* and %1,%2\n */
        -:  779:/* 115 */	1,	/* or %1,%2\n */
        -:  780:/* 116 */	1,	/* xor %1,%2\n */
        -:  781:/* 117 */	1,	/* ?mov %c,%0\nnot %c\n */
        -:  782:/* 118 */	1,	/* ?mov %c,%0\nnot %c\n */
        -:  783:/* 119 */	1,	/* ?mov %c,%0\nneg %c\n */
        -:  784:/* 120 */	1,	/* not %1\n */
        -:  785:/* 121 */	1,	/* not %1\n */
        -:  786:/* 122 */	1,	/* neg %1\n */
        -:  787:/* 123 */	1,	/* ?mov %c,%0\nsal %c,%1\n */
        -:  788:/* 124 */	1,	/* ?mov %c,%0\nshl %c,%1\n */
        -:  789:/* 125 */	1,	/* ?mov %c,%0\nsar %c,%1\n */
        -:  790:/* 126 */	1,	/* ?mov %c,%0\nshr %c,%1\n */
        -:  791:/* 127 */	1,	/* sal %1,%2\n */
        -:  792:/* 128 */	1,	/* shl %1,%2\n */
        -:  793:/* 129 */	1,	/* sar %1,%2\n */
        -:  794:/* 130 */	1,	/* shr %1,%2\n */
        -:  795:/* 131 */	0,	/* %a */
        -:  796:/* 132 */	1,	/* ?mov %c,%0\nmov ecx,%1\nsal %c,cl\n */
        -:  797:/* 133 */	1,	/* ?mov %c,%0\nmov ecx,%1\nshl %c,cl\n */
        -:  798:/* 134 */	1,	/* ?mov %c,%0\nmov ecx,%1\nsar %c,cl\n */
        -:  799:/* 135 */	1,	/* ?mov %c,%0\nmov ecx,%1\nshr %c,cl\n */
        -:  800:/* 136 */	1,	/* ?mov %c,%0\nimul %c,%1\n */
        -:  801:/* 137 */	1,	/* imul %c,%1,%0\n */
        -:  802:/* 138 */	1,	/* mul %1\n */
        -:  803:/* 139 */	1,	/* xor edx,edx\ndiv %1\n */
        -:  804:/* 140 */	1,	/* xor edx,edx\ndiv %1\n */
        -:  805:/* 141 */	1,	/* cdq\nidiv %1\n */
        -:  806:/* 142 */	1,	/* cdq\nidiv %1\n */
        -:  807:/* 143 */	1,	/* mov %c,%0\n */
        -:  808:/* 144 */	1,	/* mov %c,%0\n */
        -:  809:/* 145 */	1,	/* movsx %c,byte ptr %0\n */
        -:  810:/* 146 */	1,	/* movsx %c,word ptr %0\n */
        -:  811:/* 147 */	1,	/* movzx %c,byte ptr %0\n */
        -:  812:/* 148 */	1,	/* movzx %c,word ptr %0\n */
        -:  813:/* 149 */	1,	/* # extend\n */
        -:  814:/* 150 */	1,	/* # extend\n */
        -:  815:/* 151 */	1,	/* # extend\n */
        -:  816:/* 152 */	1,	/* # extend\n */
        -:  817:/* 153 */	1,	/* # truncate\n */
        -:  818:/* 154 */	1,	/* # truncate\n */
        -:  819:/* 155 */	1,	/* # truncate\n */
        -:  820:/* 156 */	1,	/* # truncate\n */
        -:  821:/* 157 */	1,	/* mov byte ptr %0,%1\n */
        -:  822:/* 158 */	1,	/* mov word ptr %0,%1\n */
        -:  823:/* 159 */	1,	/* mov dword ptr %0,%1\n */
        -:  824:/* 160 */	1,	/* mov byte ptr %0,%1\n */
        -:  825:/* 161 */	1,	/* mov word ptr %0,%1\n */
        -:  826:/* 162 */	1,	/* mov dword ptr %0,%1\n */
        -:  827:/* 163 */	1,	/* mov dword ptr %0,%1\n */
        -:  828:/* 164 */	1,	/* push %0\n */
        -:  829:/* 165 */	1,	/* push %0\n */
        -:  830:/* 166 */	1,	/* push %0\n */
        -:  831:/* 167 */	1,	/* mov ecx,%a\nrep movsb\n */
        -:  832:/* 168 */	1,	/* sub esp,%a\nmov edi,esp\nmov ecx,%a\nrep movsb\n */
        -:  833:/* 169 */	0,	/* qword ptr %0 */
        -:  834:/* 170 */	0,	/* dword ptr %0 */
        -:  835:/* 171 */	0,	/* dword ptr %0 */
        -:  836:/* 172 */	1,	/* fld %0\n */
        -:  837:/* 173 */	1,	/* fstp qword ptr %0\n */
        -:  838:/* 174 */	1,	/* fstp dword ptr %0\n */
        -:  839:/* 175 */	1,	/* fstp dword ptr %0\n */
        -:  840:/* 176 */	1,	/* sub esp,8\nfstp qword ptr [esp]\n */
        -:  841:/* 177 */	1,	/* sub esp,4\nfstp dword ptr [esp]\n */
        -:  842:/* 178 */	1,	/* fchs\n */
        -:  843:/* 179 */	1,	/* fchs\n */
        -:  844:/* 180 */	0,	/*  %0 */
        -:  845:/* 181 */	0,	/* p st(1),st */
        -:  846:/* 182 */	1,	/* fadd%1\n */
        -:  847:/* 183 */	1,	/* fadd%1\n */
        -:  848:/* 184 */	1,	/* fdiv%1\n */
        -:  849:/* 185 */	1,	/* fdiv%1\n */
        -:  850:/* 186 */	1,	/* fmul%1\n */
        -:  851:/* 187 */	1,	/* fmul%1\n */
        -:  852:/* 188 */	1,	/* fsub%1\n */
        -:  853:/* 189 */	1,	/* fsub%1\n */
        -:  854:/* 190 */	1,	/* # CVFF8\n */
        -:  855:/* 191 */	1,	/* sub esp,4\nfstp dword ptr 0[esp]\nfld dword ptr 0[esp]\nadd esp,4\n */
        -:  856:/* 192 */	1,	/* call __ftol\n */
        -:  857:/* 193 */	1,	/* fild dword ptr %0\n */
        -:  858:/* 194 */	1,	/* push %0\nfild dword ptr 0[esp]\nadd esp,4\n */
        -:  859:/* 195 */	1,	/* push %0\nfild dword ptr 0[esp]\nadd esp,4\n */
        -:  860:/* 196 */	0,	/* %a */
        -:  861:/* 197 */	0,	/* %0 */
        -:  862:/* 198 */	0,	/* %0 */
        -:  863:/* 199 */	1,	/* jmp %0\n */
        -:  864:/* 200 */	1,	/* %a:\n */
        -:  865:/* 201 */	1,	/* cmp %0,%1\nje %a\n */
        -:  866:/* 202 */	1,	/* cmp %0,%1\njge %a\n */
        -:  867:/* 203 */	1,	/* cmp %0,%1\njg %a\n */
        -:  868:/* 204 */	1,	/* cmp %0,%1\njle %a\n */
        -:  869:/* 205 */	1,	/* cmp %0,%1\njl %a\n */
        -:  870:/* 206 */	1,	/* cmp %0,%1\njne %a\n */
        -:  871:/* 207 */	1,	/* cmp %0,%1\njae %a\n */
        -:  872:/* 208 */	1,	/* cmp %0,%1\nja  %a\n */
        -:  873:/* 209 */	1,	/* cmp %0,%1\njbe %a\n */
        -:  874:/* 210 */	1,	/* cmp %0,%1\njb  %a\n */
        -:  875:/* 211 */	1,	/* cmp %0,%1\nje %a\n */
        -:  876:/* 212 */	1,	/* cmp %0,%1\njge %a\n */
        -:  877:/* 213 */	1,	/* cmp %0,%1\njg %a\n */
        -:  878:/* 214 */	1,	/* cmp %0,%1\njle %a\n */
        -:  879:/* 215 */	1,	/* cmp %0,%1\njl %a\n */
        -:  880:/* 216 */	1,	/* cmp %0,%1\njne %a\n */
        -:  881:/* 217 */	1,	/* cmp %0,%1\nje %a\n */
        -:  882:/* 218 */	1,	/* cmp %0,%1\njae %a\n */
        -:  883:/* 219 */	1,	/* cmp %0,%1\nja %a\n */
        -:  884:/* 220 */	1,	/* cmp %0,%1\njbe %a\n */
        -:  885:/* 221 */	1,	/* cmp %0,%1\njb %a\n */
        -:  886:/* 222 */	1,	/* cmp %0,%1\njne %a\n */
        -:  887:/* 223 */	0,	/*  %0 */
        -:  888:/* 224 */	0,	/* p */
        -:  889:/* 225 */	1,	/* fcomp%0\nfstsw ax\nsahf\nje %a\n */
        -:  890:/* 226 */	1,	/* fcomp%0\nfstsw ax\nsahf\njbe %a\n */
        -:  891:/* 227 */	1,	/* fcomp%0\nfstsw ax\nsahf\njb %a\n */
        -:  892:/* 228 */	1,	/* fcomp%0\nfstsw ax\nsahf\njae %a\n */
        -:  893:/* 229 */	1,	/* fcomp%0\nfstsw ax\nsahf\nja %a\n */
        -:  894:/* 230 */	1,	/* fcomp%0\nfstsw ax\nsahf\njne %a\n */
        -:  895:/* 231 */	1,	/* fcomp%0\nfstsw ax\nsahf\nje %a\n */
        -:  896:/* 232 */	1,	/* fcomp%0\nfstsw ax\nsahf\njbe %a\n */
        -:  897:/* 233 */	1,	/* fcomp%0\nfstsw ax\nsahf\njb %a\n */
        -:  898:/* 234 */	1,	/* fcomp%0\nfstsw ax\nsahf\njae %a\n */
        -:  899:/* 235 */	1,	/* fcomp%0\nfstsw ax\nsahf\nja %a\n */
        -:  900:/* 236 */	1,	/* fcomp%0\nfstsw ax\nsahf\njne %a\n */
        -:  901:/* 237 */	1,	/* call %0\nadd esp,%a\n */
        -:  902:/* 238 */	1,	/* call %0\nadd esp,%a\n */
        -:  903:/* 239 */	1,	/* call %0\nadd esp,%a\n */
        -:  904:/* 240 */	1,	/* call %0\nadd esp,%a\n */
        -:  905:/* 241 */	1,	/* call %0\nadd esp,%a\n */
        -:  906:/* 242 */	1,	/* call %0\nadd esp,%a\n */
        -:  907:/* 243 */	1,	/* call %0\nadd esp,%a\nfstp\n */
        -:  908:/* 244 */	1,	/* call %0\nadd esp,%a\nfstp\n */
        -:  909:/* 245 */	1,	/* # ret\n */
        -:  910:/* 246 */	1,	/* # ret\n */
        -:  911:/* 247 */	1,	/* # ret\n */
        -:  912:/* 248 */	1,	/* # ret\n */
        -:  913:/* 249 */	1,	/* # ret\n */
        -:  914:};
        -:  915:
        -:  916:static char *_string[] = {
        -:  917:/* 0 */	0,
        -:  918:/* 1 */	"reg: INDIRI1(VREGP)",
        -:  919:/* 2 */	"reg: INDIRU1(VREGP)",
        -:  920:/* 3 */	"reg: INDIRI2(VREGP)",
        -:  921:/* 4 */	"reg: INDIRU2(VREGP)",
        -:  922:/* 5 */	"reg: INDIRF4(VREGP)",
        -:  923:/* 6 */	"reg: INDIRI4(VREGP)",
        -:  924:/* 7 */	"reg: INDIRP4(VREGP)",
        -:  925:/* 8 */	"reg: INDIRU4(VREGP)",
        -:  926:/* 9 */	"reg: INDIRF8(VREGP)",
        -:  927:/* 10 */	"reg: INDIRI8(VREGP)",
        -:  928:/* 11 */	"reg: INDIRP8(VREGP)",
        -:  929:/* 12 */	"reg: INDIRU8(VREGP)",
        -:  930:/* 13 */	"stmt: ASGNI1(VREGP,reg)",
        -:  931:/* 14 */	"stmt: ASGNU1(VREGP,reg)",
        -:  932:/* 15 */	"stmt: ASGNI2(VREGP,reg)",
        -:  933:/* 16 */	"stmt: ASGNU2(VREGP,reg)",
        -:  934:/* 17 */	"stmt: ASGNF4(VREGP,reg)",
        -:  935:/* 18 */	"stmt: ASGNI4(VREGP,reg)",
        -:  936:/* 19 */	"stmt: ASGNP4(VREGP,reg)",
        -:  937:/* 20 */	"stmt: ASGNU4(VREGP,reg)",
        -:  938:/* 21 */	"stmt: ASGNF8(VREGP,reg)",
        -:  939:/* 22 */	"stmt: ASGNI8(VREGP,reg)",
        -:  940:/* 23 */	"stmt: ASGNP8(VREGP,reg)",
        -:  941:/* 24 */	"stmt: ASGNU8(VREGP,reg)",
        -:  942:/* 25 */	"con: CNSTI1",
        -:  943:/* 26 */	"con: CNSTU1",
        -:  944:/* 27 */	"con: CNSTI2",
        -:  945:/* 28 */	"con: CNSTU2",
        -:  946:/* 29 */	"con: CNSTI4",
        -:  947:/* 30 */	"con: CNSTU4",
        -:  948:/* 31 */	"con: CNSTP4",
        -:  949:/* 32 */	"con: CNSTI8",
        -:  950:/* 33 */	"con: CNSTU8",
        -:  951:/* 34 */	"con: CNSTP8",
        -:  952:/* 35 */	"stmt: reg",
        -:  953:/* 36 */	"acon: ADDRGP4",
        -:  954:/* 37 */	"acon: con",
        -:  955:/* 38 */	"base: ADDRGP4",
        -:  956:/* 39 */	"base: reg",
        -:  957:/* 40 */	"base: ADDI4(reg,acon)",
        -:  958:/* 41 */	"base: ADDP4(reg,acon)",
        -:  959:/* 42 */	"base: ADDU4(reg,acon)",
        -:  960:/* 43 */	"base: ADDRFP4",
        -:  961:/* 44 */	"base: ADDRLP4",
        -:  962:/* 45 */	"index: reg",
        -:  963:/* 46 */	"index: LSHI4(reg,con1)",
        -:  964:/* 47 */	"index: LSHI4(reg,con2)",
        -:  965:/* 48 */	"index: LSHI4(reg,con3)",
        -:  966:/* 49 */	"con1: CNSTI4",
        -:  967:/* 50 */	"con1: CNSTU4",
        -:  968:/* 51 */	"con2: CNSTI4",
        -:  969:/* 52 */	"con2: CNSTU4",
        -:  970:/* 53 */	"con3: CNSTI4",
        -:  971:/* 54 */	"con3: CNSTU4",
        -:  972:/* 55 */	"index: LSHU4(reg,con1)",
        -:  973:/* 56 */	"index: LSHU4(reg,con2)",
        -:  974:/* 57 */	"index: LSHU4(reg,con3)",
        -:  975:/* 58 */	"addr: base",
        -:  976:/* 59 */	"addr: ADDI4(index,base)",
        -:  977:/* 60 */	"addr: ADDP4(index,base)",
        -:  978:/* 61 */	"addr: ADDU4(index,base)",
        -:  979:/* 62 */	"addr: index",
        -:  980:/* 63 */	"mem: INDIRI1(addr)",
        -:  981:/* 64 */	"mem: INDIRI2(addr)",
        -:  982:/* 65 */	"mem: INDIRI4(addr)",
        -:  983:/* 66 */	"mem: INDIRU1(addr)",
        -:  984:/* 67 */	"mem: INDIRU2(addr)",
        -:  985:/* 68 */	"mem: INDIRU4(addr)",
        -:  986:/* 69 */	"mem: INDIRP4(addr)",
        -:  987:/* 70 */	"rc: reg",
        -:  988:/* 71 */	"rc: con",
        -:  989:/* 72 */	"mr: reg",
        -:  990:/* 73 */	"mr: mem",
        -:  991:/* 74 */	"mrc0: mem",
        -:  992:/* 75 */	"mrc0: rc",
        -:  993:/* 76 */	"mrc1: mem",
        -:  994:/* 77 */	"mrc1: rc",
        -:  995:/* 78 */	"mrc3: mem",
        -:  996:/* 79 */	"mrc3: rc",
        -:  997:/* 80 */	"reg: addr",
        -:  998:/* 81 */	"reg: mrc0",
        -:  999:/* 82 */	"reg: LOADI1(reg)",
        -: 1000:/* 83 */	"reg: LOADI2(reg)",
        -: 1001:/* 84 */	"reg: LOADI4(reg)",
        -: 1002:/* 85 */	"reg: LOADU1(reg)",
        -: 1003:/* 86 */	"reg: LOADU2(reg)",
        -: 1004:/* 87 */	"reg: LOADU4(reg)",
        -: 1005:/* 88 */	"reg: LOADP4(reg)",
        -: 1006:/* 89 */	"reg: ADDI4(reg,mrc1)",
        -: 1007:/* 90 */	"reg: ADDP4(reg,mrc1)",
        -: 1008:/* 91 */	"reg: ADDU4(reg,mrc1)",
        -: 1009:/* 92 */	"reg: SUBI4(reg,mrc1)",
        -: 1010:/* 93 */	"reg: SUBP4(reg,mrc1)",
        -: 1011:/* 94 */	"reg: SUBU4(reg,mrc1)",
        -: 1012:/* 95 */	"reg: BANDI4(reg,mrc1)",
        -: 1013:/* 96 */	"reg: BORI4(reg,mrc1)",
        -: 1014:/* 97 */	"reg: BXORI4(reg,mrc1)",
        -: 1015:/* 98 */	"reg: BANDU4(reg,mrc1)",
        -: 1016:/* 99 */	"reg: BORU4(reg,mrc1)",
        -: 1017:/* 100 */	"reg: BXORU4(reg,mrc1)",
        -: 1018:/* 101 */	"stmt: ASGNI4(addr,ADDI4(mem,con1))",
        -: 1019:/* 102 */	"stmt: ASGNI4(addr,ADDU4(mem,con1))",
        -: 1020:/* 103 */	"stmt: ASGNP4(addr,ADDP4(mem,con1))",
        -: 1021:/* 104 */	"stmt: ASGNI4(addr,SUBI4(mem,con1))",
        -: 1022:/* 105 */	"stmt: ASGNI4(addr,SUBU4(mem,con1))",
        -: 1023:/* 106 */	"stmt: ASGNP4(addr,SUBP4(mem,con1))",
        -: 1024:/* 107 */	"stmt: ASGNI4(addr,ADDI4(mem,rc))",
        -: 1025:/* 108 */	"stmt: ASGNI4(addr,SUBI4(mem,rc))",
        -: 1026:/* 109 */	"stmt: ASGNU4(addr,ADDU4(mem,rc))",
        -: 1027:/* 110 */	"stmt: ASGNU4(addr,SUBU4(mem,rc))",
        -: 1028:/* 111 */	"stmt: ASGNI4(addr,BANDI4(mem,rc))",
        -: 1029:/* 112 */	"stmt: ASGNI4(addr,BORI4(mem,rc))",
        -: 1030:/* 113 */	"stmt: ASGNI4(addr,BXORI4(mem,rc))",
        -: 1031:/* 114 */	"stmt: ASGNU4(addr,BANDU4(mem,rc))",
        -: 1032:/* 115 */	"stmt: ASGNU4(addr,BORU4(mem,rc))",
        -: 1033:/* 116 */	"stmt: ASGNU4(addr,BXORU4(mem,rc))",
        -: 1034:/* 117 */	"reg: BCOMI4(reg)",
        -: 1035:/* 118 */	"reg: BCOMU4(reg)",
        -: 1036:/* 119 */	"reg: NEGI4(reg)",
        -: 1037:/* 120 */	"stmt: ASGNI4(addr,BCOMI4(mem))",
        -: 1038:/* 121 */	"stmt: ASGNU4(addr,BCOMU4(mem))",
        -: 1039:/* 122 */	"stmt: ASGNI4(addr,NEGI4(mem))",
        -: 1040:/* 123 */	"reg: LSHI4(reg,con5)",
        -: 1041:/* 124 */	"reg: LSHU4(reg,con5)",
        -: 1042:/* 125 */	"reg: RSHI4(reg,con5)",
        -: 1043:/* 126 */	"reg: RSHU4(reg,con5)",
        -: 1044:/* 127 */	"stmt: ASGNI4(addr,LSHI4(mem,con5))",
        -: 1045:/* 128 */	"stmt: ASGNI4(addr,LSHU4(mem,con5))",
        -: 1046:/* 129 */	"stmt: ASGNI4(addr,RSHI4(mem,con5))",
        -: 1047:/* 130 */	"stmt: ASGNI4(addr,RSHU4(mem,con5))",
        -: 1048:/* 131 */	"con5: CNSTI4",
        -: 1049:/* 132 */	"reg: LSHI4(reg,reg)",
        -: 1050:/* 133 */	"reg: LSHU4(reg,reg)",
        -: 1051:/* 134 */	"reg: RSHI4(reg,reg)",
        -: 1052:/* 135 */	"reg: RSHU4(reg,reg)",
        -: 1053:/* 136 */	"reg: MULI4(reg,mrc3)",
        -: 1054:/* 137 */	"reg: MULI4(con,mr)",
        -: 1055:/* 138 */	"reg: MULU4(reg,mr)",
        -: 1056:/* 139 */	"reg: DIVU4(reg,reg)",
        -: 1057:/* 140 */	"reg: MODU4(reg,reg)",
        -: 1058:/* 141 */	"reg: DIVI4(reg,reg)",
        -: 1059:/* 142 */	"reg: MODI4(reg,reg)",
        -: 1060:/* 143 */	"reg: CVPU4(reg)",
        -: 1061:/* 144 */	"reg: CVUP4(reg)",
        -: 1062:/* 145 */	"reg: CVII4(INDIRI1(addr))",
        -: 1063:/* 146 */	"reg: CVII4(INDIRI2(addr))",
        -: 1064:/* 147 */	"reg: CVUU4(INDIRU1(addr))",
        -: 1065:/* 148 */	"reg: CVUU4(INDIRU2(addr))",
        -: 1066:/* 149 */	"reg: CVII4(reg)",
        -: 1067:/* 150 */	"reg: CVIU4(reg)",
        -: 1068:/* 151 */	"reg: CVUI4(reg)",
        -: 1069:/* 152 */	"reg: CVUU4(reg)",
        -: 1070:/* 153 */	"reg: CVII1(reg)",
        -: 1071:/* 154 */	"reg: CVII2(reg)",
        -: 1072:/* 155 */	"reg: CVUU1(reg)",
        -: 1073:/* 156 */	"reg: CVUU2(reg)",
        -: 1074:/* 157 */	"stmt: ASGNI1(addr,rc)",
        -: 1075:/* 158 */	"stmt: ASGNI2(addr,rc)",
        -: 1076:/* 159 */	"stmt: ASGNI4(addr,rc)",
        -: 1077:/* 160 */	"stmt: ASGNU1(addr,rc)",
        -: 1078:/* 161 */	"stmt: ASGNU2(addr,rc)",
        -: 1079:/* 162 */	"stmt: ASGNU4(addr,rc)",
        -: 1080:/* 163 */	"stmt: ASGNP4(addr,rc)",
        -: 1081:/* 164 */	"stmt: ARGI4(mrc3)",
        -: 1082:/* 165 */	"stmt: ARGU4(mrc3)",
        -: 1083:/* 166 */	"stmt: ARGP4(mrc3)",
        -: 1084:/* 167 */	"stmt: ASGNB(reg,INDIRB(reg))",
        -: 1085:/* 168 */	"stmt: ARGB(INDIRB(reg))",
        -: 1086:/* 169 */	"memf: INDIRF8(addr)",
        -: 1087:/* 170 */	"memf: INDIRF4(addr)",
        -: 1088:/* 171 */	"memf: CVFF8(INDIRF4(addr))",
        -: 1089:/* 172 */	"reg: memf",
        -: 1090:/* 173 */	"stmt: ASGNF8(addr,reg)",
        -: 1091:/* 174 */	"stmt: ASGNF4(addr,reg)",
        -: 1092:/* 175 */	"stmt: ASGNF4(addr,CVFF4(reg))",
        -: 1093:/* 176 */	"stmt: ARGF8(reg)",
        -: 1094:/* 177 */	"stmt: ARGF4(reg)",
        -: 1095:/* 178 */	"reg: NEGF8(reg)",
        -: 1096:/* 179 */	"reg: NEGF4(reg)",
        -: 1097:/* 180 */	"flt: memf",
        -: 1098:/* 181 */	"flt: reg",
        -: 1099:/* 182 */	"reg: ADDF8(reg,flt)",
        -: 1100:/* 183 */	"reg: ADDF4(reg,flt)",
        -: 1101:/* 184 */	"reg: DIVF8(reg,flt)",
        -: 1102:/* 185 */	"reg: DIVF4(reg,flt)",
        -: 1103:/* 186 */	"reg: MULF8(reg,flt)",
        -: 1104:/* 187 */	"reg: MULF4(reg,flt)",
        -: 1105:/* 188 */	"reg: SUBF8(reg,flt)",
        -: 1106:/* 189 */	"reg: SUBF4(reg,flt)",
        -: 1107:/* 190 */	"reg: CVFF8(reg)",
        -: 1108:/* 191 */	"reg: CVFF4(reg)",
        -: 1109:/* 192 */	"reg: CVFI4(reg)",
        -: 1110:/* 193 */	"reg: CVIF8(INDIRI4(addr))",
        -: 1111:/* 194 */	"reg: CVIF4(reg)",
        -: 1112:/* 195 */	"reg: CVIF8(reg)",
        -: 1113:/* 196 */	"addrj: ADDRGP4",
        -: 1114:/* 197 */	"addrj: reg",
        -: 1115:/* 198 */	"addrj: mem",
        -: 1116:/* 199 */	"stmt: JUMPV(addrj)",
        -: 1117:/* 200 */	"stmt: LABELV",
        -: 1118:/* 201 */	"stmt: EQI4(mem,rc)",
        -: 1119:/* 202 */	"stmt: GEI4(mem,rc)",
        -: 1120:/* 203 */	"stmt: GTI4(mem,rc)",
        -: 1121:/* 204 */	"stmt: LEI4(mem,rc)",
        -: 1122:/* 205 */	"stmt: LTI4(mem,rc)",
        -: 1123:/* 206 */	"stmt: NEI4(mem,rc)",
        -: 1124:/* 207 */	"stmt: GEU4(mem,rc)",
        -: 1125:/* 208 */	"stmt: GTU4(mem,rc)",
        -: 1126:/* 209 */	"stmt: LEU4(mem,rc)",
        -: 1127:/* 210 */	"stmt: LTU4(mem,rc)",
        -: 1128:/* 211 */	"stmt: EQI4(reg,mrc1)",
        -: 1129:/* 212 */	"stmt: GEI4(reg,mrc1)",
        -: 1130:/* 213 */	"stmt: GTI4(reg,mrc1)",
        -: 1131:/* 214 */	"stmt: LEI4(reg,mrc1)",
        -: 1132:/* 215 */	"stmt: LTI4(reg,mrc1)",
        -: 1133:/* 216 */	"stmt: NEI4(reg,mrc1)",
        -: 1134:/* 217 */	"stmt: EQU4(reg,mrc1)",
        -: 1135:/* 218 */	"stmt: GEU4(reg,mrc1)",
        -: 1136:/* 219 */	"stmt: GTU4(reg,mrc1)",
        -: 1137:/* 220 */	"stmt: LEU4(reg,mrc1)",
        -: 1138:/* 221 */	"stmt: LTU4(reg,mrc1)",
        -: 1139:/* 222 */	"stmt: NEU4(reg,mrc1)",
        -: 1140:/* 223 */	"cmpf: memf",
        -: 1141:/* 224 */	"cmpf: reg",
        -: 1142:/* 225 */	"stmt: EQF8(cmpf,reg)",
        -: 1143:/* 226 */	"stmt: GEF8(cmpf,reg)",
        -: 1144:/* 227 */	"stmt: GTF8(cmpf,reg)",
        -: 1145:/* 228 */	"stmt: LEF8(cmpf,reg)",
        -: 1146:/* 229 */	"stmt: LTF8(cmpf,reg)",
        -: 1147:/* 230 */	"stmt: NEF8(cmpf,reg)",
        -: 1148:/* 231 */	"stmt: EQF4(cmpf,reg)",
        -: 1149:/* 232 */	"stmt: GEF4(cmpf,reg)",
        -: 1150:/* 233 */	"stmt: GTF4(cmpf,reg)",
        -: 1151:/* 234 */	"stmt: LEF4(cmpf,reg)",
        -: 1152:/* 235 */	"stmt: LTF4(cmpf,reg)",
        -: 1153:/* 236 */	"stmt: NEF4(cmpf,reg)",
        -: 1154:/* 237 */	"reg: CALLI4(addrj)",
        -: 1155:/* 238 */	"reg: CALLU4(addrj)",
        -: 1156:/* 239 */	"reg: CALLP4(addrj)",
        -: 1157:/* 240 */	"stmt: CALLV(addrj)",
        -: 1158:/* 241 */	"reg: CALLF4(addrj)",
        -: 1159:/* 242 */	"reg: CALLF8(addrj)",
        -: 1160:/* 243 */	"stmt: CALLF4(addrj)",
        -: 1161:/* 244 */	"stmt: CALLF8(addrj)",
        -: 1162:/* 245 */	"stmt: RETI4(reg)",
        -: 1163:/* 246 */	"stmt: RETU4(reg)",
        -: 1164:/* 247 */	"stmt: RETP4(reg)",
        -: 1165:/* 248 */	"stmt: RETF4(reg)",
        -: 1166:/* 249 */	"stmt: RETF8(reg)",
        -: 1167:};
        -: 1168:
        -: 1169:static short _decode_stmt[] = {
        -: 1170:	0,
        -: 1171:	13,
        -: 1172:	14,
        -: 1173:	15,
        -: 1174:	16,
        -: 1175:	17,
        -: 1176:	18,
        -: 1177:	19,
        -: 1178:	20,
        -: 1179:	21,
        -: 1180:	22,
        -: 1181:	23,
        -: 1182:	24,
        -: 1183:	35,
        -: 1184:	101,
        -: 1185:	102,
        -: 1186:	103,
        -: 1187:	104,
        -: 1188:	105,
        -: 1189:	106,
        -: 1190:	107,
        -: 1191:	108,
        -: 1192:	109,
        -: 1193:	110,
        -: 1194:	111,
        -: 1195:	112,
        -: 1196:	113,
        -: 1197:	114,
        -: 1198:	115,
        -: 1199:	116,
        -: 1200:	120,
        -: 1201:	121,
        -: 1202:	122,
        -: 1203:	127,
        -: 1204:	128,
        -: 1205:	129,
        -: 1206:	130,
        -: 1207:	157,
        -: 1208:	158,
        -: 1209:	159,
        -: 1210:	160,
        -: 1211:	161,
        -: 1212:	162,
        -: 1213:	163,
        -: 1214:	164,
        -: 1215:	165,
        -: 1216:	166,
        -: 1217:	167,
        -: 1218:	168,
        -: 1219:	173,
        -: 1220:	174,
        -: 1221:	175,
        -: 1222:	176,
        -: 1223:	177,
        -: 1224:	199,
        -: 1225:	200,
        -: 1226:	201,
        -: 1227:	202,
        -: 1228:	203,
        -: 1229:	204,
        -: 1230:	205,
        -: 1231:	206,
        -: 1232:	207,
        -: 1233:	208,
        -: 1234:	209,
        -: 1235:	210,
        -: 1236:	211,
        -: 1237:	212,
        -: 1238:	213,
        -: 1239:	214,
        -: 1240:	215,
        -: 1241:	216,
        -: 1242:	217,
        -: 1243:	218,
        -: 1244:	219,
        -: 1245:	220,
        -: 1246:	221,
        -: 1247:	222,
        -: 1248:	225,
        -: 1249:	226,
        -: 1250:	227,
        -: 1251:	228,
        -: 1252:	229,
        -: 1253:	230,
        -: 1254:	231,
        -: 1255:	232,
        -: 1256:	233,
        -: 1257:	234,
        -: 1258:	235,
        -: 1259:	236,
        -: 1260:	240,
        -: 1261:	243,
        -: 1262:	244,
        -: 1263:	245,
        -: 1264:	246,
        -: 1265:	247,
        -: 1266:	248,
        -: 1267:	249,
        -: 1268:};
        -: 1269:
        -: 1270:static short _decode_reg[] = {
        -: 1271:	0,
        -: 1272:	1,
        -: 1273:	2,
        -: 1274:	3,
        -: 1275:	4,
        -: 1276:	5,
        -: 1277:	6,
        -: 1278:	7,
        -: 1279:	8,
        -: 1280:	9,
        -: 1281:	10,
        -: 1282:	11,
        -: 1283:	12,
        -: 1284:	80,
        -: 1285:	81,
        -: 1286:	82,
        -: 1287:	83,
        -: 1288:	84,
        -: 1289:	85,
        -: 1290:	86,
        -: 1291:	87,
        -: 1292:	88,
        -: 1293:	89,
        -: 1294:	90,
        -: 1295:	91,
        -: 1296:	92,
        -: 1297:	93,
        -: 1298:	94,
        -: 1299:	95,
        -: 1300:	96,
        -: 1301:	97,
        -: 1302:	98,
        -: 1303:	99,
        -: 1304:	100,
        -: 1305:	117,
        -: 1306:	118,
        -: 1307:	119,
        -: 1308:	123,
        -: 1309:	124,
        -: 1310:	125,
        -: 1311:	126,
        -: 1312:	132,
        -: 1313:	133,
        -: 1314:	134,
        -: 1315:	135,
        -: 1316:	136,
        -: 1317:	137,
        -: 1318:	138,
        -: 1319:	139,
        -: 1320:	140,
        -: 1321:	141,
        -: 1322:	142,
        -: 1323:	143,
        -: 1324:	144,
        -: 1325:	145,
        -: 1326:	146,
        -: 1327:	147,
        -: 1328:	148,
        -: 1329:	149,
        -: 1330:	150,
        -: 1331:	151,
        -: 1332:	152,
        -: 1333:	153,
        -: 1334:	154,
        -: 1335:	155,
        -: 1336:	156,
        -: 1337:	172,
        -: 1338:	178,
        -: 1339:	179,
        -: 1340:	182,
        -: 1341:	183,
        -: 1342:	184,
        -: 1343:	185,
        -: 1344:	186,
        -: 1345:	187,
        -: 1346:	188,
        -: 1347:	189,
        -: 1348:	190,
        -: 1349:	191,
        -: 1350:	192,
        -: 1351:	193,
        -: 1352:	194,
        -: 1353:	195,
        -: 1354:	237,
        -: 1355:	238,
        -: 1356:	239,
        -: 1357:	241,
        -: 1358:	242,
        -: 1359:};
        -: 1360:
        -: 1361:static short _decode_con[] = {
        -: 1362:	0,
        -: 1363:	25,
        -: 1364:	26,
        -: 1365:	27,
        -: 1366:	28,
        -: 1367:	29,
        -: 1368:	30,
        -: 1369:	31,
        -: 1370:	32,
        -: 1371:	33,
        -: 1372:	34,
        -: 1373:};
        -: 1374:
        -: 1375:static short _decode_acon[] = {
        -: 1376:	0,
        -: 1377:	36,
        -: 1378:	37,
        -: 1379:};
        -: 1380:
        -: 1381:static short _decode_base[] = {
        -: 1382:	0,
        -: 1383:	38,
        -: 1384:	39,
        -: 1385:	40,
        -: 1386:	41,
        -: 1387:	42,
        -: 1388:	43,
        -: 1389:	44,
        -: 1390:};
        -: 1391:
        -: 1392:static short _decode_index[] = {
        -: 1393:	0,
        -: 1394:	45,
        -: 1395:	46,
        -: 1396:	47,
        -: 1397:	48,
        -: 1398:	55,
        -: 1399:	56,
        -: 1400:	57,
        -: 1401:};
        -: 1402:
        -: 1403:static short _decode_con1[] = {
        -: 1404:	0,
        -: 1405:	49,
        -: 1406:	50,
        -: 1407:};
        -: 1408:
        -: 1409:static short _decode_con2[] = {
        -: 1410:	0,
        -: 1411:	51,
        -: 1412:	52,
        -: 1413:};
        -: 1414:
        -: 1415:static short _decode_con3[] = {
        -: 1416:	0,
        -: 1417:	53,
        -: 1418:	54,
        -: 1419:};
        -: 1420:
        -: 1421:static short _decode_addr[] = {
        -: 1422:	0,
        -: 1423:	58,
        -: 1424:	59,
        -: 1425:	60,
        -: 1426:	61,
        -: 1427:	62,
        -: 1428:};
        -: 1429:
        -: 1430:static short _decode_mem[] = {
        -: 1431:	0,
        -: 1432:	63,
        -: 1433:	64,
        -: 1434:	65,
        -: 1435:	66,
        -: 1436:	67,
        -: 1437:	68,
        -: 1438:	69,
        -: 1439:};
        -: 1440:
        -: 1441:static short _decode_rc[] = {
        -: 1442:	0,
        -: 1443:	70,
        -: 1444:	71,
        -: 1445:};
        -: 1446:
        -: 1447:static short _decode_mr[] = {
        -: 1448:	0,
        -: 1449:	72,
        -: 1450:	73,
        -: 1451:};
        -: 1452:
        -: 1453:static short _decode_mrc0[] = {
        -: 1454:	0,
        -: 1455:	74,
        -: 1456:	75,
        -: 1457:};
        -: 1458:
        -: 1459:static short _decode_mrc1[] = {
        -: 1460:	0,
        -: 1461:	76,
        -: 1462:	77,
        -: 1463:};
        -: 1464:
        -: 1465:static short _decode_mrc3[] = {
        -: 1466:	0,
        -: 1467:	78,
        -: 1468:	79,
        -: 1469:};
        -: 1470:
        -: 1471:static short _decode_con5[] = {
        -: 1472:	0,
        -: 1473:	131,
        -: 1474:};
        -: 1475:
        -: 1476:static short _decode_memf[] = {
        -: 1477:	0,
        -: 1478:	169,
        -: 1479:	170,
        -: 1480:	171,
        -: 1481:};
        -: 1482:
        -: 1483:static short _decode_flt[] = {
        -: 1484:	0,
        -: 1485:	180,
        -: 1486:	181,
        -: 1487:};
        -: 1488:
        -: 1489:static short _decode_addrj[] = {
        -: 1490:	0,
        -: 1491:	196,
        -: 1492:	197,
        -: 1493:	198,
        -: 1494:};
        -: 1495:
        -: 1496:static short _decode_cmpf[] = {
        -: 1497:	0,
        -: 1498:	223,
        -: 1499:	224,
        -: 1500:};
        -: 1501:
function _rule called 0 returned 0% blocks executed 0%
    #####: 1502:static int _rule(void *state, int goalnt) {
    #####: 1503:	if (goalnt < 1 || goalnt > 21)
    #####: 1504:		fatal("_rule", "Bad goal nonterminal %d\n", goalnt);
    #####: 1505:	if (!state)
    #####: 1506:		return 0;
    #####: 1507:	switch (goalnt) {
    #####: 1508:	case _stmt_NT:	return _decode_stmt[((struct _state *)state)->rule._stmt];
    #####: 1509:	case _reg_NT:	return _decode_reg[((struct _state *)state)->rule._reg];
    #####: 1510:	case _con_NT:	return _decode_con[((struct _state *)state)->rule._con];
    #####: 1511:	case _acon_NT:	return _decode_acon[((struct _state *)state)->rule._acon];
    #####: 1512:	case _base_NT:	return _decode_base[((struct _state *)state)->rule._base];
    #####: 1513:	case _index_NT:	return _decode_index[((struct _state *)state)->rule._index];
    #####: 1514:	case _con1_NT:	return _decode_con1[((struct _state *)state)->rule._con1];
    #####: 1515:	case _con2_NT:	return _decode_con2[((struct _state *)state)->rule._con2];
    #####: 1516:	case _con3_NT:	return _decode_con3[((struct _state *)state)->rule._con3];
    #####: 1517:	case _addr_NT:	return _decode_addr[((struct _state *)state)->rule._addr];
    #####: 1518:	case _mem_NT:	return _decode_mem[((struct _state *)state)->rule._mem];
    #####: 1519:	case _rc_NT:	return _decode_rc[((struct _state *)state)->rule._rc];
    #####: 1520:	case _mr_NT:	return _decode_mr[((struct _state *)state)->rule._mr];
    #####: 1521:	case _mrc0_NT:	return _decode_mrc0[((struct _state *)state)->rule._mrc0];
    #####: 1522:	case _mrc1_NT:	return _decode_mrc1[((struct _state *)state)->rule._mrc1];
    #####: 1523:	case _mrc3_NT:	return _decode_mrc3[((struct _state *)state)->rule._mrc3];
    #####: 1524:	case _con5_NT:	return _decode_con5[((struct _state *)state)->rule._con5];
    #####: 1525:	case _memf_NT:	return _decode_memf[((struct _state *)state)->rule._memf];
    #####: 1526:	case _flt_NT:	return _decode_flt[((struct _state *)state)->rule._flt];
    #####: 1527:	case _addrj_NT:	return _decode_addrj[((struct _state *)state)->rule._addrj];
    #####: 1528:	case _cmpf_NT:	return _decode_cmpf[((struct _state *)state)->rule._cmpf];
        -: 1529:	default:
    #####: 1530:		fatal("_rule", "Bad goal nonterminal %d\n", goalnt);
    #####: 1531:		return 0;
        -: 1532:	}
        -: 1533:}
        -: 1534:
        -: 1535:static void _closure_reg(NODEPTR_TYPE, int);
        -: 1536:static void _closure_con(NODEPTR_TYPE, int);
        -: 1537:static void _closure_base(NODEPTR_TYPE, int);
        -: 1538:static void _closure_index(NODEPTR_TYPE, int);
        -: 1539:static void _closure_addr(NODEPTR_TYPE, int);
        -: 1540:static void _closure_mem(NODEPTR_TYPE, int);
        -: 1541:static void _closure_rc(NODEPTR_TYPE, int);
        -: 1542:static void _closure_mrc0(NODEPTR_TYPE, int);
        -: 1543:static void _closure_memf(NODEPTR_TYPE, int);
        -: 1544:
function _closure_reg called 0 returned 0% blocks executed 0%
    #####: 1545:static void _closure_reg(NODEPTR_TYPE a, int c) {
    #####: 1546:	struct _state *p = STATE_LABEL(a);
    #####: 1547:	if (c + 0 < p->cost[_cmpf_NT]) {
    #####: 1548:		p->cost[_cmpf_NT] = c + 0;
    #####: 1549:		p->rule._cmpf = 2;
        -: 1550:	}
    #####: 1551:	if (c + 2 < p->cost[_addrj_NT]) {
    #####: 1552:		p->cost[_addrj_NT] = c + 2;
    #####: 1553:		p->rule._addrj = 2;
        -: 1554:	}
    #####: 1555:	if (c + 0 < p->cost[_flt_NT]) {
    #####: 1556:		p->cost[_flt_NT] = c + 0;
    #####: 1557:		p->rule._flt = 2;
        -: 1558:	}
    #####: 1559:	if (c + 0 < p->cost[_mr_NT]) {
    #####: 1560:		p->cost[_mr_NT] = c + 0;
    #####: 1561:		p->rule._mr = 1;
        -: 1562:	}
    #####: 1563:	if (c + 0 < p->cost[_rc_NT]) {
    #####: 1564:		p->cost[_rc_NT] = c + 0;
    #####: 1565:		p->rule._rc = 1;
    #####: 1566:		_closure_rc(a, c + 0);
        -: 1567:	}
    #####: 1568:	if (c + 0 < p->cost[_index_NT]) {
    #####: 1569:		p->cost[_index_NT] = c + 0;
    #####: 1570:		p->rule._index = 1;
    #####: 1571:		_closure_index(a, c + 0);
        -: 1572:	}
    #####: 1573:	if (c + 0 < p->cost[_base_NT]) {
    #####: 1574:		p->cost[_base_NT] = c + 0;
    #####: 1575:		p->rule._base = 2;
    #####: 1576:		_closure_base(a, c + 0);
        -: 1577:	}
    #####: 1578:	if (c + 0 < p->cost[_stmt_NT]) {
    #####: 1579:		p->cost[_stmt_NT] = c + 0;
    #####: 1580:		p->rule._stmt = 13;
        -: 1581:	}
        -: 1582:}
        -: 1583:
function _closure_con called 0 returned 0% blocks executed 0%
    #####: 1584:static void _closure_con(NODEPTR_TYPE a, int c) {
    #####: 1585:	struct _state *p = STATE_LABEL(a);
    #####: 1586:	if (c + 0 < p->cost[_rc_NT]) {
    #####: 1587:		p->cost[_rc_NT] = c + 0;
    #####: 1588:		p->rule._rc = 2;
    #####: 1589:		_closure_rc(a, c + 0);
        -: 1590:	}
    #####: 1591:	if (c + 0 < p->cost[_acon_NT]) {
    #####: 1592:		p->cost[_acon_NT] = c + 0;
    #####: 1593:		p->rule._acon = 2;
        -: 1594:	}
        -: 1595:}
        -: 1596:
function _closure_base called 0 returned 0% blocks executed 0%
    #####: 1597:static void _closure_base(NODEPTR_TYPE a, int c) {
    #####: 1598:	struct _state *p = STATE_LABEL(a);
    #####: 1599:	if (c + 0 < p->cost[_addr_NT]) {
    #####: 1600:		p->cost[_addr_NT] = c + 0;
    #####: 1601:		p->rule._addr = 1;
    #####: 1602:		_closure_addr(a, c + 0);
        -: 1603:	}
        -: 1604:}
        -: 1605:
function _closure_index called 0 returned 0% blocks executed 0%
    #####: 1606:static void _closure_index(NODEPTR_TYPE a, int c) {
    #####: 1607:	struct _state *p = STATE_LABEL(a);
    #####: 1608:	if (c + 0 < p->cost[_addr_NT]) {
    #####: 1609:		p->cost[_addr_NT] = c + 0;
    #####: 1610:		p->rule._addr = 5;
    #####: 1611:		_closure_addr(a, c + 0);
        -: 1612:	}
        -: 1613:}
        -: 1614:
function _closure_addr called 0 returned 0% blocks executed 0%
    #####: 1615:static void _closure_addr(NODEPTR_TYPE a, int c) {
    #####: 1616:	struct _state *p = STATE_LABEL(a);
    #####: 1617:	if (c + 1 < p->cost[_reg_NT]) {
    #####: 1618:		p->cost[_reg_NT] = c + 1;
    #####: 1619:		p->rule._reg = 13;
    #####: 1620:		_closure_reg(a, c + 1);
        -: 1621:	}
        -: 1622:}
        -: 1623:
function _closure_mem called 0 returned 0% blocks executed 0%
    #####: 1624:static void _closure_mem(NODEPTR_TYPE a, int c) {
    #####: 1625:	struct _state *p = STATE_LABEL(a);
    #####: 1626:	if (c + 2 < p->cost[_addrj_NT]) {
    #####: 1627:		p->cost[_addrj_NT] = c + 2;
    #####: 1628:		p->rule._addrj = 3;
        -: 1629:	}
    #####: 1630:	if (c + 3 < p->cost[_mrc3_NT]) {
    #####: 1631:		p->cost[_mrc3_NT] = c + 3;
    #####: 1632:		p->rule._mrc3 = 1;
        -: 1633:	}
    #####: 1634:	if (c + 1 < p->cost[_mrc1_NT]) {
    #####: 1635:		p->cost[_mrc1_NT] = c + 1;
    #####: 1636:		p->rule._mrc1 = 1;
        -: 1637:	}
    #####: 1638:	if (c + 0 < p->cost[_mrc0_NT]) {
    #####: 1639:		p->cost[_mrc0_NT] = c + 0;
    #####: 1640:		p->rule._mrc0 = 1;
    #####: 1641:		_closure_mrc0(a, c + 0);
        -: 1642:	}
    #####: 1643:	if (c + 0 < p->cost[_mr_NT]) {
    #####: 1644:		p->cost[_mr_NT] = c + 0;
    #####: 1645:		p->rule._mr = 2;
        -: 1646:	}
        -: 1647:}
        -: 1648:
function _closure_rc called 0 returned 0% blocks executed 0%
    #####: 1649:static void _closure_rc(NODEPTR_TYPE a, int c) {
    #####: 1650:	struct _state *p = STATE_LABEL(a);
    #####: 1651:	if (c + 0 < p->cost[_mrc3_NT]) {
    #####: 1652:		p->cost[_mrc3_NT] = c + 0;
    #####: 1653:		p->rule._mrc3 = 2;
        -: 1654:	}
    #####: 1655:	if (c + 0 < p->cost[_mrc1_NT]) {
    #####: 1656:		p->cost[_mrc1_NT] = c + 0;
    #####: 1657:		p->rule._mrc1 = 2;
        -: 1658:	}
    #####: 1659:	if (c + 0 < p->cost[_mrc0_NT]) {
    #####: 1660:		p->cost[_mrc0_NT] = c + 0;
    #####: 1661:		p->rule._mrc0 = 2;
    #####: 1662:		_closure_mrc0(a, c + 0);
        -: 1663:	}
        -: 1664:}
        -: 1665:
function _closure_mrc0 called 0 returned 0% blocks executed 0%
    #####: 1666:static void _closure_mrc0(NODEPTR_TYPE a, int c) {
    #####: 1667:	struct _state *p = STATE_LABEL(a);
    #####: 1668:	if (c + 1 < p->cost[_reg_NT]) {
    #####: 1669:		p->cost[_reg_NT] = c + 1;
    #####: 1670:		p->rule._reg = 14;
    #####: 1671:		_closure_reg(a, c + 1);
        -: 1672:	}
        -: 1673:}
        -: 1674:
function _closure_memf called 0 returned 0% blocks executed 0%
    #####: 1675:static void _closure_memf(NODEPTR_TYPE a, int c) {
    #####: 1676:	struct _state *p = STATE_LABEL(a);
    #####: 1677:	if (c + 0 < p->cost[_cmpf_NT]) {
    #####: 1678:		p->cost[_cmpf_NT] = c + 0;
    #####: 1679:		p->rule._cmpf = 1;
        -: 1680:	}
    #####: 1681:	if (c + 0 < p->cost[_flt_NT]) {
    #####: 1682:		p->cost[_flt_NT] = c + 0;
    #####: 1683:		p->rule._flt = 1;
        -: 1684:	}
    #####: 1685:	if (c + 3 < p->cost[_reg_NT]) {
    #####: 1686:		p->cost[_reg_NT] = c + 3;
    #####: 1687:		p->rule._reg = 66;
    #####: 1688:		_closure_reg(a, c + 3);
        -: 1689:	}
        -: 1690:}
        -: 1691:
function _label called 0 returned 0% blocks executed 0%
    #####: 1692:static void _label(NODEPTR_TYPE a) {
    #####: 1693:	int c;
    #####: 1694:	struct _state *p;
        -: 1695:
    #####: 1696:	if (!a)
    #####: 1697:		fatal("_label", "Null tree\n", 0);
    #####: 1698:	STATE_LABEL(a) = p = allocate(sizeof *p, FUNC);
    #####: 1699:	p->rule._stmt = 0;
    #####: 1700:	p->cost[1] =
        -: 1701:	p->cost[2] =
        -: 1702:	p->cost[3] =
        -: 1703:	p->cost[4] =
        -: 1704:	p->cost[5] =
        -: 1705:	p->cost[6] =
        -: 1706:	p->cost[7] =
        -: 1707:	p->cost[8] =
        -: 1708:	p->cost[9] =
        -: 1709:	p->cost[10] =
        -: 1710:	p->cost[11] =
        -: 1711:	p->cost[12] =
        -: 1712:	p->cost[13] =
        -: 1713:	p->cost[14] =
        -: 1714:	p->cost[15] =
        -: 1715:	p->cost[16] =
        -: 1716:	p->cost[17] =
        -: 1717:	p->cost[18] =
        -: 1718:	p->cost[19] =
        -: 1719:	p->cost[20] =
        -: 1720:	p->cost[21] =
        -: 1721:		0x7fff;
    #####: 1722:	switch (OP_LABEL(a)) {
        -: 1723:	case 41: /* ARGB */
    #####: 1724:		_label(LEFT_CHILD(a));
    #####: 1725:		if (	/* stmt: ARGB(INDIRB(reg)) */
        -: 1726:			LEFT_CHILD(a)->op == 73 /* INDIRB */
        -: 1727:		) {
    #####: 1728:			c = ((struct _state *)(LEFT_CHILD(LEFT_CHILD(a))->x.state))->cost[_reg_NT] + 0;
    #####: 1729:			if (c + 0 < p->cost[_stmt_NT]) {
    #####: 1730:				p->cost[_stmt_NT] = c + 0;
    #####: 1731:				p->rule._stmt = 48;
        -: 1732:			}
        -: 1733:		}
    #####: 1734:		break;
        -: 1735:	case 57: /* ASGNB */
    #####: 1736:		_label(LEFT_CHILD(a));
    #####: 1737:		_label(RIGHT_CHILD(a));
    #####: 1738:		if (	/* stmt: ASGNB(reg,INDIRB(reg)) */
        -: 1739:			RIGHT_CHILD(a)->op == 73 /* INDIRB */
        -: 1740:		) {
    #####: 1741:			c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(LEFT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_reg_NT] + 0;
    #####: 1742:			if (c + 0 < p->cost[_stmt_NT]) {
    #####: 1743:				p->cost[_stmt_NT] = c + 0;
    #####: 1744:				p->rule._stmt = 47;
        -: 1745:			}
        -: 1746:		}
    #####: 1747:		break;
        -: 1748:	case 73: /* INDIRB */
    #####: 1749:		_label(LEFT_CHILD(a));
    #####: 1750:		break;
        -: 1751:	case 216: /* CALLV */
    #####: 1752:		_label(LEFT_CHILD(a));
        -: 1753:		/* stmt: CALLV(addrj) */
    #####: 1754:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addrj_NT] + 0;
    #####: 1755:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 1756:			p->cost[_stmt_NT] = c + 0;
    #####: 1757:			p->rule._stmt = 90;
        -: 1758:		}
    #####: 1759:		break;
        -: 1760:	case 217: /* CALLB */
    #####: 1761:		break;
        -: 1762:	case 233: /* LOADB */
    #####: 1763:		break;
        -: 1764:	case 248: /* RETV */
    #####: 1765:		break;
        -: 1766:	case 584: /* JUMPV */
    #####: 1767:		_label(LEFT_CHILD(a));
        -: 1768:		/* stmt: JUMPV(addrj) */
    #####: 1769:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addrj_NT] + 3;
    #####: 1770:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 1771:			p->cost[_stmt_NT] = c + 0;
    #####: 1772:			p->rule._stmt = 54;
        -: 1773:		}
    #####: 1774:		break;
        -: 1775:	case 600: /* LABELV */
        -: 1776:		/* stmt: LABELV */
    #####: 1777:		if (0 + 0 < p->cost[_stmt_NT]) {
    #####: 1778:			p->cost[_stmt_NT] = 0 + 0;
    #####: 1779:			p->rule._stmt = 55;
        -: 1780:		}
    #####: 1781:		break;
        -: 1782:	case 711: /* VREGP */
    #####: 1783:		break;
        -: 1784:	case 1045: /* CNSTI1 */
        -: 1785:		/* con: CNSTI1 */
    #####: 1786:		if (0 + 0 < p->cost[_con_NT]) {
    #####: 1787:			p->cost[_con_NT] = 0 + 0;
    #####: 1788:			p->rule._con = 1;
    #####: 1789:			_closure_con(a, 0 + 0);
        -: 1790:		}
    #####: 1791:		break;
        -: 1792:	case 1046: /* CNSTU1 */
        -: 1793:		/* con: CNSTU1 */
    #####: 1794:		if (0 + 0 < p->cost[_con_NT]) {
    #####: 1795:			p->cost[_con_NT] = 0 + 0;
    #####: 1796:			p->rule._con = 2;
    #####: 1797:			_closure_con(a, 0 + 0);
        -: 1798:		}
    #####: 1799:		break;
        -: 1800:	case 1077: /* ASGNI1 */
    #####: 1801:		_label(LEFT_CHILD(a));
    #####: 1802:		_label(RIGHT_CHILD(a));
    #####: 1803:		if (	/* stmt: ASGNI1(VREGP,reg) */
        -: 1804:			LEFT_CHILD(a)->op == 711 /* VREGP */
        -: 1805:		) {
    #####: 1806:			c = ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
    #####: 1807:			if (c + 0 < p->cost[_stmt_NT]) {
    #####: 1808:				p->cost[_stmt_NT] = c + 0;
    #####: 1809:				p->rule._stmt = 1;
        -: 1810:			}
        -: 1811:		}
        -: 1812:		/* stmt: ASGNI1(addr,rc) */
    #####: 1813:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_rc_NT] + 1;
    #####: 1814:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 1815:			p->cost[_stmt_NT] = c + 0;
    #####: 1816:			p->rule._stmt = 37;
        -: 1817:		}
    #####: 1818:		break;
        -: 1819:	case 1078: /* ASGNU1 */
    #####: 1820:		_label(LEFT_CHILD(a));
    #####: 1821:		_label(RIGHT_CHILD(a));
    #####: 1822:		if (	/* stmt: ASGNU1(VREGP,reg) */
        -: 1823:			LEFT_CHILD(a)->op == 711 /* VREGP */
        -: 1824:		) {
    #####: 1825:			c = ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
    #####: 1826:			if (c + 0 < p->cost[_stmt_NT]) {
    #####: 1827:				p->cost[_stmt_NT] = c + 0;
    #####: 1828:				p->rule._stmt = 2;
        -: 1829:			}
        -: 1830:		}
        -: 1831:		/* stmt: ASGNU1(addr,rc) */
    #####: 1832:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_rc_NT] + 1;
    #####: 1833:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 1834:			p->cost[_stmt_NT] = c + 0;
    #####: 1835:			p->rule._stmt = 40;
        -: 1836:		}
    #####: 1837:		break;
        -: 1838:	case 1093: /* INDIRI1 */
    #####: 1839:		_label(LEFT_CHILD(a));
    #####: 1840:		if (	/* reg: INDIRI1(VREGP) */
        -: 1841:			LEFT_CHILD(a)->op == 711 /* VREGP */
        -: 1842:		) {
    #####: 1843:			if (mayrecalc(a)) {
    #####: 1844:				struct _state *q = a->syms[RX]->u.t.cse->x.state;
    #####: 1845:				if (q->cost[_stmt_NT] == 0) {
    #####: 1846:					p->cost[_stmt_NT] = 0;
    #####: 1847:					p->rule._stmt = q->rule._stmt;
        -: 1848:				}
    #####: 1849:				if (q->cost[_reg_NT] == 0) {
    #####: 1850:					p->cost[_reg_NT] = 0;
    #####: 1851:					p->rule._reg = q->rule._reg;
        -: 1852:				}
    #####: 1853:				if (q->cost[_con_NT] == 0) {
    #####: 1854:					p->cost[_con_NT] = 0;
    #####: 1855:					p->rule._con = q->rule._con;
        -: 1856:				}
    #####: 1857:				if (q->cost[_acon_NT] == 0) {
    #####: 1858:					p->cost[_acon_NT] = 0;
    #####: 1859:					p->rule._acon = q->rule._acon;
        -: 1860:				}
    #####: 1861:				if (q->cost[_base_NT] == 0) {
    #####: 1862:					p->cost[_base_NT] = 0;
    #####: 1863:					p->rule._base = q->rule._base;
        -: 1864:				}
    #####: 1865:				if (q->cost[_index_NT] == 0) {
    #####: 1866:					p->cost[_index_NT] = 0;
    #####: 1867:					p->rule._index = q->rule._index;
        -: 1868:				}
    #####: 1869:				if (q->cost[_con1_NT] == 0) {
    #####: 1870:					p->cost[_con1_NT] = 0;
    #####: 1871:					p->rule._con1 = q->rule._con1;
        -: 1872:				}
    #####: 1873:				if (q->cost[_con2_NT] == 0) {
    #####: 1874:					p->cost[_con2_NT] = 0;
    #####: 1875:					p->rule._con2 = q->rule._con2;
        -: 1876:				}
    #####: 1877:				if (q->cost[_con3_NT] == 0) {
    #####: 1878:					p->cost[_con3_NT] = 0;
    #####: 1879:					p->rule._con3 = q->rule._con3;
        -: 1880:				}
    #####: 1881:				if (q->cost[_addr_NT] == 0) {
    #####: 1882:					p->cost[_addr_NT] = 0;
    #####: 1883:					p->rule._addr = q->rule._addr;
        -: 1884:				}
    #####: 1885:				if (q->cost[_mem_NT] == 0) {
    #####: 1886:					p->cost[_mem_NT] = 0;
    #####: 1887:					p->rule._mem = q->rule._mem;
        -: 1888:				}
    #####: 1889:				if (q->cost[_rc_NT] == 0) {
    #####: 1890:					p->cost[_rc_NT] = 0;
    #####: 1891:					p->rule._rc = q->rule._rc;
        -: 1892:				}
    #####: 1893:				if (q->cost[_mr_NT] == 0) {
    #####: 1894:					p->cost[_mr_NT] = 0;
    #####: 1895:					p->rule._mr = q->rule._mr;
        -: 1896:				}
    #####: 1897:				if (q->cost[_mrc0_NT] == 0) {
    #####: 1898:					p->cost[_mrc0_NT] = 0;
    #####: 1899:					p->rule._mrc0 = q->rule._mrc0;
        -: 1900:				}
    #####: 1901:				if (q->cost[_mrc1_NT] == 0) {
    #####: 1902:					p->cost[_mrc1_NT] = 0;
    #####: 1903:					p->rule._mrc1 = q->rule._mrc1;
        -: 1904:				}
    #####: 1905:				if (q->cost[_mrc3_NT] == 0) {
    #####: 1906:					p->cost[_mrc3_NT] = 0;
    #####: 1907:					p->rule._mrc3 = q->rule._mrc3;
        -: 1908:				}
    #####: 1909:				if (q->cost[_con5_NT] == 0) {
    #####: 1910:					p->cost[_con5_NT] = 0;
    #####: 1911:					p->rule._con5 = q->rule._con5;
        -: 1912:				}
    #####: 1913:				if (q->cost[_memf_NT] == 0) {
    #####: 1914:					p->cost[_memf_NT] = 0;
    #####: 1915:					p->rule._memf = q->rule._memf;
        -: 1916:				}
    #####: 1917:				if (q->cost[_flt_NT] == 0) {
    #####: 1918:					p->cost[_flt_NT] = 0;
    #####: 1919:					p->rule._flt = q->rule._flt;
        -: 1920:				}
    #####: 1921:				if (q->cost[_addrj_NT] == 0) {
    #####: 1922:					p->cost[_addrj_NT] = 0;
    #####: 1923:					p->rule._addrj = q->rule._addrj;
        -: 1924:				}
    #####: 1925:				if (q->cost[_cmpf_NT] == 0) {
    #####: 1926:					p->cost[_cmpf_NT] = 0;
    #####: 1927:					p->rule._cmpf = q->rule._cmpf;
        -: 1928:				}
        -: 1929:			}
    #####: 1930:			c = 0;
    #####: 1931:			if (c + 0 < p->cost[_reg_NT]) {
    #####: 1932:				p->cost[_reg_NT] = c + 0;
    #####: 1933:				p->rule._reg = 1;
    #####: 1934:				_closure_reg(a, c + 0);
        -: 1935:			}
        -: 1936:		}
        -: 1937:		/* mem: INDIRI1(addr) */
    #####: 1938:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + 0;
    #####: 1939:		if (c + 0 < p->cost[_mem_NT]) {
    #####: 1940:			p->cost[_mem_NT] = c + 0;
    #####: 1941:			p->rule._mem = 1;
    #####: 1942:			_closure_mem(a, c + 0);
        -: 1943:		}
    #####: 1944:		break;
        -: 1945:	case 1094: /* INDIRU1 */
    #####: 1946:		_label(LEFT_CHILD(a));
    #####: 1947:		if (	/* reg: INDIRU1(VREGP) */
        -: 1948:			LEFT_CHILD(a)->op == 711 /* VREGP */
        -: 1949:		) {
    #####: 1950:			if (mayrecalc(a)) {
    #####: 1951:				struct _state *q = a->syms[RX]->u.t.cse->x.state;
    #####: 1952:				if (q->cost[_stmt_NT] == 0) {
    #####: 1953:					p->cost[_stmt_NT] = 0;
    #####: 1954:					p->rule._stmt = q->rule._stmt;
        -: 1955:				}
    #####: 1956:				if (q->cost[_reg_NT] == 0) {
    #####: 1957:					p->cost[_reg_NT] = 0;
    #####: 1958:					p->rule._reg = q->rule._reg;
        -: 1959:				}
    #####: 1960:				if (q->cost[_con_NT] == 0) {
    #####: 1961:					p->cost[_con_NT] = 0;
    #####: 1962:					p->rule._con = q->rule._con;
        -: 1963:				}
    #####: 1964:				if (q->cost[_acon_NT] == 0) {
    #####: 1965:					p->cost[_acon_NT] = 0;
    #####: 1966:					p->rule._acon = q->rule._acon;
        -: 1967:				}
    #####: 1968:				if (q->cost[_base_NT] == 0) {
    #####: 1969:					p->cost[_base_NT] = 0;
    #####: 1970:					p->rule._base = q->rule._base;
        -: 1971:				}
    #####: 1972:				if (q->cost[_index_NT] == 0) {
    #####: 1973:					p->cost[_index_NT] = 0;
    #####: 1974:					p->rule._index = q->rule._index;
        -: 1975:				}
    #####: 1976:				if (q->cost[_con1_NT] == 0) {
    #####: 1977:					p->cost[_con1_NT] = 0;
    #####: 1978:					p->rule._con1 = q->rule._con1;
        -: 1979:				}
    #####: 1980:				if (q->cost[_con2_NT] == 0) {
    #####: 1981:					p->cost[_con2_NT] = 0;
    #####: 1982:					p->rule._con2 = q->rule._con2;
        -: 1983:				}
    #####: 1984:				if (q->cost[_con3_NT] == 0) {
    #####: 1985:					p->cost[_con3_NT] = 0;
    #####: 1986:					p->rule._con3 = q->rule._con3;
        -: 1987:				}
    #####: 1988:				if (q->cost[_addr_NT] == 0) {
    #####: 1989:					p->cost[_addr_NT] = 0;
    #####: 1990:					p->rule._addr = q->rule._addr;
        -: 1991:				}
    #####: 1992:				if (q->cost[_mem_NT] == 0) {
    #####: 1993:					p->cost[_mem_NT] = 0;
    #####: 1994:					p->rule._mem = q->rule._mem;
        -: 1995:				}
    #####: 1996:				if (q->cost[_rc_NT] == 0) {
    #####: 1997:					p->cost[_rc_NT] = 0;
    #####: 1998:					p->rule._rc = q->rule._rc;
        -: 1999:				}
    #####: 2000:				if (q->cost[_mr_NT] == 0) {
    #####: 2001:					p->cost[_mr_NT] = 0;
    #####: 2002:					p->rule._mr = q->rule._mr;
        -: 2003:				}
    #####: 2004:				if (q->cost[_mrc0_NT] == 0) {
    #####: 2005:					p->cost[_mrc0_NT] = 0;
    #####: 2006:					p->rule._mrc0 = q->rule._mrc0;
        -: 2007:				}
    #####: 2008:				if (q->cost[_mrc1_NT] == 0) {
    #####: 2009:					p->cost[_mrc1_NT] = 0;
    #####: 2010:					p->rule._mrc1 = q->rule._mrc1;
        -: 2011:				}
    #####: 2012:				if (q->cost[_mrc3_NT] == 0) {
    #####: 2013:					p->cost[_mrc3_NT] = 0;
    #####: 2014:					p->rule._mrc3 = q->rule._mrc3;
        -: 2015:				}
    #####: 2016:				if (q->cost[_con5_NT] == 0) {
    #####: 2017:					p->cost[_con5_NT] = 0;
    #####: 2018:					p->rule._con5 = q->rule._con5;
        -: 2019:				}
    #####: 2020:				if (q->cost[_memf_NT] == 0) {
    #####: 2021:					p->cost[_memf_NT] = 0;
    #####: 2022:					p->rule._memf = q->rule._memf;
        -: 2023:				}
    #####: 2024:				if (q->cost[_flt_NT] == 0) {
    #####: 2025:					p->cost[_flt_NT] = 0;
    #####: 2026:					p->rule._flt = q->rule._flt;
        -: 2027:				}
    #####: 2028:				if (q->cost[_addrj_NT] == 0) {
    #####: 2029:					p->cost[_addrj_NT] = 0;
    #####: 2030:					p->rule._addrj = q->rule._addrj;
        -: 2031:				}
    #####: 2032:				if (q->cost[_cmpf_NT] == 0) {
    #####: 2033:					p->cost[_cmpf_NT] = 0;
    #####: 2034:					p->rule._cmpf = q->rule._cmpf;
        -: 2035:				}
        -: 2036:			}
    #####: 2037:			c = 0;
    #####: 2038:			if (c + 0 < p->cost[_reg_NT]) {
    #####: 2039:				p->cost[_reg_NT] = c + 0;
    #####: 2040:				p->rule._reg = 2;
    #####: 2041:				_closure_reg(a, c + 0);
        -: 2042:			}
        -: 2043:		}
        -: 2044:		/* mem: INDIRU1(addr) */
    #####: 2045:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + 0;
    #####: 2046:		if (c + 0 < p->cost[_mem_NT]) {
    #####: 2047:			p->cost[_mem_NT] = c + 0;
    #####: 2048:			p->rule._mem = 4;
    #####: 2049:			_closure_mem(a, c + 0);
        -: 2050:		}
    #####: 2051:		break;
        -: 2052:	case 1157: /* CVII1 */
    #####: 2053:		_label(LEFT_CHILD(a));
        -: 2054:		/* reg: CVII1(reg) */
    #####: 2055:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + 1;
    #####: 2056:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 2057:			p->cost[_reg_NT] = c + 0;
    #####: 2058:			p->rule._reg = 62;
    #####: 2059:			_closure_reg(a, c + 0);
        -: 2060:		}
    #####: 2061:		break;
        -: 2062:	case 1158: /* CVIU1 */
    #####: 2063:		break;
        -: 2064:	case 1205: /* CVUI1 */
    #####: 2065:		break;
        -: 2066:	case 1206: /* CVUU1 */
    #####: 2067:		_label(LEFT_CHILD(a));
        -: 2068:		/* reg: CVUU1(reg) */
    #####: 2069:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + 1;
    #####: 2070:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 2071:			p->cost[_reg_NT] = c + 0;
    #####: 2072:			p->rule._reg = 64;
    #####: 2073:			_closure_reg(a, c + 0);
        -: 2074:		}
    #####: 2075:		break;
        -: 2076:	case 1253: /* LOADI1 */
    #####: 2077:		_label(LEFT_CHILD(a));
        -: 2078:		/* reg: LOADI1(reg) */
    #####: 2079:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + 1;
    #####: 2080:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 2081:			p->cost[_reg_NT] = c + 0;
    #####: 2082:			p->rule._reg = 15;
    #####: 2083:			_closure_reg(a, c + 0);
        -: 2084:		}
    #####: 2085:		break;
        -: 2086:	case 1254: /* LOADU1 */
    #####: 2087:		_label(LEFT_CHILD(a));
        -: 2088:		/* reg: LOADU1(reg) */
    #####: 2089:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + 1;
    #####: 2090:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 2091:			p->cost[_reg_NT] = c + 0;
    #####: 2092:			p->rule._reg = 18;
    #####: 2093:			_closure_reg(a, c + 0);
        -: 2094:		}
    #####: 2095:		break;
        -: 2096:	case 2069: /* CNSTI2 */
        -: 2097:		/* con: CNSTI2 */
    #####: 2098:		if (0 + 0 < p->cost[_con_NT]) {
    #####: 2099:			p->cost[_con_NT] = 0 + 0;
    #####: 2100:			p->rule._con = 3;
    #####: 2101:			_closure_con(a, 0 + 0);
        -: 2102:		}
    #####: 2103:		break;
        -: 2104:	case 2070: /* CNSTU2 */
        -: 2105:		/* con: CNSTU2 */
    #####: 2106:		if (0 + 0 < p->cost[_con_NT]) {
    #####: 2107:			p->cost[_con_NT] = 0 + 0;
    #####: 2108:			p->rule._con = 4;
    #####: 2109:			_closure_con(a, 0 + 0);
        -: 2110:		}
    #####: 2111:		break;
        -: 2112:	case 2101: /* ASGNI2 */
    #####: 2113:		_label(LEFT_CHILD(a));
    #####: 2114:		_label(RIGHT_CHILD(a));
    #####: 2115:		if (	/* stmt: ASGNI2(VREGP,reg) */
        -: 2116:			LEFT_CHILD(a)->op == 711 /* VREGP */
        -: 2117:		) {
    #####: 2118:			c = ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
    #####: 2119:			if (c + 0 < p->cost[_stmt_NT]) {
    #####: 2120:				p->cost[_stmt_NT] = c + 0;
    #####: 2121:				p->rule._stmt = 3;
        -: 2122:			}
        -: 2123:		}
        -: 2124:		/* stmt: ASGNI2(addr,rc) */
    #####: 2125:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_rc_NT] + 1;
    #####: 2126:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 2127:			p->cost[_stmt_NT] = c + 0;
    #####: 2128:			p->rule._stmt = 38;
        -: 2129:		}
    #####: 2130:		break;
        -: 2131:	case 2102: /* ASGNU2 */
    #####: 2132:		_label(LEFT_CHILD(a));
    #####: 2133:		_label(RIGHT_CHILD(a));
    #####: 2134:		if (	/* stmt: ASGNU2(VREGP,reg) */
        -: 2135:			LEFT_CHILD(a)->op == 711 /* VREGP */
        -: 2136:		) {
    #####: 2137:			c = ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
    #####: 2138:			if (c + 0 < p->cost[_stmt_NT]) {
    #####: 2139:				p->cost[_stmt_NT] = c + 0;
    #####: 2140:				p->rule._stmt = 4;
        -: 2141:			}
        -: 2142:		}
        -: 2143:		/* stmt: ASGNU2(addr,rc) */
    #####: 2144:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_rc_NT] + 1;
    #####: 2145:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 2146:			p->cost[_stmt_NT] = c + 0;
    #####: 2147:			p->rule._stmt = 41;
        -: 2148:		}
    #####: 2149:		break;
        -: 2150:	case 2117: /* INDIRI2 */
    #####: 2151:		_label(LEFT_CHILD(a));
    #####: 2152:		if (	/* reg: INDIRI2(VREGP) */
        -: 2153:			LEFT_CHILD(a)->op == 711 /* VREGP */
        -: 2154:		) {
    #####: 2155:			if (mayrecalc(a)) {
    #####: 2156:				struct _state *q = a->syms[RX]->u.t.cse->x.state;
    #####: 2157:				if (q->cost[_stmt_NT] == 0) {
    #####: 2158:					p->cost[_stmt_NT] = 0;
    #####: 2159:					p->rule._stmt = q->rule._stmt;
        -: 2160:				}
    #####: 2161:				if (q->cost[_reg_NT] == 0) {
    #####: 2162:					p->cost[_reg_NT] = 0;
    #####: 2163:					p->rule._reg = q->rule._reg;
        -: 2164:				}
    #####: 2165:				if (q->cost[_con_NT] == 0) {
    #####: 2166:					p->cost[_con_NT] = 0;
    #####: 2167:					p->rule._con = q->rule._con;
        -: 2168:				}
    #####: 2169:				if (q->cost[_acon_NT] == 0) {
    #####: 2170:					p->cost[_acon_NT] = 0;
    #####: 2171:					p->rule._acon = q->rule._acon;
        -: 2172:				}
    #####: 2173:				if (q->cost[_base_NT] == 0) {
    #####: 2174:					p->cost[_base_NT] = 0;
    #####: 2175:					p->rule._base = q->rule._base;
        -: 2176:				}
    #####: 2177:				if (q->cost[_index_NT] == 0) {
    #####: 2178:					p->cost[_index_NT] = 0;
    #####: 2179:					p->rule._index = q->rule._index;
        -: 2180:				}
    #####: 2181:				if (q->cost[_con1_NT] == 0) {
    #####: 2182:					p->cost[_con1_NT] = 0;
    #####: 2183:					p->rule._con1 = q->rule._con1;
        -: 2184:				}
    #####: 2185:				if (q->cost[_con2_NT] == 0) {
    #####: 2186:					p->cost[_con2_NT] = 0;
    #####: 2187:					p->rule._con2 = q->rule._con2;
        -: 2188:				}
    #####: 2189:				if (q->cost[_con3_NT] == 0) {
    #####: 2190:					p->cost[_con3_NT] = 0;
    #####: 2191:					p->rule._con3 = q->rule._con3;
        -: 2192:				}
    #####: 2193:				if (q->cost[_addr_NT] == 0) {
    #####: 2194:					p->cost[_addr_NT] = 0;
    #####: 2195:					p->rule._addr = q->rule._addr;
        -: 2196:				}
    #####: 2197:				if (q->cost[_mem_NT] == 0) {
    #####: 2198:					p->cost[_mem_NT] = 0;
    #####: 2199:					p->rule._mem = q->rule._mem;
        -: 2200:				}
    #####: 2201:				if (q->cost[_rc_NT] == 0) {
    #####: 2202:					p->cost[_rc_NT] = 0;
    #####: 2203:					p->rule._rc = q->rule._rc;
        -: 2204:				}
    #####: 2205:				if (q->cost[_mr_NT] == 0) {
    #####: 2206:					p->cost[_mr_NT] = 0;
    #####: 2207:					p->rule._mr = q->rule._mr;
        -: 2208:				}
    #####: 2209:				if (q->cost[_mrc0_NT] == 0) {
    #####: 2210:					p->cost[_mrc0_NT] = 0;
    #####: 2211:					p->rule._mrc0 = q->rule._mrc0;
        -: 2212:				}
    #####: 2213:				if (q->cost[_mrc1_NT] == 0) {
    #####: 2214:					p->cost[_mrc1_NT] = 0;
    #####: 2215:					p->rule._mrc1 = q->rule._mrc1;
        -: 2216:				}
    #####: 2217:				if (q->cost[_mrc3_NT] == 0) {
    #####: 2218:					p->cost[_mrc3_NT] = 0;
    #####: 2219:					p->rule._mrc3 = q->rule._mrc3;
        -: 2220:				}
    #####: 2221:				if (q->cost[_con5_NT] == 0) {
    #####: 2222:					p->cost[_con5_NT] = 0;
    #####: 2223:					p->rule._con5 = q->rule._con5;
        -: 2224:				}
    #####: 2225:				if (q->cost[_memf_NT] == 0) {
    #####: 2226:					p->cost[_memf_NT] = 0;
    #####: 2227:					p->rule._memf = q->rule._memf;
        -: 2228:				}
    #####: 2229:				if (q->cost[_flt_NT] == 0) {
    #####: 2230:					p->cost[_flt_NT] = 0;
    #####: 2231:					p->rule._flt = q->rule._flt;
        -: 2232:				}
    #####: 2233:				if (q->cost[_addrj_NT] == 0) {
    #####: 2234:					p->cost[_addrj_NT] = 0;
    #####: 2235:					p->rule._addrj = q->rule._addrj;
        -: 2236:				}
    #####: 2237:				if (q->cost[_cmpf_NT] == 0) {
    #####: 2238:					p->cost[_cmpf_NT] = 0;
    #####: 2239:					p->rule._cmpf = q->rule._cmpf;
        -: 2240:				}
        -: 2241:			}
    #####: 2242:			c = 0;
    #####: 2243:			if (c + 0 < p->cost[_reg_NT]) {
    #####: 2244:				p->cost[_reg_NT] = c + 0;
    #####: 2245:				p->rule._reg = 3;
    #####: 2246:				_closure_reg(a, c + 0);
        -: 2247:			}
        -: 2248:		}
        -: 2249:		/* mem: INDIRI2(addr) */
    #####: 2250:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + 0;
    #####: 2251:		if (c + 0 < p->cost[_mem_NT]) {
    #####: 2252:			p->cost[_mem_NT] = c + 0;
    #####: 2253:			p->rule._mem = 2;
    #####: 2254:			_closure_mem(a, c + 0);
        -: 2255:		}
    #####: 2256:		break;
        -: 2257:	case 2118: /* INDIRU2 */
    #####: 2258:		_label(LEFT_CHILD(a));
    #####: 2259:		if (	/* reg: INDIRU2(VREGP) */
        -: 2260:			LEFT_CHILD(a)->op == 711 /* VREGP */
        -: 2261:		) {
    #####: 2262:			if (mayrecalc(a)) {
    #####: 2263:				struct _state *q = a->syms[RX]->u.t.cse->x.state;
    #####: 2264:				if (q->cost[_stmt_NT] == 0) {
    #####: 2265:					p->cost[_stmt_NT] = 0;
    #####: 2266:					p->rule._stmt = q->rule._stmt;
        -: 2267:				}
    #####: 2268:				if (q->cost[_reg_NT] == 0) {
    #####: 2269:					p->cost[_reg_NT] = 0;
    #####: 2270:					p->rule._reg = q->rule._reg;
        -: 2271:				}
    #####: 2272:				if (q->cost[_con_NT] == 0) {
    #####: 2273:					p->cost[_con_NT] = 0;
    #####: 2274:					p->rule._con = q->rule._con;
        -: 2275:				}
    #####: 2276:				if (q->cost[_acon_NT] == 0) {
    #####: 2277:					p->cost[_acon_NT] = 0;
    #####: 2278:					p->rule._acon = q->rule._acon;
        -: 2279:				}
    #####: 2280:				if (q->cost[_base_NT] == 0) {
    #####: 2281:					p->cost[_base_NT] = 0;
    #####: 2282:					p->rule._base = q->rule._base;
        -: 2283:				}
    #####: 2284:				if (q->cost[_index_NT] == 0) {
    #####: 2285:					p->cost[_index_NT] = 0;
    #####: 2286:					p->rule._index = q->rule._index;
        -: 2287:				}
    #####: 2288:				if (q->cost[_con1_NT] == 0) {
    #####: 2289:					p->cost[_con1_NT] = 0;
    #####: 2290:					p->rule._con1 = q->rule._con1;
        -: 2291:				}
    #####: 2292:				if (q->cost[_con2_NT] == 0) {
    #####: 2293:					p->cost[_con2_NT] = 0;
    #####: 2294:					p->rule._con2 = q->rule._con2;
        -: 2295:				}
    #####: 2296:				if (q->cost[_con3_NT] == 0) {
    #####: 2297:					p->cost[_con3_NT] = 0;
    #####: 2298:					p->rule._con3 = q->rule._con3;
        -: 2299:				}
    #####: 2300:				if (q->cost[_addr_NT] == 0) {
    #####: 2301:					p->cost[_addr_NT] = 0;
    #####: 2302:					p->rule._addr = q->rule._addr;
        -: 2303:				}
    #####: 2304:				if (q->cost[_mem_NT] == 0) {
    #####: 2305:					p->cost[_mem_NT] = 0;
    #####: 2306:					p->rule._mem = q->rule._mem;
        -: 2307:				}
    #####: 2308:				if (q->cost[_rc_NT] == 0) {
    #####: 2309:					p->cost[_rc_NT] = 0;
    #####: 2310:					p->rule._rc = q->rule._rc;
        -: 2311:				}
    #####: 2312:				if (q->cost[_mr_NT] == 0) {
    #####: 2313:					p->cost[_mr_NT] = 0;
    #####: 2314:					p->rule._mr = q->rule._mr;
        -: 2315:				}
    #####: 2316:				if (q->cost[_mrc0_NT] == 0) {
    #####: 2317:					p->cost[_mrc0_NT] = 0;
    #####: 2318:					p->rule._mrc0 = q->rule._mrc0;
        -: 2319:				}
    #####: 2320:				if (q->cost[_mrc1_NT] == 0) {
    #####: 2321:					p->cost[_mrc1_NT] = 0;
    #####: 2322:					p->rule._mrc1 = q->rule._mrc1;
        -: 2323:				}
    #####: 2324:				if (q->cost[_mrc3_NT] == 0) {
    #####: 2325:					p->cost[_mrc3_NT] = 0;
    #####: 2326:					p->rule._mrc3 = q->rule._mrc3;
        -: 2327:				}
    #####: 2328:				if (q->cost[_con5_NT] == 0) {
    #####: 2329:					p->cost[_con5_NT] = 0;
    #####: 2330:					p->rule._con5 = q->rule._con5;
        -: 2331:				}
    #####: 2332:				if (q->cost[_memf_NT] == 0) {
    #####: 2333:					p->cost[_memf_NT] = 0;
    #####: 2334:					p->rule._memf = q->rule._memf;
        -: 2335:				}
    #####: 2336:				if (q->cost[_flt_NT] == 0) {
    #####: 2337:					p->cost[_flt_NT] = 0;
    #####: 2338:					p->rule._flt = q->rule._flt;
        -: 2339:				}
    #####: 2340:				if (q->cost[_addrj_NT] == 0) {
    #####: 2341:					p->cost[_addrj_NT] = 0;
    #####: 2342:					p->rule._addrj = q->rule._addrj;
        -: 2343:				}
    #####: 2344:				if (q->cost[_cmpf_NT] == 0) {
    #####: 2345:					p->cost[_cmpf_NT] = 0;
    #####: 2346:					p->rule._cmpf = q->rule._cmpf;
        -: 2347:				}
        -: 2348:			}
    #####: 2349:			c = 0;
    #####: 2350:			if (c + 0 < p->cost[_reg_NT]) {
    #####: 2351:				p->cost[_reg_NT] = c + 0;
    #####: 2352:				p->rule._reg = 4;
    #####: 2353:				_closure_reg(a, c + 0);
        -: 2354:			}
        -: 2355:		}
        -: 2356:		/* mem: INDIRU2(addr) */
    #####: 2357:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + 0;
    #####: 2358:		if (c + 0 < p->cost[_mem_NT]) {
    #####: 2359:			p->cost[_mem_NT] = c + 0;
    #####: 2360:			p->rule._mem = 5;
    #####: 2361:			_closure_mem(a, c + 0);
        -: 2362:		}
    #####: 2363:		break;
        -: 2364:	case 2181: /* CVII2 */
    #####: 2365:		_label(LEFT_CHILD(a));
        -: 2366:		/* reg: CVII2(reg) */
    #####: 2367:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + 1;
    #####: 2368:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 2369:			p->cost[_reg_NT] = c + 0;
    #####: 2370:			p->rule._reg = 63;
    #####: 2371:			_closure_reg(a, c + 0);
        -: 2372:		}
    #####: 2373:		break;
        -: 2374:	case 2182: /* CVIU2 */
    #####: 2375:		break;
        -: 2376:	case 2229: /* CVUI2 */
    #####: 2377:		break;
        -: 2378:	case 2230: /* CVUU2 */
    #####: 2379:		_label(LEFT_CHILD(a));
        -: 2380:		/* reg: CVUU2(reg) */
    #####: 2381:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + 1;
    #####: 2382:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 2383:			p->cost[_reg_NT] = c + 0;
    #####: 2384:			p->rule._reg = 65;
    #####: 2385:			_closure_reg(a, c + 0);
        -: 2386:		}
    #####: 2387:		break;
        -: 2388:	case 2277: /* LOADI2 */
    #####: 2389:		_label(LEFT_CHILD(a));
        -: 2390:		/* reg: LOADI2(reg) */
    #####: 2391:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + 1;
    #####: 2392:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 2393:			p->cost[_reg_NT] = c + 0;
    #####: 2394:			p->rule._reg = 16;
    #####: 2395:			_closure_reg(a, c + 0);
        -: 2396:		}
    #####: 2397:		break;
        -: 2398:	case 2278: /* LOADU2 */
    #####: 2399:		_label(LEFT_CHILD(a));
        -: 2400:		/* reg: LOADU2(reg) */
    #####: 2401:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + 1;
    #####: 2402:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 2403:			p->cost[_reg_NT] = c + 0;
    #####: 2404:			p->rule._reg = 19;
    #####: 2405:			_closure_reg(a, c + 0);
        -: 2406:		}
    #####: 2407:		break;
        -: 2408:	case 4113: /* CNSTF4 */
    #####: 2409:		break;
        -: 2410:	case 4117: /* CNSTI4 */
        -: 2411:		/* con: CNSTI4 */
    #####: 2412:		if (0 + 0 < p->cost[_con_NT]) {
    #####: 2413:			p->cost[_con_NT] = 0 + 0;
    #####: 2414:			p->rule._con = 5;
    #####: 2415:			_closure_con(a, 0 + 0);
        -: 2416:		}
        -: 2417:		/* con1: CNSTI4 */
    #####: 2418:		c = (range(a, 1, 1));
    #####: 2419:		if (c + 0 < p->cost[_con1_NT]) {
    #####: 2420:			p->cost[_con1_NT] = c + 0;
    #####: 2421:			p->rule._con1 = 1;
        -: 2422:		}
        -: 2423:		/* con2: CNSTI4 */
    #####: 2424:		c = (range(a, 2, 2));
    #####: 2425:		if (c + 0 < p->cost[_con2_NT]) {
    #####: 2426:			p->cost[_con2_NT] = c + 0;
    #####: 2427:			p->rule._con2 = 1;
        -: 2428:		}
        -: 2429:		/* con3: CNSTI4 */
    #####: 2430:		c = (range(a, 3, 3));
    #####: 2431:		if (c + 0 < p->cost[_con3_NT]) {
    #####: 2432:			p->cost[_con3_NT] = c + 0;
    #####: 2433:			p->rule._con3 = 1;
        -: 2434:		}
        -: 2435:		/* con5: CNSTI4 */
    #####: 2436:		c = (range(a, 0, 31));
    #####: 2437:		if (c + 0 < p->cost[_con5_NT]) {
    #####: 2438:			p->cost[_con5_NT] = c + 0;
    #####: 2439:			p->rule._con5 = 1;
        -: 2440:		}
    #####: 2441:		break;
        -: 2442:	case 4118: /* CNSTU4 */
        -: 2443:		/* con: CNSTU4 */
    #####: 2444:		if (0 + 0 < p->cost[_con_NT]) {
    #####: 2445:			p->cost[_con_NT] = 0 + 0;
    #####: 2446:			p->rule._con = 6;
    #####: 2447:			_closure_con(a, 0 + 0);
        -: 2448:		}
        -: 2449:		/* con1: CNSTU4 */
    #####: 2450:		c = (range(a, 1, 1));
    #####: 2451:		if (c + 0 < p->cost[_con1_NT]) {
    #####: 2452:			p->cost[_con1_NT] = c + 0;
    #####: 2453:			p->rule._con1 = 2;
        -: 2454:		}
        -: 2455:		/* con2: CNSTU4 */
    #####: 2456:		c = (range(a, 2, 2));
    #####: 2457:		if (c + 0 < p->cost[_con2_NT]) {
    #####: 2458:			p->cost[_con2_NT] = c + 0;
    #####: 2459:			p->rule._con2 = 2;
        -: 2460:		}
        -: 2461:		/* con3: CNSTU4 */
    #####: 2462:		c = (range(a, 3, 3));
    #####: 2463:		if (c + 0 < p->cost[_con3_NT]) {
    #####: 2464:			p->cost[_con3_NT] = c + 0;
    #####: 2465:			p->rule._con3 = 2;
        -: 2466:		}
    #####: 2467:		break;
        -: 2468:	case 4119: /* CNSTP4 */
        -: 2469:		/* con: CNSTP4 */
    #####: 2470:		if (0 + 0 < p->cost[_con_NT]) {
    #####: 2471:			p->cost[_con_NT] = 0 + 0;
    #####: 2472:			p->rule._con = 7;
    #####: 2473:			_closure_con(a, 0 + 0);
        -: 2474:		}
    #####: 2475:		break;
        -: 2476:	case 4129: /* ARGF4 */
    #####: 2477:		_label(LEFT_CHILD(a));
        -: 2478:		/* stmt: ARGF4(reg) */
    #####: 2479:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
    #####: 2480:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 2481:			p->cost[_stmt_NT] = c + 0;
    #####: 2482:			p->rule._stmt = 53;
        -: 2483:		}
    #####: 2484:		break;
        -: 2485:	case 4133: /* ARGI4 */
    #####: 2486:		_label(LEFT_CHILD(a));
        -: 2487:		/* stmt: ARGI4(mrc3) */
    #####: 2488:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_mrc3_NT] + 1;
    #####: 2489:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 2490:			p->cost[_stmt_NT] = c + 0;
    #####: 2491:			p->rule._stmt = 44;
        -: 2492:		}
    #####: 2493:		break;
        -: 2494:	case 4134: /* ARGU4 */
    #####: 2495:		_label(LEFT_CHILD(a));
        -: 2496:		/* stmt: ARGU4(mrc3) */
    #####: 2497:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_mrc3_NT] + 1;
    #####: 2498:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 2499:			p->cost[_stmt_NT] = c + 0;
    #####: 2500:			p->rule._stmt = 45;
        -: 2501:		}
    #####: 2502:		break;
        -: 2503:	case 4135: /* ARGP4 */
    #####: 2504:		_label(LEFT_CHILD(a));
        -: 2505:		/* stmt: ARGP4(mrc3) */
    #####: 2506:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_mrc3_NT] + 1;
    #####: 2507:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 2508:			p->cost[_stmt_NT] = c + 0;
    #####: 2509:			p->rule._stmt = 46;
        -: 2510:		}
    #####: 2511:		break;
        -: 2512:	case 4145: /* ASGNF4 */
    #####: 2513:		_label(LEFT_CHILD(a));
    #####: 2514:		_label(RIGHT_CHILD(a));
    #####: 2515:		if (	/* stmt: ASGNF4(VREGP,reg) */
        -: 2516:			LEFT_CHILD(a)->op == 711 /* VREGP */
        -: 2517:		) {
    #####: 2518:			c = ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
    #####: 2519:			if (c + 0 < p->cost[_stmt_NT]) {
    #####: 2520:				p->cost[_stmt_NT] = c + 0;
    #####: 2521:				p->rule._stmt = 5;
        -: 2522:			}
        -: 2523:		}
        -: 2524:		/* stmt: ASGNF4(addr,reg) */
    #####: 2525:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_reg_NT] + 7;
    #####: 2526:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 2527:			p->cost[_stmt_NT] = c + 0;
    #####: 2528:			p->rule._stmt = 50;
        -: 2529:		}
    #####: 2530:		if (	/* stmt: ASGNF4(addr,CVFF4(reg)) */
        -: 2531:			RIGHT_CHILD(a)->op == 4209 /* CVFF4 */
        -: 2532:		) {
    #####: 2533:			c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(LEFT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_reg_NT] + 7;
    #####: 2534:			if (c + 0 < p->cost[_stmt_NT]) {
    #####: 2535:				p->cost[_stmt_NT] = c + 0;
    #####: 2536:				p->rule._stmt = 51;
        -: 2537:			}
        -: 2538:		}
    #####: 2539:		break;
        -: 2540:	case 4149: /* ASGNI4 */
    #####: 2541:		_label(LEFT_CHILD(a));
    #####: 2542:		_label(RIGHT_CHILD(a));
    #####: 2543:		if (	/* stmt: ASGNI4(VREGP,reg) */
        -: 2544:			LEFT_CHILD(a)->op == 711 /* VREGP */
        -: 2545:		) {
    #####: 2546:			c = ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
    #####: 2547:			if (c + 0 < p->cost[_stmt_NT]) {
    #####: 2548:				p->cost[_stmt_NT] = c + 0;
    #####: 2549:				p->rule._stmt = 6;
        -: 2550:			}
        -: 2551:		}
    #####: 2552:		if (	/* stmt: ASGNI4(addr,ADDI4(mem,con1)) */
        -: 2553:			RIGHT_CHILD(a)->op == 4405 /* ADDI4 */
        -: 2554:		) {
    #####: 2555:			c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(LEFT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_mem_NT] + ((struct _state *)(RIGHT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_con1_NT] + (memop(a));
    #####: 2556:			if (c + 0 < p->cost[_stmt_NT]) {
    #####: 2557:				p->cost[_stmt_NT] = c + 0;
    #####: 2558:				p->rule._stmt = 14;
        -: 2559:			}
        -: 2560:		}
    #####: 2561:		if (	/* stmt: ASGNI4(addr,ADDU4(mem,con1)) */
        -: 2562:			RIGHT_CHILD(a)->op == 4406 /* ADDU4 */
        -: 2563:		) {
    #####: 2564:			c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(LEFT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_mem_NT] + ((struct _state *)(RIGHT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_con1_NT] + (memop(a));
    #####: 2565:			if (c + 0 < p->cost[_stmt_NT]) {
    #####: 2566:				p->cost[_stmt_NT] = c + 0;
    #####: 2567:				p->rule._stmt = 15;
        -: 2568:			}
        -: 2569:		}
    #####: 2570:		if (	/* stmt: ASGNI4(addr,SUBI4(mem,con1)) */
        -: 2571:			RIGHT_CHILD(a)->op == 4421 /* SUBI4 */
        -: 2572:		) {
    #####: 2573:			c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(LEFT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_mem_NT] + ((struct _state *)(RIGHT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_con1_NT] + (memop(a));
    #####: 2574:			if (c + 0 < p->cost[_stmt_NT]) {
    #####: 2575:				p->cost[_stmt_NT] = c + 0;
    #####: 2576:				p->rule._stmt = 17;
        -: 2577:			}
        -: 2578:		}
    #####: 2579:		if (	/* stmt: ASGNI4(addr,SUBU4(mem,con1)) */
        -: 2580:			RIGHT_CHILD(a)->op == 4422 /* SUBU4 */
        -: 2581:		) {
    #####: 2582:			c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(LEFT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_mem_NT] + ((struct _state *)(RIGHT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_con1_NT] + (memop(a));
    #####: 2583:			if (c + 0 < p->cost[_stmt_NT]) {
    #####: 2584:				p->cost[_stmt_NT] = c + 0;
    #####: 2585:				p->rule._stmt = 18;
        -: 2586:			}
        -: 2587:		}
    #####: 2588:		if (	/* stmt: ASGNI4(addr,ADDI4(mem,rc)) */
        -: 2589:			RIGHT_CHILD(a)->op == 4405 /* ADDI4 */
        -: 2590:		) {
    #####: 2591:			c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(LEFT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_mem_NT] + ((struct _state *)(RIGHT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_rc_NT] + (memop(a));
    #####: 2592:			if (c + 0 < p->cost[_stmt_NT]) {
    #####: 2593:				p->cost[_stmt_NT] = c + 0;
    #####: 2594:				p->rule._stmt = 20;
        -: 2595:			}
        -: 2596:		}
    #####: 2597:		if (	/* stmt: ASGNI4(addr,SUBI4(mem,rc)) */
        -: 2598:			RIGHT_CHILD(a)->op == 4421 /* SUBI4 */
        -: 2599:		) {
    #####: 2600:			c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(LEFT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_mem_NT] + ((struct _state *)(RIGHT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_rc_NT] + (memop(a));
    #####: 2601:			if (c + 0 < p->cost[_stmt_NT]) {
    #####: 2602:				p->cost[_stmt_NT] = c + 0;
    #####: 2603:				p->rule._stmt = 21;
        -: 2604:			}
        -: 2605:		}
    #####: 2606:		if (	/* stmt: ASGNI4(addr,BANDI4(mem,rc)) */
        -: 2607:			RIGHT_CHILD(a)->op == 4485 /* BANDI4 */
        -: 2608:		) {
    #####: 2609:			c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(LEFT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_mem_NT] + ((struct _state *)(RIGHT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_rc_NT] + (memop(a));
    #####: 2610:			if (c + 0 < p->cost[_stmt_NT]) {
    #####: 2611:				p->cost[_stmt_NT] = c + 0;
    #####: 2612:				p->rule._stmt = 24;
        -: 2613:			}
        -: 2614:		}
    #####: 2615:		if (	/* stmt: ASGNI4(addr,BORI4(mem,rc)) */
        -: 2616:			RIGHT_CHILD(a)->op == 4517 /* BORI4 */
        -: 2617:		) {
    #####: 2618:			c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(LEFT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_mem_NT] + ((struct _state *)(RIGHT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_rc_NT] + (memop(a));
    #####: 2619:			if (c + 0 < p->cost[_stmt_NT]) {
    #####: 2620:				p->cost[_stmt_NT] = c + 0;
    #####: 2621:				p->rule._stmt = 25;
        -: 2622:			}
        -: 2623:		}
    #####: 2624:		if (	/* stmt: ASGNI4(addr,BXORI4(mem,rc)) */
        -: 2625:			RIGHT_CHILD(a)->op == 4533 /* BXORI4 */
        -: 2626:		) {
    #####: 2627:			c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(LEFT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_mem_NT] + ((struct _state *)(RIGHT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_rc_NT] + (memop(a));
    #####: 2628:			if (c + 0 < p->cost[_stmt_NT]) {
    #####: 2629:				p->cost[_stmt_NT] = c + 0;
    #####: 2630:				p->rule._stmt = 26;
        -: 2631:			}
        -: 2632:		}
    #####: 2633:		if (	/* stmt: ASGNI4(addr,BCOMI4(mem)) */
        -: 2634:			RIGHT_CHILD(a)->op == 4501 /* BCOMI4 */
        -: 2635:		) {
    #####: 2636:			c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(LEFT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_mem_NT] + (memop(a));
    #####: 2637:			if (c + 0 < p->cost[_stmt_NT]) {
    #####: 2638:				p->cost[_stmt_NT] = c + 0;
    #####: 2639:				p->rule._stmt = 30;
        -: 2640:			}
        -: 2641:		}
    #####: 2642:		if (	/* stmt: ASGNI4(addr,NEGI4(mem)) */
        -: 2643:			RIGHT_CHILD(a)->op == 4293 /* NEGI4 */
        -: 2644:		) {
    #####: 2645:			c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(LEFT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_mem_NT] + (memop(a));
    #####: 2646:			if (c + 0 < p->cost[_stmt_NT]) {
    #####: 2647:				p->cost[_stmt_NT] = c + 0;
    #####: 2648:				p->rule._stmt = 32;
        -: 2649:			}
        -: 2650:		}
    #####: 2651:		if (	/* stmt: ASGNI4(addr,LSHI4(mem,con5)) */
        -: 2652:			RIGHT_CHILD(a)->op == 4437 /* LSHI4 */
        -: 2653:		) {
    #####: 2654:			c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(LEFT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_mem_NT] + ((struct _state *)(RIGHT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_con5_NT] + (memop(a));
    #####: 2655:			if (c + 0 < p->cost[_stmt_NT]) {
    #####: 2656:				p->cost[_stmt_NT] = c + 0;
    #####: 2657:				p->rule._stmt = 33;
        -: 2658:			}
        -: 2659:		}
    #####: 2660:		if (	/* stmt: ASGNI4(addr,LSHU4(mem,con5)) */
        -: 2661:			RIGHT_CHILD(a)->op == 4438 /* LSHU4 */
        -: 2662:		) {
    #####: 2663:			c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(LEFT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_mem_NT] + ((struct _state *)(RIGHT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_con5_NT] + (memop(a));
    #####: 2664:			if (c + 0 < p->cost[_stmt_NT]) {
    #####: 2665:				p->cost[_stmt_NT] = c + 0;
    #####: 2666:				p->rule._stmt = 34;
        -: 2667:			}
        -: 2668:		}
    #####: 2669:		if (	/* stmt: ASGNI4(addr,RSHI4(mem,con5)) */
        -: 2670:			RIGHT_CHILD(a)->op == 4469 /* RSHI4 */
        -: 2671:		) {
    #####: 2672:			c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(LEFT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_mem_NT] + ((struct _state *)(RIGHT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_con5_NT] + (memop(a));
    #####: 2673:			if (c + 0 < p->cost[_stmt_NT]) {
    #####: 2674:				p->cost[_stmt_NT] = c + 0;
    #####: 2675:				p->rule._stmt = 35;
        -: 2676:			}
        -: 2677:		}
    #####: 2678:		if (	/* stmt: ASGNI4(addr,RSHU4(mem,con5)) */
        -: 2679:			RIGHT_CHILD(a)->op == 4470 /* RSHU4 */
        -: 2680:		) {
    #####: 2681:			c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(LEFT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_mem_NT] + ((struct _state *)(RIGHT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_con5_NT] + (memop(a));
    #####: 2682:			if (c + 0 < p->cost[_stmt_NT]) {
    #####: 2683:				p->cost[_stmt_NT] = c + 0;
    #####: 2684:				p->rule._stmt = 36;
        -: 2685:			}
        -: 2686:		}
        -: 2687:		/* stmt: ASGNI4(addr,rc) */
    #####: 2688:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_rc_NT] + 1;
    #####: 2689:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 2690:			p->cost[_stmt_NT] = c + 0;
    #####: 2691:			p->rule._stmt = 39;
        -: 2692:		}
    #####: 2693:		break;
        -: 2694:	case 4150: /* ASGNU4 */
    #####: 2695:		_label(LEFT_CHILD(a));
    #####: 2696:		_label(RIGHT_CHILD(a));
    #####: 2697:		if (	/* stmt: ASGNU4(VREGP,reg) */
        -: 2698:			LEFT_CHILD(a)->op == 711 /* VREGP */
        -: 2699:		) {
    #####: 2700:			c = ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
    #####: 2701:			if (c + 0 < p->cost[_stmt_NT]) {
    #####: 2702:				p->cost[_stmt_NT] = c + 0;
    #####: 2703:				p->rule._stmt = 8;
        -: 2704:			}
        -: 2705:		}
    #####: 2706:		if (	/* stmt: ASGNU4(addr,ADDU4(mem,rc)) */
        -: 2707:			RIGHT_CHILD(a)->op == 4406 /* ADDU4 */
        -: 2708:		) {
    #####: 2709:			c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(LEFT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_mem_NT] + ((struct _state *)(RIGHT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_rc_NT] + (memop(a));
    #####: 2710:			if (c + 0 < p->cost[_stmt_NT]) {
    #####: 2711:				p->cost[_stmt_NT] = c + 0;
    #####: 2712:				p->rule._stmt = 22;
        -: 2713:			}
        -: 2714:		}
    #####: 2715:		if (	/* stmt: ASGNU4(addr,SUBU4(mem,rc)) */
        -: 2716:			RIGHT_CHILD(a)->op == 4422 /* SUBU4 */
        -: 2717:		) {
    #####: 2718:			c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(LEFT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_mem_NT] + ((struct _state *)(RIGHT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_rc_NT] + (memop(a));
    #####: 2719:			if (c + 0 < p->cost[_stmt_NT]) {
    #####: 2720:				p->cost[_stmt_NT] = c + 0;
    #####: 2721:				p->rule._stmt = 23;
        -: 2722:			}
        -: 2723:		}
    #####: 2724:		if (	/* stmt: ASGNU4(addr,BANDU4(mem,rc)) */
        -: 2725:			RIGHT_CHILD(a)->op == 4486 /* BANDU4 */
        -: 2726:		) {
    #####: 2727:			c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(LEFT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_mem_NT] + ((struct _state *)(RIGHT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_rc_NT] + (memop(a));
    #####: 2728:			if (c + 0 < p->cost[_stmt_NT]) {
    #####: 2729:				p->cost[_stmt_NT] = c + 0;
    #####: 2730:				p->rule._stmt = 27;
        -: 2731:			}
        -: 2732:		}
    #####: 2733:		if (	/* stmt: ASGNU4(addr,BORU4(mem,rc)) */
        -: 2734:			RIGHT_CHILD(a)->op == 4518 /* BORU4 */
        -: 2735:		) {
    #####: 2736:			c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(LEFT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_mem_NT] + ((struct _state *)(RIGHT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_rc_NT] + (memop(a));
    #####: 2737:			if (c + 0 < p->cost[_stmt_NT]) {
    #####: 2738:				p->cost[_stmt_NT] = c + 0;
    #####: 2739:				p->rule._stmt = 28;
        -: 2740:			}
        -: 2741:		}
    #####: 2742:		if (	/* stmt: ASGNU4(addr,BXORU4(mem,rc)) */
        -: 2743:			RIGHT_CHILD(a)->op == 4534 /* BXORU4 */
        -: 2744:		) {
    #####: 2745:			c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(LEFT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_mem_NT] + ((struct _state *)(RIGHT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_rc_NT] + (memop(a));
    #####: 2746:			if (c + 0 < p->cost[_stmt_NT]) {
    #####: 2747:				p->cost[_stmt_NT] = c + 0;
    #####: 2748:				p->rule._stmt = 29;
        -: 2749:			}
        -: 2750:		}
    #####: 2751:		if (	/* stmt: ASGNU4(addr,BCOMU4(mem)) */
        -: 2752:			RIGHT_CHILD(a)->op == 4502 /* BCOMU4 */
        -: 2753:		) {
    #####: 2754:			c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(LEFT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_mem_NT] + (memop(a));
    #####: 2755:			if (c + 0 < p->cost[_stmt_NT]) {
    #####: 2756:				p->cost[_stmt_NT] = c + 0;
    #####: 2757:				p->rule._stmt = 31;
        -: 2758:			}
        -: 2759:		}
        -: 2760:		/* stmt: ASGNU4(addr,rc) */
    #####: 2761:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_rc_NT] + 1;
    #####: 2762:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 2763:			p->cost[_stmt_NT] = c + 0;
    #####: 2764:			p->rule._stmt = 42;
        -: 2765:		}
    #####: 2766:		break;
        -: 2767:	case 4151: /* ASGNP4 */
    #####: 2768:		_label(LEFT_CHILD(a));
    #####: 2769:		_label(RIGHT_CHILD(a));
    #####: 2770:		if (	/* stmt: ASGNP4(VREGP,reg) */
        -: 2771:			LEFT_CHILD(a)->op == 711 /* VREGP */
        -: 2772:		) {
    #####: 2773:			c = ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
    #####: 2774:			if (c + 0 < p->cost[_stmt_NT]) {
    #####: 2775:				p->cost[_stmt_NT] = c + 0;
    #####: 2776:				p->rule._stmt = 7;
        -: 2777:			}
        -: 2778:		}
    #####: 2779:		if (	/* stmt: ASGNP4(addr,ADDP4(mem,con1)) */
        -: 2780:			RIGHT_CHILD(a)->op == 4407 /* ADDP4 */
        -: 2781:		) {
    #####: 2782:			c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(LEFT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_mem_NT] + ((struct _state *)(RIGHT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_con1_NT] + (memop(a));
    #####: 2783:			if (c + 0 < p->cost[_stmt_NT]) {
    #####: 2784:				p->cost[_stmt_NT] = c + 0;
    #####: 2785:				p->rule._stmt = 16;
        -: 2786:			}
        -: 2787:		}
    #####: 2788:		if (	/* stmt: ASGNP4(addr,SUBP4(mem,con1)) */
        -: 2789:			RIGHT_CHILD(a)->op == 4423 /* SUBP4 */
        -: 2790:		) {
    #####: 2791:			c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(LEFT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_mem_NT] + ((struct _state *)(RIGHT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_con1_NT] + (memop(a));
    #####: 2792:			if (c + 0 < p->cost[_stmt_NT]) {
    #####: 2793:				p->cost[_stmt_NT] = c + 0;
    #####: 2794:				p->rule._stmt = 19;
        -: 2795:			}
        -: 2796:		}
        -: 2797:		/* stmt: ASGNP4(addr,rc) */
    #####: 2798:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_rc_NT] + 1;
    #####: 2799:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 2800:			p->cost[_stmt_NT] = c + 0;
    #####: 2801:			p->rule._stmt = 43;
        -: 2802:		}
    #####: 2803:		break;
        -: 2804:	case 4161: /* INDIRF4 */
    #####: 2805:		_label(LEFT_CHILD(a));
    #####: 2806:		if (	/* reg: INDIRF4(VREGP) */
        -: 2807:			LEFT_CHILD(a)->op == 711 /* VREGP */
        -: 2808:		) {
    #####: 2809:			if (mayrecalc(a)) {
    #####: 2810:				struct _state *q = a->syms[RX]->u.t.cse->x.state;
    #####: 2811:				if (q->cost[_stmt_NT] == 0) {
    #####: 2812:					p->cost[_stmt_NT] = 0;
    #####: 2813:					p->rule._stmt = q->rule._stmt;
        -: 2814:				}
    #####: 2815:				if (q->cost[_reg_NT] == 0) {
    #####: 2816:					p->cost[_reg_NT] = 0;
    #####: 2817:					p->rule._reg = q->rule._reg;
        -: 2818:				}
    #####: 2819:				if (q->cost[_con_NT] == 0) {
    #####: 2820:					p->cost[_con_NT] = 0;
    #####: 2821:					p->rule._con = q->rule._con;
        -: 2822:				}
    #####: 2823:				if (q->cost[_acon_NT] == 0) {
    #####: 2824:					p->cost[_acon_NT] = 0;
    #####: 2825:					p->rule._acon = q->rule._acon;
        -: 2826:				}
    #####: 2827:				if (q->cost[_base_NT] == 0) {
    #####: 2828:					p->cost[_base_NT] = 0;
    #####: 2829:					p->rule._base = q->rule._base;
        -: 2830:				}
    #####: 2831:				if (q->cost[_index_NT] == 0) {
    #####: 2832:					p->cost[_index_NT] = 0;
    #####: 2833:					p->rule._index = q->rule._index;
        -: 2834:				}
    #####: 2835:				if (q->cost[_con1_NT] == 0) {
    #####: 2836:					p->cost[_con1_NT] = 0;
    #####: 2837:					p->rule._con1 = q->rule._con1;
        -: 2838:				}
    #####: 2839:				if (q->cost[_con2_NT] == 0) {
    #####: 2840:					p->cost[_con2_NT] = 0;
    #####: 2841:					p->rule._con2 = q->rule._con2;
        -: 2842:				}
    #####: 2843:				if (q->cost[_con3_NT] == 0) {
    #####: 2844:					p->cost[_con3_NT] = 0;
    #####: 2845:					p->rule._con3 = q->rule._con3;
        -: 2846:				}
    #####: 2847:				if (q->cost[_addr_NT] == 0) {
    #####: 2848:					p->cost[_addr_NT] = 0;
    #####: 2849:					p->rule._addr = q->rule._addr;
        -: 2850:				}
    #####: 2851:				if (q->cost[_mem_NT] == 0) {
    #####: 2852:					p->cost[_mem_NT] = 0;
    #####: 2853:					p->rule._mem = q->rule._mem;
        -: 2854:				}
    #####: 2855:				if (q->cost[_rc_NT] == 0) {
    #####: 2856:					p->cost[_rc_NT] = 0;
    #####: 2857:					p->rule._rc = q->rule._rc;
        -: 2858:				}
    #####: 2859:				if (q->cost[_mr_NT] == 0) {
    #####: 2860:					p->cost[_mr_NT] = 0;
    #####: 2861:					p->rule._mr = q->rule._mr;
        -: 2862:				}
    #####: 2863:				if (q->cost[_mrc0_NT] == 0) {
    #####: 2864:					p->cost[_mrc0_NT] = 0;
    #####: 2865:					p->rule._mrc0 = q->rule._mrc0;
        -: 2866:				}
    #####: 2867:				if (q->cost[_mrc1_NT] == 0) {
    #####: 2868:					p->cost[_mrc1_NT] = 0;
    #####: 2869:					p->rule._mrc1 = q->rule._mrc1;
        -: 2870:				}
    #####: 2871:				if (q->cost[_mrc3_NT] == 0) {
    #####: 2872:					p->cost[_mrc3_NT] = 0;
    #####: 2873:					p->rule._mrc3 = q->rule._mrc3;
        -: 2874:				}
    #####: 2875:				if (q->cost[_con5_NT] == 0) {
    #####: 2876:					p->cost[_con5_NT] = 0;
    #####: 2877:					p->rule._con5 = q->rule._con5;
        -: 2878:				}
    #####: 2879:				if (q->cost[_memf_NT] == 0) {
    #####: 2880:					p->cost[_memf_NT] = 0;
    #####: 2881:					p->rule._memf = q->rule._memf;
        -: 2882:				}
    #####: 2883:				if (q->cost[_flt_NT] == 0) {
    #####: 2884:					p->cost[_flt_NT] = 0;
    #####: 2885:					p->rule._flt = q->rule._flt;
        -: 2886:				}
    #####: 2887:				if (q->cost[_addrj_NT] == 0) {
    #####: 2888:					p->cost[_addrj_NT] = 0;
    #####: 2889:					p->rule._addrj = q->rule._addrj;
        -: 2890:				}
    #####: 2891:				if (q->cost[_cmpf_NT] == 0) {
    #####: 2892:					p->cost[_cmpf_NT] = 0;
    #####: 2893:					p->rule._cmpf = q->rule._cmpf;
        -: 2894:				}
        -: 2895:			}
    #####: 2896:			c = 0;
    #####: 2897:			if (c + 0 < p->cost[_reg_NT]) {
    #####: 2898:				p->cost[_reg_NT] = c + 0;
    #####: 2899:				p->rule._reg = 5;
    #####: 2900:				_closure_reg(a, c + 0);
        -: 2901:			}
        -: 2902:		}
        -: 2903:		/* memf: INDIRF4(addr) */
    #####: 2904:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + 0;
    #####: 2905:		if (c + 0 < p->cost[_memf_NT]) {
    #####: 2906:			p->cost[_memf_NT] = c + 0;
    #####: 2907:			p->rule._memf = 2;
    #####: 2908:			_closure_memf(a, c + 0);
        -: 2909:		}
    #####: 2910:		break;
        -: 2911:	case 4165: /* INDIRI4 */
    #####: 2912:		_label(LEFT_CHILD(a));
    #####: 2913:		if (	/* reg: INDIRI4(VREGP) */
        -: 2914:			LEFT_CHILD(a)->op == 711 /* VREGP */
        -: 2915:		) {
    #####: 2916:			if (mayrecalc(a)) {
    #####: 2917:				struct _state *q = a->syms[RX]->u.t.cse->x.state;
    #####: 2918:				if (q->cost[_stmt_NT] == 0) {
    #####: 2919:					p->cost[_stmt_NT] = 0;
    #####: 2920:					p->rule._stmt = q->rule._stmt;
        -: 2921:				}
    #####: 2922:				if (q->cost[_reg_NT] == 0) {
    #####: 2923:					p->cost[_reg_NT] = 0;
    #####: 2924:					p->rule._reg = q->rule._reg;
        -: 2925:				}
    #####: 2926:				if (q->cost[_con_NT] == 0) {
    #####: 2927:					p->cost[_con_NT] = 0;
    #####: 2928:					p->rule._con = q->rule._con;
        -: 2929:				}
    #####: 2930:				if (q->cost[_acon_NT] == 0) {
    #####: 2931:					p->cost[_acon_NT] = 0;
    #####: 2932:					p->rule._acon = q->rule._acon;
        -: 2933:				}
    #####: 2934:				if (q->cost[_base_NT] == 0) {
    #####: 2935:					p->cost[_base_NT] = 0;
    #####: 2936:					p->rule._base = q->rule._base;
        -: 2937:				}
    #####: 2938:				if (q->cost[_index_NT] == 0) {
    #####: 2939:					p->cost[_index_NT] = 0;
    #####: 2940:					p->rule._index = q->rule._index;
        -: 2941:				}
    #####: 2942:				if (q->cost[_con1_NT] == 0) {
    #####: 2943:					p->cost[_con1_NT] = 0;
    #####: 2944:					p->rule._con1 = q->rule._con1;
        -: 2945:				}
    #####: 2946:				if (q->cost[_con2_NT] == 0) {
    #####: 2947:					p->cost[_con2_NT] = 0;
    #####: 2948:					p->rule._con2 = q->rule._con2;
        -: 2949:				}
    #####: 2950:				if (q->cost[_con3_NT] == 0) {
    #####: 2951:					p->cost[_con3_NT] = 0;
    #####: 2952:					p->rule._con3 = q->rule._con3;
        -: 2953:				}
    #####: 2954:				if (q->cost[_addr_NT] == 0) {
    #####: 2955:					p->cost[_addr_NT] = 0;
    #####: 2956:					p->rule._addr = q->rule._addr;
        -: 2957:				}
    #####: 2958:				if (q->cost[_mem_NT] == 0) {
    #####: 2959:					p->cost[_mem_NT] = 0;
    #####: 2960:					p->rule._mem = q->rule._mem;
        -: 2961:				}
    #####: 2962:				if (q->cost[_rc_NT] == 0) {
    #####: 2963:					p->cost[_rc_NT] = 0;
    #####: 2964:					p->rule._rc = q->rule._rc;
        -: 2965:				}
    #####: 2966:				if (q->cost[_mr_NT] == 0) {
    #####: 2967:					p->cost[_mr_NT] = 0;
    #####: 2968:					p->rule._mr = q->rule._mr;
        -: 2969:				}
    #####: 2970:				if (q->cost[_mrc0_NT] == 0) {
    #####: 2971:					p->cost[_mrc0_NT] = 0;
    #####: 2972:					p->rule._mrc0 = q->rule._mrc0;
        -: 2973:				}
    #####: 2974:				if (q->cost[_mrc1_NT] == 0) {
    #####: 2975:					p->cost[_mrc1_NT] = 0;
    #####: 2976:					p->rule._mrc1 = q->rule._mrc1;
        -: 2977:				}
    #####: 2978:				if (q->cost[_mrc3_NT] == 0) {
    #####: 2979:					p->cost[_mrc3_NT] = 0;
    #####: 2980:					p->rule._mrc3 = q->rule._mrc3;
        -: 2981:				}
    #####: 2982:				if (q->cost[_con5_NT] == 0) {
    #####: 2983:					p->cost[_con5_NT] = 0;
    #####: 2984:					p->rule._con5 = q->rule._con5;
        -: 2985:				}
    #####: 2986:				if (q->cost[_memf_NT] == 0) {
    #####: 2987:					p->cost[_memf_NT] = 0;
    #####: 2988:					p->rule._memf = q->rule._memf;
        -: 2989:				}
    #####: 2990:				if (q->cost[_flt_NT] == 0) {
    #####: 2991:					p->cost[_flt_NT] = 0;
    #####: 2992:					p->rule._flt = q->rule._flt;
        -: 2993:				}
    #####: 2994:				if (q->cost[_addrj_NT] == 0) {
    #####: 2995:					p->cost[_addrj_NT] = 0;
    #####: 2996:					p->rule._addrj = q->rule._addrj;
        -: 2997:				}
    #####: 2998:				if (q->cost[_cmpf_NT] == 0) {
    #####: 2999:					p->cost[_cmpf_NT] = 0;
    #####: 3000:					p->rule._cmpf = q->rule._cmpf;
        -: 3001:				}
        -: 3002:			}
    #####: 3003:			c = 0;
    #####: 3004:			if (c + 0 < p->cost[_reg_NT]) {
    #####: 3005:				p->cost[_reg_NT] = c + 0;
    #####: 3006:				p->rule._reg = 6;
    #####: 3007:				_closure_reg(a, c + 0);
        -: 3008:			}
        -: 3009:		}
        -: 3010:		/* mem: INDIRI4(addr) */
    #####: 3011:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + 0;
    #####: 3012:		if (c + 0 < p->cost[_mem_NT]) {
    #####: 3013:			p->cost[_mem_NT] = c + 0;
    #####: 3014:			p->rule._mem = 3;
    #####: 3015:			_closure_mem(a, c + 0);
        -: 3016:		}
    #####: 3017:		break;
        -: 3018:	case 4166: /* INDIRU4 */
    #####: 3019:		_label(LEFT_CHILD(a));
    #####: 3020:		if (	/* reg: INDIRU4(VREGP) */
        -: 3021:			LEFT_CHILD(a)->op == 711 /* VREGP */
        -: 3022:		) {
    #####: 3023:			if (mayrecalc(a)) {
    #####: 3024:				struct _state *q = a->syms[RX]->u.t.cse->x.state;
    #####: 3025:				if (q->cost[_stmt_NT] == 0) {
    #####: 3026:					p->cost[_stmt_NT] = 0;
    #####: 3027:					p->rule._stmt = q->rule._stmt;
        -: 3028:				}
    #####: 3029:				if (q->cost[_reg_NT] == 0) {
    #####: 3030:					p->cost[_reg_NT] = 0;
    #####: 3031:					p->rule._reg = q->rule._reg;
        -: 3032:				}
    #####: 3033:				if (q->cost[_con_NT] == 0) {
    #####: 3034:					p->cost[_con_NT] = 0;
    #####: 3035:					p->rule._con = q->rule._con;
        -: 3036:				}
    #####: 3037:				if (q->cost[_acon_NT] == 0) {
    #####: 3038:					p->cost[_acon_NT] = 0;
    #####: 3039:					p->rule._acon = q->rule._acon;
        -: 3040:				}
    #####: 3041:				if (q->cost[_base_NT] == 0) {
    #####: 3042:					p->cost[_base_NT] = 0;
    #####: 3043:					p->rule._base = q->rule._base;
        -: 3044:				}
    #####: 3045:				if (q->cost[_index_NT] == 0) {
    #####: 3046:					p->cost[_index_NT] = 0;
    #####: 3047:					p->rule._index = q->rule._index;
        -: 3048:				}
    #####: 3049:				if (q->cost[_con1_NT] == 0) {
    #####: 3050:					p->cost[_con1_NT] = 0;
    #####: 3051:					p->rule._con1 = q->rule._con1;
        -: 3052:				}
    #####: 3053:				if (q->cost[_con2_NT] == 0) {
    #####: 3054:					p->cost[_con2_NT] = 0;
    #####: 3055:					p->rule._con2 = q->rule._con2;
        -: 3056:				}
    #####: 3057:				if (q->cost[_con3_NT] == 0) {
    #####: 3058:					p->cost[_con3_NT] = 0;
    #####: 3059:					p->rule._con3 = q->rule._con3;
        -: 3060:				}
    #####: 3061:				if (q->cost[_addr_NT] == 0) {
    #####: 3062:					p->cost[_addr_NT] = 0;
    #####: 3063:					p->rule._addr = q->rule._addr;
        -: 3064:				}
    #####: 3065:				if (q->cost[_mem_NT] == 0) {
    #####: 3066:					p->cost[_mem_NT] = 0;
    #####: 3067:					p->rule._mem = q->rule._mem;
        -: 3068:				}
    #####: 3069:				if (q->cost[_rc_NT] == 0) {
    #####: 3070:					p->cost[_rc_NT] = 0;
    #####: 3071:					p->rule._rc = q->rule._rc;
        -: 3072:				}
    #####: 3073:				if (q->cost[_mr_NT] == 0) {
    #####: 3074:					p->cost[_mr_NT] = 0;
    #####: 3075:					p->rule._mr = q->rule._mr;
        -: 3076:				}
    #####: 3077:				if (q->cost[_mrc0_NT] == 0) {
    #####: 3078:					p->cost[_mrc0_NT] = 0;
    #####: 3079:					p->rule._mrc0 = q->rule._mrc0;
        -: 3080:				}
    #####: 3081:				if (q->cost[_mrc1_NT] == 0) {
    #####: 3082:					p->cost[_mrc1_NT] = 0;
    #####: 3083:					p->rule._mrc1 = q->rule._mrc1;
        -: 3084:				}
    #####: 3085:				if (q->cost[_mrc3_NT] == 0) {
    #####: 3086:					p->cost[_mrc3_NT] = 0;
    #####: 3087:					p->rule._mrc3 = q->rule._mrc3;
        -: 3088:				}
    #####: 3089:				if (q->cost[_con5_NT] == 0) {
    #####: 3090:					p->cost[_con5_NT] = 0;
    #####: 3091:					p->rule._con5 = q->rule._con5;
        -: 3092:				}
    #####: 3093:				if (q->cost[_memf_NT] == 0) {
    #####: 3094:					p->cost[_memf_NT] = 0;
    #####: 3095:					p->rule._memf = q->rule._memf;
        -: 3096:				}
    #####: 3097:				if (q->cost[_flt_NT] == 0) {
    #####: 3098:					p->cost[_flt_NT] = 0;
    #####: 3099:					p->rule._flt = q->rule._flt;
        -: 3100:				}
    #####: 3101:				if (q->cost[_addrj_NT] == 0) {
    #####: 3102:					p->cost[_addrj_NT] = 0;
    #####: 3103:					p->rule._addrj = q->rule._addrj;
        -: 3104:				}
    #####: 3105:				if (q->cost[_cmpf_NT] == 0) {
    #####: 3106:					p->cost[_cmpf_NT] = 0;
    #####: 3107:					p->rule._cmpf = q->rule._cmpf;
        -: 3108:				}
        -: 3109:			}
    #####: 3110:			c = 0;
    #####: 3111:			if (c + 0 < p->cost[_reg_NT]) {
    #####: 3112:				p->cost[_reg_NT] = c + 0;
    #####: 3113:				p->rule._reg = 8;
    #####: 3114:				_closure_reg(a, c + 0);
        -: 3115:			}
        -: 3116:		}
        -: 3117:		/* mem: INDIRU4(addr) */
    #####: 3118:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + 0;
    #####: 3119:		if (c + 0 < p->cost[_mem_NT]) {
    #####: 3120:			p->cost[_mem_NT] = c + 0;
    #####: 3121:			p->rule._mem = 6;
    #####: 3122:			_closure_mem(a, c + 0);
        -: 3123:		}
    #####: 3124:		break;
        -: 3125:	case 4167: /* INDIRP4 */
    #####: 3126:		_label(LEFT_CHILD(a));
    #####: 3127:		if (	/* reg: INDIRP4(VREGP) */
        -: 3128:			LEFT_CHILD(a)->op == 711 /* VREGP */
        -: 3129:		) {
    #####: 3130:			if (mayrecalc(a)) {
    #####: 3131:				struct _state *q = a->syms[RX]->u.t.cse->x.state;
    #####: 3132:				if (q->cost[_stmt_NT] == 0) {
    #####: 3133:					p->cost[_stmt_NT] = 0;
    #####: 3134:					p->rule._stmt = q->rule._stmt;
        -: 3135:				}
    #####: 3136:				if (q->cost[_reg_NT] == 0) {
    #####: 3137:					p->cost[_reg_NT] = 0;
    #####: 3138:					p->rule._reg = q->rule._reg;
        -: 3139:				}
    #####: 3140:				if (q->cost[_con_NT] == 0) {
    #####: 3141:					p->cost[_con_NT] = 0;
    #####: 3142:					p->rule._con = q->rule._con;
        -: 3143:				}
    #####: 3144:				if (q->cost[_acon_NT] == 0) {
    #####: 3145:					p->cost[_acon_NT] = 0;
    #####: 3146:					p->rule._acon = q->rule._acon;
        -: 3147:				}
    #####: 3148:				if (q->cost[_base_NT] == 0) {
    #####: 3149:					p->cost[_base_NT] = 0;
    #####: 3150:					p->rule._base = q->rule._base;
        -: 3151:				}
    #####: 3152:				if (q->cost[_index_NT] == 0) {
    #####: 3153:					p->cost[_index_NT] = 0;
    #####: 3154:					p->rule._index = q->rule._index;
        -: 3155:				}
    #####: 3156:				if (q->cost[_con1_NT] == 0) {
    #####: 3157:					p->cost[_con1_NT] = 0;
    #####: 3158:					p->rule._con1 = q->rule._con1;
        -: 3159:				}
    #####: 3160:				if (q->cost[_con2_NT] == 0) {
    #####: 3161:					p->cost[_con2_NT] = 0;
    #####: 3162:					p->rule._con2 = q->rule._con2;
        -: 3163:				}
    #####: 3164:				if (q->cost[_con3_NT] == 0) {
    #####: 3165:					p->cost[_con3_NT] = 0;
    #####: 3166:					p->rule._con3 = q->rule._con3;
        -: 3167:				}
    #####: 3168:				if (q->cost[_addr_NT] == 0) {
    #####: 3169:					p->cost[_addr_NT] = 0;
    #####: 3170:					p->rule._addr = q->rule._addr;
        -: 3171:				}
    #####: 3172:				if (q->cost[_mem_NT] == 0) {
    #####: 3173:					p->cost[_mem_NT] = 0;
    #####: 3174:					p->rule._mem = q->rule._mem;
        -: 3175:				}
    #####: 3176:				if (q->cost[_rc_NT] == 0) {
    #####: 3177:					p->cost[_rc_NT] = 0;
    #####: 3178:					p->rule._rc = q->rule._rc;
        -: 3179:				}
    #####: 3180:				if (q->cost[_mr_NT] == 0) {
    #####: 3181:					p->cost[_mr_NT] = 0;
    #####: 3182:					p->rule._mr = q->rule._mr;
        -: 3183:				}
    #####: 3184:				if (q->cost[_mrc0_NT] == 0) {
    #####: 3185:					p->cost[_mrc0_NT] = 0;
    #####: 3186:					p->rule._mrc0 = q->rule._mrc0;
        -: 3187:				}
    #####: 3188:				if (q->cost[_mrc1_NT] == 0) {
    #####: 3189:					p->cost[_mrc1_NT] = 0;
    #####: 3190:					p->rule._mrc1 = q->rule._mrc1;
        -: 3191:				}
    #####: 3192:				if (q->cost[_mrc3_NT] == 0) {
    #####: 3193:					p->cost[_mrc3_NT] = 0;
    #####: 3194:					p->rule._mrc3 = q->rule._mrc3;
        -: 3195:				}
    #####: 3196:				if (q->cost[_con5_NT] == 0) {
    #####: 3197:					p->cost[_con5_NT] = 0;
    #####: 3198:					p->rule._con5 = q->rule._con5;
        -: 3199:				}
    #####: 3200:				if (q->cost[_memf_NT] == 0) {
    #####: 3201:					p->cost[_memf_NT] = 0;
    #####: 3202:					p->rule._memf = q->rule._memf;
        -: 3203:				}
    #####: 3204:				if (q->cost[_flt_NT] == 0) {
    #####: 3205:					p->cost[_flt_NT] = 0;
    #####: 3206:					p->rule._flt = q->rule._flt;
        -: 3207:				}
    #####: 3208:				if (q->cost[_addrj_NT] == 0) {
    #####: 3209:					p->cost[_addrj_NT] = 0;
    #####: 3210:					p->rule._addrj = q->rule._addrj;
        -: 3211:				}
    #####: 3212:				if (q->cost[_cmpf_NT] == 0) {
    #####: 3213:					p->cost[_cmpf_NT] = 0;
    #####: 3214:					p->rule._cmpf = q->rule._cmpf;
        -: 3215:				}
        -: 3216:			}
    #####: 3217:			c = 0;
    #####: 3218:			if (c + 0 < p->cost[_reg_NT]) {
    #####: 3219:				p->cost[_reg_NT] = c + 0;
    #####: 3220:				p->rule._reg = 7;
    #####: 3221:				_closure_reg(a, c + 0);
        -: 3222:			}
        -: 3223:		}
        -: 3224:		/* mem: INDIRP4(addr) */
    #####: 3225:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + 0;
    #####: 3226:		if (c + 0 < p->cost[_mem_NT]) {
    #####: 3227:			p->cost[_mem_NT] = c + 0;
    #####: 3228:			p->rule._mem = 7;
    #####: 3229:			_closure_mem(a, c + 0);
        -: 3230:		}
    #####: 3231:		break;
        -: 3232:	case 4209: /* CVFF4 */
    #####: 3233:		_label(LEFT_CHILD(a));
        -: 3234:		/* reg: CVFF4(reg) */
    #####: 3235:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + 12;
    #####: 3236:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 3237:			p->cost[_reg_NT] = c + 0;
    #####: 3238:			p->rule._reg = 78;
    #####: 3239:			_closure_reg(a, c + 0);
        -: 3240:		}
    #####: 3241:		break;
        -: 3242:	case 4213: /* CVFI4 */
    #####: 3243:		_label(LEFT_CHILD(a));
        -: 3244:		/* reg: CVFI4(reg) */
    #####: 3245:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + 31;
    #####: 3246:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 3247:			p->cost[_reg_NT] = c + 0;
    #####: 3248:			p->rule._reg = 79;
    #####: 3249:			_closure_reg(a, c + 0);
        -: 3250:		}
    #####: 3251:		break;
        -: 3252:	case 4225: /* CVIF4 */
    #####: 3253:		_label(LEFT_CHILD(a));
        -: 3254:		/* reg: CVIF4(reg) */
    #####: 3255:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + 12;
    #####: 3256:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 3257:			p->cost[_reg_NT] = c + 0;
    #####: 3258:			p->rule._reg = 81;
    #####: 3259:			_closure_reg(a, c + 0);
        -: 3260:		}
    #####: 3261:		break;
        -: 3262:	case 4229: /* CVII4 */
    #####: 3263:		_label(LEFT_CHILD(a));
    #####: 3264:		if (	/* reg: CVII4(INDIRI1(addr)) */
        -: 3265:			LEFT_CHILD(a)->op == 1093 /* INDIRI1 */
        -: 3266:		) {
    #####: 3267:			c = ((struct _state *)(LEFT_CHILD(LEFT_CHILD(a))->x.state))->cost[_addr_NT] + 3;
    #####: 3268:			if (c + 0 < p->cost[_reg_NT]) {
    #####: 3269:				p->cost[_reg_NT] = c + 0;
    #####: 3270:				p->rule._reg = 54;
    #####: 3271:				_closure_reg(a, c + 0);
        -: 3272:			}
        -: 3273:		}
    #####: 3274:		if (	/* reg: CVII4(INDIRI2(addr)) */
        -: 3275:			LEFT_CHILD(a)->op == 2117 /* INDIRI2 */
        -: 3276:		) {
    #####: 3277:			c = ((struct _state *)(LEFT_CHILD(LEFT_CHILD(a))->x.state))->cost[_addr_NT] + 3;
    #####: 3278:			if (c + 0 < p->cost[_reg_NT]) {
    #####: 3279:				p->cost[_reg_NT] = c + 0;
    #####: 3280:				p->rule._reg = 55;
    #####: 3281:				_closure_reg(a, c + 0);
        -: 3282:			}
        -: 3283:		}
        -: 3284:		/* reg: CVII4(reg) */
    #####: 3285:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + 3;
    #####: 3286:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 3287:			p->cost[_reg_NT] = c + 0;
    #####: 3288:			p->rule._reg = 58;
    #####: 3289:			_closure_reg(a, c + 0);
        -: 3290:		}
    #####: 3291:		break;
        -: 3292:	case 4230: /* CVIU4 */
    #####: 3293:		_label(LEFT_CHILD(a));
        -: 3294:		/* reg: CVIU4(reg) */
    #####: 3295:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + 3;
    #####: 3296:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 3297:			p->cost[_reg_NT] = c + 0;
    #####: 3298:			p->rule._reg = 59;
    #####: 3299:			_closure_reg(a, c + 0);
        -: 3300:		}
    #####: 3301:		break;
        -: 3302:	case 4246: /* CVPU4 */
    #####: 3303:		_label(LEFT_CHILD(a));
        -: 3304:		/* reg: CVPU4(reg) */
    #####: 3305:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + (move(a));
    #####: 3306:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 3307:			p->cost[_reg_NT] = c + 0;
    #####: 3308:			p->rule._reg = 52;
    #####: 3309:			_closure_reg(a, c + 0);
        -: 3310:		}
    #####: 3311:		break;
        -: 3312:	case 4247: /* CVPP4 */
    #####: 3313:		break;
        -: 3314:	case 4277: /* CVUI4 */
    #####: 3315:		_label(LEFT_CHILD(a));
        -: 3316:		/* reg: CVUI4(reg) */
    #####: 3317:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + 3;
    #####: 3318:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 3319:			p->cost[_reg_NT] = c + 0;
    #####: 3320:			p->rule._reg = 60;
    #####: 3321:			_closure_reg(a, c + 0);
        -: 3322:		}
    #####: 3323:		break;
        -: 3324:	case 4278: /* CVUU4 */
    #####: 3325:		_label(LEFT_CHILD(a));
    #####: 3326:		if (	/* reg: CVUU4(INDIRU1(addr)) */
        -: 3327:			LEFT_CHILD(a)->op == 1094 /* INDIRU1 */
        -: 3328:		) {
    #####: 3329:			c = ((struct _state *)(LEFT_CHILD(LEFT_CHILD(a))->x.state))->cost[_addr_NT] + 3;
    #####: 3330:			if (c + 0 < p->cost[_reg_NT]) {
    #####: 3331:				p->cost[_reg_NT] = c + 0;
    #####: 3332:				p->rule._reg = 56;
    #####: 3333:				_closure_reg(a, c + 0);
        -: 3334:			}
        -: 3335:		}
    #####: 3336:		if (	/* reg: CVUU4(INDIRU2(addr)) */
        -: 3337:			LEFT_CHILD(a)->op == 2118 /* INDIRU2 */
        -: 3338:		) {
    #####: 3339:			c = ((struct _state *)(LEFT_CHILD(LEFT_CHILD(a))->x.state))->cost[_addr_NT] + 3;
    #####: 3340:			if (c + 0 < p->cost[_reg_NT]) {
    #####: 3341:				p->cost[_reg_NT] = c + 0;
    #####: 3342:				p->rule._reg = 57;
    #####: 3343:				_closure_reg(a, c + 0);
        -: 3344:			}
        -: 3345:		}
        -: 3346:		/* reg: CVUU4(reg) */
    #####: 3347:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + 3;
    #####: 3348:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 3349:			p->cost[_reg_NT] = c + 0;
    #####: 3350:			p->rule._reg = 61;
    #####: 3351:			_closure_reg(a, c + 0);
        -: 3352:		}
    #####: 3353:		break;
        -: 3354:	case 4279: /* CVUP4 */
    #####: 3355:		_label(LEFT_CHILD(a));
        -: 3356:		/* reg: CVUP4(reg) */
    #####: 3357:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + (move(a));
    #####: 3358:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 3359:			p->cost[_reg_NT] = c + 0;
    #####: 3360:			p->rule._reg = 53;
    #####: 3361:			_closure_reg(a, c + 0);
        -: 3362:		}
    #####: 3363:		break;
        -: 3364:	case 4289: /* NEGF4 */
    #####: 3365:		_label(LEFT_CHILD(a));
        -: 3366:		/* reg: NEGF4(reg) */
    #####: 3367:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
    #####: 3368:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 3369:			p->cost[_reg_NT] = c + 0;
    #####: 3370:			p->rule._reg = 68;
    #####: 3371:			_closure_reg(a, c + 0);
        -: 3372:		}
    #####: 3373:		break;
        -: 3374:	case 4293: /* NEGI4 */
    #####: 3375:		_label(LEFT_CHILD(a));
        -: 3376:		/* reg: NEGI4(reg) */
    #####: 3377:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + 2;
    #####: 3378:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 3379:			p->cost[_reg_NT] = c + 0;
    #####: 3380:			p->rule._reg = 36;
    #####: 3381:			_closure_reg(a, c + 0);
        -: 3382:		}
    #####: 3383:		break;
        -: 3384:	case 4305: /* CALLF4 */
    #####: 3385:		_label(LEFT_CHILD(a));
        -: 3386:		/* reg: CALLF4(addrj) */
    #####: 3387:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addrj_NT] + 0;
    #####: 3388:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 3389:			p->cost[_reg_NT] = c + 0;
    #####: 3390:			p->rule._reg = 86;
    #####: 3391:			_closure_reg(a, c + 0);
        -: 3392:		}
        -: 3393:		/* stmt: CALLF4(addrj) */
    #####: 3394:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addrj_NT] + 0;
    #####: 3395:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 3396:			p->cost[_stmt_NT] = c + 0;
    #####: 3397:			p->rule._stmt = 91;
        -: 3398:		}
    #####: 3399:		break;
        -: 3400:	case 4309: /* CALLI4 */
    #####: 3401:		_label(LEFT_CHILD(a));
        -: 3402:		/* reg: CALLI4(addrj) */
    #####: 3403:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addrj_NT] + 0;
    #####: 3404:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 3405:			p->cost[_reg_NT] = c + 0;
    #####: 3406:			p->rule._reg = 83;
    #####: 3407:			_closure_reg(a, c + 0);
        -: 3408:		}
    #####: 3409:		break;
        -: 3410:	case 4310: /* CALLU4 */
    #####: 3411:		_label(LEFT_CHILD(a));
        -: 3412:		/* reg: CALLU4(addrj) */
    #####: 3413:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addrj_NT] + 0;
    #####: 3414:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 3415:			p->cost[_reg_NT] = c + 0;
    #####: 3416:			p->rule._reg = 84;
    #####: 3417:			_closure_reg(a, c + 0);
        -: 3418:		}
    #####: 3419:		break;
        -: 3420:	case 4311: /* CALLP4 */
    #####: 3421:		_label(LEFT_CHILD(a));
        -: 3422:		/* reg: CALLP4(addrj) */
    #####: 3423:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addrj_NT] + 0;
    #####: 3424:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 3425:			p->cost[_reg_NT] = c + 0;
    #####: 3426:			p->rule._reg = 85;
    #####: 3427:			_closure_reg(a, c + 0);
        -: 3428:		}
    #####: 3429:		break;
        -: 3430:	case 4321: /* LOADF4 */
    #####: 3431:		break;
        -: 3432:	case 4325: /* LOADI4 */
    #####: 3433:		_label(LEFT_CHILD(a));
        -: 3434:		/* reg: LOADI4(reg) */
    #####: 3435:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + (move(a));
    #####: 3436:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 3437:			p->cost[_reg_NT] = c + 0;
    #####: 3438:			p->rule._reg = 17;
    #####: 3439:			_closure_reg(a, c + 0);
        -: 3440:		}
    #####: 3441:		break;
        -: 3442:	case 4326: /* LOADU4 */
    #####: 3443:		_label(LEFT_CHILD(a));
        -: 3444:		/* reg: LOADU4(reg) */
    #####: 3445:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + (move(a));
    #####: 3446:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 3447:			p->cost[_reg_NT] = c + 0;
    #####: 3448:			p->rule._reg = 20;
    #####: 3449:			_closure_reg(a, c + 0);
        -: 3450:		}
    #####: 3451:		break;
        -: 3452:	case 4327: /* LOADP4 */
    #####: 3453:		_label(LEFT_CHILD(a));
        -: 3454:		/* reg: LOADP4(reg) */
    #####: 3455:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + (move(a));
    #####: 3456:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 3457:			p->cost[_reg_NT] = c + 0;
    #####: 3458:			p->rule._reg = 21;
    #####: 3459:			_closure_reg(a, c + 0);
        -: 3460:		}
    #####: 3461:		break;
        -: 3462:	case 4337: /* RETF4 */
    #####: 3463:		_label(LEFT_CHILD(a));
        -: 3464:		/* stmt: RETF4(reg) */
    #####: 3465:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
    #####: 3466:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 3467:			p->cost[_stmt_NT] = c + 0;
    #####: 3468:			p->rule._stmt = 96;
        -: 3469:		}
    #####: 3470:		break;
        -: 3471:	case 4341: /* RETI4 */
    #####: 3472:		_label(LEFT_CHILD(a));
        -: 3473:		/* stmt: RETI4(reg) */
    #####: 3474:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
    #####: 3475:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 3476:			p->cost[_stmt_NT] = c + 0;
    #####: 3477:			p->rule._stmt = 93;
        -: 3478:		}
    #####: 3479:		break;
        -: 3480:	case 4342: /* RETU4 */
    #####: 3481:		_label(LEFT_CHILD(a));
        -: 3482:		/* stmt: RETU4(reg) */
    #####: 3483:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
    #####: 3484:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 3485:			p->cost[_stmt_NT] = c + 0;
    #####: 3486:			p->rule._stmt = 94;
        -: 3487:		}
    #####: 3488:		break;
        -: 3489:	case 4343: /* RETP4 */
    #####: 3490:		_label(LEFT_CHILD(a));
        -: 3491:		/* stmt: RETP4(reg) */
    #####: 3492:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
    #####: 3493:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 3494:			p->cost[_stmt_NT] = c + 0;
    #####: 3495:			p->rule._stmt = 95;
        -: 3496:		}
    #####: 3497:		break;
        -: 3498:	case 4359: /* ADDRGP4 */
        -: 3499:		/* acon: ADDRGP4 */
    #####: 3500:		if (0 + 0 < p->cost[_acon_NT]) {
    #####: 3501:			p->cost[_acon_NT] = 0 + 0;
    #####: 3502:			p->rule._acon = 1;
        -: 3503:		}
        -: 3504:		/* base: ADDRGP4 */
    #####: 3505:		if (0 + 0 < p->cost[_base_NT]) {
    #####: 3506:			p->cost[_base_NT] = 0 + 0;
    #####: 3507:			p->rule._base = 1;
    #####: 3508:			_closure_base(a, 0 + 0);
        -: 3509:		}
        -: 3510:		/* addrj: ADDRGP4 */
    #####: 3511:		if (0 + 0 < p->cost[_addrj_NT]) {
    #####: 3512:			p->cost[_addrj_NT] = 0 + 0;
    #####: 3513:			p->rule._addrj = 1;
        -: 3514:		}
    #####: 3515:		break;
        -: 3516:	case 4375: /* ADDRFP4 */
        -: 3517:		/* base: ADDRFP4 */
    #####: 3518:		if (0 + 0 < p->cost[_base_NT]) {
    #####: 3519:			p->cost[_base_NT] = 0 + 0;
    #####: 3520:			p->rule._base = 6;
    #####: 3521:			_closure_base(a, 0 + 0);
        -: 3522:		}
    #####: 3523:		break;
        -: 3524:	case 4391: /* ADDRLP4 */
        -: 3525:		/* base: ADDRLP4 */
    #####: 3526:		if (0 + 0 < p->cost[_base_NT]) {
    #####: 3527:			p->cost[_base_NT] = 0 + 0;
    #####: 3528:			p->rule._base = 7;
    #####: 3529:			_closure_base(a, 0 + 0);
        -: 3530:		}
    #####: 3531:		break;
        -: 3532:	case 4401: /* ADDF4 */
    #####: 3533:		_label(LEFT_CHILD(a));
    #####: 3534:		_label(RIGHT_CHILD(a));
        -: 3535:		/* reg: ADDF4(reg,flt) */
    #####: 3536:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_flt_NT] + 0;
    #####: 3537:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 3538:			p->cost[_reg_NT] = c + 0;
    #####: 3539:			p->rule._reg = 70;
    #####: 3540:			_closure_reg(a, c + 0);
        -: 3541:		}
    #####: 3542:		break;
        -: 3543:	case 4405: /* ADDI4 */
    #####: 3544:		_label(LEFT_CHILD(a));
    #####: 3545:		_label(RIGHT_CHILD(a));
        -: 3546:		/* base: ADDI4(reg,acon) */
    #####: 3547:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_acon_NT] + 0;
    #####: 3548:		if (c + 0 < p->cost[_base_NT]) {
    #####: 3549:			p->cost[_base_NT] = c + 0;
    #####: 3550:			p->rule._base = 3;
    #####: 3551:			_closure_base(a, c + 0);
        -: 3552:		}
        -: 3553:		/* addr: ADDI4(index,base) */
    #####: 3554:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_index_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_base_NT] + 0;
    #####: 3555:		if (c + 0 < p->cost[_addr_NT]) {
    #####: 3556:			p->cost[_addr_NT] = c + 0;
    #####: 3557:			p->rule._addr = 2;
    #####: 3558:			_closure_addr(a, c + 0);
        -: 3559:		}
        -: 3560:		/* reg: ADDI4(reg,mrc1) */
    #####: 3561:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_mrc1_NT] + 1;
    #####: 3562:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 3563:			p->cost[_reg_NT] = c + 0;
    #####: 3564:			p->rule._reg = 22;
    #####: 3565:			_closure_reg(a, c + 0);
        -: 3566:		}
    #####: 3567:		break;
        -: 3568:	case 4406: /* ADDU4 */
    #####: 3569:		_label(LEFT_CHILD(a));
    #####: 3570:		_label(RIGHT_CHILD(a));
        -: 3571:		/* base: ADDU4(reg,acon) */
    #####: 3572:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_acon_NT] + 0;
    #####: 3573:		if (c + 0 < p->cost[_base_NT]) {
    #####: 3574:			p->cost[_base_NT] = c + 0;
    #####: 3575:			p->rule._base = 5;
    #####: 3576:			_closure_base(a, c + 0);
        -: 3577:		}
        -: 3578:		/* addr: ADDU4(index,base) */
    #####: 3579:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_index_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_base_NT] + 0;
    #####: 3580:		if (c + 0 < p->cost[_addr_NT]) {
    #####: 3581:			p->cost[_addr_NT] = c + 0;
    #####: 3582:			p->rule._addr = 4;
    #####: 3583:			_closure_addr(a, c + 0);
        -: 3584:		}
        -: 3585:		/* reg: ADDU4(reg,mrc1) */
    #####: 3586:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_mrc1_NT] + 1;
    #####: 3587:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 3588:			p->cost[_reg_NT] = c + 0;
    #####: 3589:			p->rule._reg = 24;
    #####: 3590:			_closure_reg(a, c + 0);
        -: 3591:		}
    #####: 3592:		break;
        -: 3593:	case 4407: /* ADDP4 */
    #####: 3594:		_label(LEFT_CHILD(a));
    #####: 3595:		_label(RIGHT_CHILD(a));
        -: 3596:		/* base: ADDP4(reg,acon) */
    #####: 3597:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_acon_NT] + 0;
    #####: 3598:		if (c + 0 < p->cost[_base_NT]) {
    #####: 3599:			p->cost[_base_NT] = c + 0;
    #####: 3600:			p->rule._base = 4;
    #####: 3601:			_closure_base(a, c + 0);
        -: 3602:		}
        -: 3603:		/* addr: ADDP4(index,base) */
    #####: 3604:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_index_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_base_NT] + 0;
    #####: 3605:		if (c + 0 < p->cost[_addr_NT]) {
    #####: 3606:			p->cost[_addr_NT] = c + 0;
    #####: 3607:			p->rule._addr = 3;
    #####: 3608:			_closure_addr(a, c + 0);
        -: 3609:		}
        -: 3610:		/* reg: ADDP4(reg,mrc1) */
    #####: 3611:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_mrc1_NT] + 1;
    #####: 3612:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 3613:			p->cost[_reg_NT] = c + 0;
    #####: 3614:			p->rule._reg = 23;
    #####: 3615:			_closure_reg(a, c + 0);
        -: 3616:		}
    #####: 3617:		break;
        -: 3618:	case 4417: /* SUBF4 */
    #####: 3619:		_label(LEFT_CHILD(a));
    #####: 3620:		_label(RIGHT_CHILD(a));
        -: 3621:		/* reg: SUBF4(reg,flt) */
    #####: 3622:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_flt_NT] + 0;
    #####: 3623:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 3624:			p->cost[_reg_NT] = c + 0;
    #####: 3625:			p->rule._reg = 76;
    #####: 3626:			_closure_reg(a, c + 0);
        -: 3627:		}
    #####: 3628:		break;
        -: 3629:	case 4421: /* SUBI4 */
    #####: 3630:		_label(LEFT_CHILD(a));
    #####: 3631:		_label(RIGHT_CHILD(a));
        -: 3632:		/* reg: SUBI4(reg,mrc1) */
    #####: 3633:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_mrc1_NT] + 1;
    #####: 3634:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 3635:			p->cost[_reg_NT] = c + 0;
    #####: 3636:			p->rule._reg = 25;
    #####: 3637:			_closure_reg(a, c + 0);
        -: 3638:		}
    #####: 3639:		break;
        -: 3640:	case 4422: /* SUBU4 */
    #####: 3641:		_label(LEFT_CHILD(a));
    #####: 3642:		_label(RIGHT_CHILD(a));
        -: 3643:		/* reg: SUBU4(reg,mrc1) */
    #####: 3644:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_mrc1_NT] + 1;
    #####: 3645:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 3646:			p->cost[_reg_NT] = c + 0;
    #####: 3647:			p->rule._reg = 27;
    #####: 3648:			_closure_reg(a, c + 0);
        -: 3649:		}
    #####: 3650:		break;
        -: 3651:	case 4423: /* SUBP4 */
    #####: 3652:		_label(LEFT_CHILD(a));
    #####: 3653:		_label(RIGHT_CHILD(a));
        -: 3654:		/* reg: SUBP4(reg,mrc1) */
    #####: 3655:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_mrc1_NT] + 1;
    #####: 3656:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 3657:			p->cost[_reg_NT] = c + 0;
    #####: 3658:			p->rule._reg = 26;
    #####: 3659:			_closure_reg(a, c + 0);
        -: 3660:		}
    #####: 3661:		break;
        -: 3662:	case 4437: /* LSHI4 */
    #####: 3663:		_label(LEFT_CHILD(a));
    #####: 3664:		_label(RIGHT_CHILD(a));
        -: 3665:		/* index: LSHI4(reg,con1) */
    #####: 3666:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_con1_NT] + 0;
    #####: 3667:		if (c + 0 < p->cost[_index_NT]) {
    #####: 3668:			p->cost[_index_NT] = c + 0;
    #####: 3669:			p->rule._index = 2;
    #####: 3670:			_closure_index(a, c + 0);
        -: 3671:		}
        -: 3672:		/* index: LSHI4(reg,con2) */
    #####: 3673:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_con2_NT] + 0;
    #####: 3674:		if (c + 0 < p->cost[_index_NT]) {
    #####: 3675:			p->cost[_index_NT] = c + 0;
    #####: 3676:			p->rule._index = 3;
    #####: 3677:			_closure_index(a, c + 0);
        -: 3678:		}
        -: 3679:		/* index: LSHI4(reg,con3) */
    #####: 3680:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_con3_NT] + 0;
    #####: 3681:		if (c + 0 < p->cost[_index_NT]) {
    #####: 3682:			p->cost[_index_NT] = c + 0;
    #####: 3683:			p->rule._index = 4;
    #####: 3684:			_closure_index(a, c + 0);
        -: 3685:		}
        -: 3686:		/* reg: LSHI4(reg,con5) */
    #####: 3687:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_con5_NT] + 2;
    #####: 3688:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 3689:			p->cost[_reg_NT] = c + 0;
    #####: 3690:			p->rule._reg = 37;
    #####: 3691:			_closure_reg(a, c + 0);
        -: 3692:		}
        -: 3693:		/* reg: LSHI4(reg,reg) */
    #####: 3694:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_reg_NT] + 3;
    #####: 3695:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 3696:			p->cost[_reg_NT] = c + 0;
    #####: 3697:			p->rule._reg = 41;
    #####: 3698:			_closure_reg(a, c + 0);
        -: 3699:		}
    #####: 3700:		break;
        -: 3701:	case 4438: /* LSHU4 */
    #####: 3702:		_label(LEFT_CHILD(a));
    #####: 3703:		_label(RIGHT_CHILD(a));
        -: 3704:		/* index: LSHU4(reg,con1) */
    #####: 3705:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_con1_NT] + 0;
    #####: 3706:		if (c + 0 < p->cost[_index_NT]) {
    #####: 3707:			p->cost[_index_NT] = c + 0;
    #####: 3708:			p->rule._index = 5;
    #####: 3709:			_closure_index(a, c + 0);
        -: 3710:		}
        -: 3711:		/* index: LSHU4(reg,con2) */
    #####: 3712:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_con2_NT] + 0;
    #####: 3713:		if (c + 0 < p->cost[_index_NT]) {
    #####: 3714:			p->cost[_index_NT] = c + 0;
    #####: 3715:			p->rule._index = 6;
    #####: 3716:			_closure_index(a, c + 0);
        -: 3717:		}
        -: 3718:		/* index: LSHU4(reg,con3) */
    #####: 3719:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_con3_NT] + 0;
    #####: 3720:		if (c + 0 < p->cost[_index_NT]) {
    #####: 3721:			p->cost[_index_NT] = c + 0;
    #####: 3722:			p->rule._index = 7;
    #####: 3723:			_closure_index(a, c + 0);
        -: 3724:		}
        -: 3725:		/* reg: LSHU4(reg,con5) */
    #####: 3726:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_con5_NT] + 2;
    #####: 3727:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 3728:			p->cost[_reg_NT] = c + 0;
    #####: 3729:			p->rule._reg = 38;
    #####: 3730:			_closure_reg(a, c + 0);
        -: 3731:		}
        -: 3732:		/* reg: LSHU4(reg,reg) */
    #####: 3733:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_reg_NT] + 2;
    #####: 3734:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 3735:			p->cost[_reg_NT] = c + 0;
    #####: 3736:			p->rule._reg = 42;
    #####: 3737:			_closure_reg(a, c + 0);
        -: 3738:		}
    #####: 3739:		break;
        -: 3740:	case 4453: /* MODI4 */
    #####: 3741:		_label(LEFT_CHILD(a));
    #####: 3742:		_label(RIGHT_CHILD(a));
        -: 3743:		/* reg: MODI4(reg,reg) */
    #####: 3744:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
    #####: 3745:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 3746:			p->cost[_reg_NT] = c + 0;
    #####: 3747:			p->rule._reg = 51;
    #####: 3748:			_closure_reg(a, c + 0);
        -: 3749:		}
    #####: 3750:		break;
        -: 3751:	case 4454: /* MODU4 */
    #####: 3752:		_label(LEFT_CHILD(a));
    #####: 3753:		_label(RIGHT_CHILD(a));
        -: 3754:		/* reg: MODU4(reg,reg) */
    #####: 3755:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
    #####: 3756:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 3757:			p->cost[_reg_NT] = c + 0;
    #####: 3758:			p->rule._reg = 49;
    #####: 3759:			_closure_reg(a, c + 0);
        -: 3760:		}
    #####: 3761:		break;
        -: 3762:	case 4469: /* RSHI4 */
    #####: 3763:		_label(LEFT_CHILD(a));
    #####: 3764:		_label(RIGHT_CHILD(a));
        -: 3765:		/* reg: RSHI4(reg,con5) */
    #####: 3766:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_con5_NT] + 2;
    #####: 3767:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 3768:			p->cost[_reg_NT] = c + 0;
    #####: 3769:			p->rule._reg = 39;
    #####: 3770:			_closure_reg(a, c + 0);
        -: 3771:		}
        -: 3772:		/* reg: RSHI4(reg,reg) */
    #####: 3773:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_reg_NT] + 2;
    #####: 3774:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 3775:			p->cost[_reg_NT] = c + 0;
    #####: 3776:			p->rule._reg = 43;
    #####: 3777:			_closure_reg(a, c + 0);
        -: 3778:		}
    #####: 3779:		break;
        -: 3780:	case 4470: /* RSHU4 */
    #####: 3781:		_label(LEFT_CHILD(a));
    #####: 3782:		_label(RIGHT_CHILD(a));
        -: 3783:		/* reg: RSHU4(reg,con5) */
    #####: 3784:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_con5_NT] + 2;
    #####: 3785:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 3786:			p->cost[_reg_NT] = c + 0;
    #####: 3787:			p->rule._reg = 40;
    #####: 3788:			_closure_reg(a, c + 0);
        -: 3789:		}
        -: 3790:		/* reg: RSHU4(reg,reg) */
    #####: 3791:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_reg_NT] + 2;
    #####: 3792:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 3793:			p->cost[_reg_NT] = c + 0;
    #####: 3794:			p->rule._reg = 44;
    #####: 3795:			_closure_reg(a, c + 0);
        -: 3796:		}
    #####: 3797:		break;
        -: 3798:	case 4485: /* BANDI4 */
    #####: 3799:		_label(LEFT_CHILD(a));
    #####: 3800:		_label(RIGHT_CHILD(a));
        -: 3801:		/* reg: BANDI4(reg,mrc1) */
    #####: 3802:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_mrc1_NT] + 1;
    #####: 3803:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 3804:			p->cost[_reg_NT] = c + 0;
    #####: 3805:			p->rule._reg = 28;
    #####: 3806:			_closure_reg(a, c + 0);
        -: 3807:		}
    #####: 3808:		break;
        -: 3809:	case 4486: /* BANDU4 */
    #####: 3810:		_label(LEFT_CHILD(a));
    #####: 3811:		_label(RIGHT_CHILD(a));
        -: 3812:		/* reg: BANDU4(reg,mrc1) */
    #####: 3813:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_mrc1_NT] + 1;
    #####: 3814:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 3815:			p->cost[_reg_NT] = c + 0;
    #####: 3816:			p->rule._reg = 31;
    #####: 3817:			_closure_reg(a, c + 0);
        -: 3818:		}
    #####: 3819:		break;
        -: 3820:	case 4501: /* BCOMI4 */
    #####: 3821:		_label(LEFT_CHILD(a));
        -: 3822:		/* reg: BCOMI4(reg) */
    #####: 3823:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + 2;
    #####: 3824:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 3825:			p->cost[_reg_NT] = c + 0;
    #####: 3826:			p->rule._reg = 34;
    #####: 3827:			_closure_reg(a, c + 0);
        -: 3828:		}
    #####: 3829:		break;
        -: 3830:	case 4502: /* BCOMU4 */
    #####: 3831:		_label(LEFT_CHILD(a));
        -: 3832:		/* reg: BCOMU4(reg) */
    #####: 3833:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + 2;
    #####: 3834:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 3835:			p->cost[_reg_NT] = c + 0;
    #####: 3836:			p->rule._reg = 35;
    #####: 3837:			_closure_reg(a, c + 0);
        -: 3838:		}
    #####: 3839:		break;
        -: 3840:	case 4517: /* BORI4 */
    #####: 3841:		_label(LEFT_CHILD(a));
    #####: 3842:		_label(RIGHT_CHILD(a));
        -: 3843:		/* reg: BORI4(reg,mrc1) */
    #####: 3844:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_mrc1_NT] + 1;
    #####: 3845:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 3846:			p->cost[_reg_NT] = c + 0;
    #####: 3847:			p->rule._reg = 29;
    #####: 3848:			_closure_reg(a, c + 0);
        -: 3849:		}
    #####: 3850:		break;
        -: 3851:	case 4518: /* BORU4 */
    #####: 3852:		_label(LEFT_CHILD(a));
    #####: 3853:		_label(RIGHT_CHILD(a));
        -: 3854:		/* reg: BORU4(reg,mrc1) */
    #####: 3855:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_mrc1_NT] + 1;
    #####: 3856:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 3857:			p->cost[_reg_NT] = c + 0;
    #####: 3858:			p->rule._reg = 32;
    #####: 3859:			_closure_reg(a, c + 0);
        -: 3860:		}
    #####: 3861:		break;
        -: 3862:	case 4533: /* BXORI4 */
    #####: 3863:		_label(LEFT_CHILD(a));
    #####: 3864:		_label(RIGHT_CHILD(a));
        -: 3865:		/* reg: BXORI4(reg,mrc1) */
    #####: 3866:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_mrc1_NT] + 1;
    #####: 3867:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 3868:			p->cost[_reg_NT] = c + 0;
    #####: 3869:			p->rule._reg = 30;
    #####: 3870:			_closure_reg(a, c + 0);
        -: 3871:		}
    #####: 3872:		break;
        -: 3873:	case 4534: /* BXORU4 */
    #####: 3874:		_label(LEFT_CHILD(a));
    #####: 3875:		_label(RIGHT_CHILD(a));
        -: 3876:		/* reg: BXORU4(reg,mrc1) */
    #####: 3877:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_mrc1_NT] + 1;
    #####: 3878:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 3879:			p->cost[_reg_NT] = c + 0;
    #####: 3880:			p->rule._reg = 33;
    #####: 3881:			_closure_reg(a, c + 0);
        -: 3882:		}
    #####: 3883:		break;
        -: 3884:	case 4545: /* DIVF4 */
    #####: 3885:		_label(LEFT_CHILD(a));
    #####: 3886:		_label(RIGHT_CHILD(a));
        -: 3887:		/* reg: DIVF4(reg,flt) */
    #####: 3888:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_flt_NT] + 0;
    #####: 3889:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 3890:			p->cost[_reg_NT] = c + 0;
    #####: 3891:			p->rule._reg = 72;
    #####: 3892:			_closure_reg(a, c + 0);
        -: 3893:		}
    #####: 3894:		break;
        -: 3895:	case 4549: /* DIVI4 */
    #####: 3896:		_label(LEFT_CHILD(a));
    #####: 3897:		_label(RIGHT_CHILD(a));
        -: 3898:		/* reg: DIVI4(reg,reg) */
    #####: 3899:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
    #####: 3900:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 3901:			p->cost[_reg_NT] = c + 0;
    #####: 3902:			p->rule._reg = 50;
    #####: 3903:			_closure_reg(a, c + 0);
        -: 3904:		}
    #####: 3905:		break;
        -: 3906:	case 4550: /* DIVU4 */
    #####: 3907:		_label(LEFT_CHILD(a));
    #####: 3908:		_label(RIGHT_CHILD(a));
        -: 3909:		/* reg: DIVU4(reg,reg) */
    #####: 3910:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
    #####: 3911:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 3912:			p->cost[_reg_NT] = c + 0;
    #####: 3913:			p->rule._reg = 48;
    #####: 3914:			_closure_reg(a, c + 0);
        -: 3915:		}
    #####: 3916:		break;
        -: 3917:	case 4561: /* MULF4 */
    #####: 3918:		_label(LEFT_CHILD(a));
    #####: 3919:		_label(RIGHT_CHILD(a));
        -: 3920:		/* reg: MULF4(reg,flt) */
    #####: 3921:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_flt_NT] + 0;
    #####: 3922:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 3923:			p->cost[_reg_NT] = c + 0;
    #####: 3924:			p->rule._reg = 74;
    #####: 3925:			_closure_reg(a, c + 0);
        -: 3926:		}
    #####: 3927:		break;
        -: 3928:	case 4565: /* MULI4 */
    #####: 3929:		_label(LEFT_CHILD(a));
    #####: 3930:		_label(RIGHT_CHILD(a));
        -: 3931:		/* reg: MULI4(reg,mrc3) */
    #####: 3932:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_mrc3_NT] + 14;
    #####: 3933:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 3934:			p->cost[_reg_NT] = c + 0;
    #####: 3935:			p->rule._reg = 45;
    #####: 3936:			_closure_reg(a, c + 0);
        -: 3937:		}
        -: 3938:		/* reg: MULI4(con,mr) */
    #####: 3939:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_con_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_mr_NT] + 13;
    #####: 3940:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 3941:			p->cost[_reg_NT] = c + 0;
    #####: 3942:			p->rule._reg = 46;
    #####: 3943:			_closure_reg(a, c + 0);
        -: 3944:		}
    #####: 3945:		break;
        -: 3946:	case 4566: /* MULU4 */
    #####: 3947:		_label(LEFT_CHILD(a));
    #####: 3948:		_label(RIGHT_CHILD(a));
        -: 3949:		/* reg: MULU4(reg,mr) */
    #####: 3950:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_mr_NT] + 13;
    #####: 3951:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 3952:			p->cost[_reg_NT] = c + 0;
    #####: 3953:			p->rule._reg = 47;
    #####: 3954:			_closure_reg(a, c + 0);
        -: 3955:		}
    #####: 3956:		break;
        -: 3957:	case 4577: /* EQF4 */
    #####: 3958:		_label(LEFT_CHILD(a));
    #####: 3959:		_label(RIGHT_CHILD(a));
        -: 3960:		/* stmt: EQF4(cmpf,reg) */
    #####: 3961:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_cmpf_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
    #####: 3962:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 3963:			p->cost[_stmt_NT] = c + 0;
    #####: 3964:			p->rule._stmt = 84;
        -: 3965:		}
    #####: 3966:		break;
        -: 3967:	case 4581: /* EQI4 */
    #####: 3968:		_label(LEFT_CHILD(a));
    #####: 3969:		_label(RIGHT_CHILD(a));
        -: 3970:		/* stmt: EQI4(mem,rc) */
    #####: 3971:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_mem_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_rc_NT] + 5;
    #####: 3972:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 3973:			p->cost[_stmt_NT] = c + 0;
    #####: 3974:			p->rule._stmt = 56;
        -: 3975:		}
        -: 3976:		/* stmt: EQI4(reg,mrc1) */
    #####: 3977:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_mrc1_NT] + 4;
    #####: 3978:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 3979:			p->cost[_stmt_NT] = c + 0;
    #####: 3980:			p->rule._stmt = 66;
        -: 3981:		}
    #####: 3982:		break;
        -: 3983:	case 4582: /* EQU4 */
    #####: 3984:		_label(LEFT_CHILD(a));
    #####: 3985:		_label(RIGHT_CHILD(a));
        -: 3986:		/* stmt: EQU4(reg,mrc1) */
    #####: 3987:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_mrc1_NT] + 4;
    #####: 3988:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 3989:			p->cost[_stmt_NT] = c + 0;
    #####: 3990:			p->rule._stmt = 72;
        -: 3991:		}
    #####: 3992:		break;
        -: 3993:	case 4593: /* GEF4 */
    #####: 3994:		_label(LEFT_CHILD(a));
    #####: 3995:		_label(RIGHT_CHILD(a));
        -: 3996:		/* stmt: GEF4(cmpf,reg) */
    #####: 3997:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_cmpf_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
    #####: 3998:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 3999:			p->cost[_stmt_NT] = c + 0;
    #####: 4000:			p->rule._stmt = 85;
        -: 4001:		}
    #####: 4002:		break;
        -: 4003:	case 4597: /* GEI4 */
    #####: 4004:		_label(LEFT_CHILD(a));
    #####: 4005:		_label(RIGHT_CHILD(a));
        -: 4006:		/* stmt: GEI4(mem,rc) */
    #####: 4007:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_mem_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_rc_NT] + 5;
    #####: 4008:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 4009:			p->cost[_stmt_NT] = c + 0;
    #####: 4010:			p->rule._stmt = 57;
        -: 4011:		}
        -: 4012:		/* stmt: GEI4(reg,mrc1) */
    #####: 4013:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_mrc1_NT] + 4;
    #####: 4014:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 4015:			p->cost[_stmt_NT] = c + 0;
    #####: 4016:			p->rule._stmt = 67;
        -: 4017:		}
    #####: 4018:		break;
        -: 4019:	case 4598: /* GEU4 */
    #####: 4020:		_label(LEFT_CHILD(a));
    #####: 4021:		_label(RIGHT_CHILD(a));
        -: 4022:		/* stmt: GEU4(mem,rc) */
    #####: 4023:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_mem_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_rc_NT] + 5;
    #####: 4024:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 4025:			p->cost[_stmt_NT] = c + 0;
    #####: 4026:			p->rule._stmt = 62;
        -: 4027:		}
        -: 4028:		/* stmt: GEU4(reg,mrc1) */
    #####: 4029:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_mrc1_NT] + 4;
    #####: 4030:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 4031:			p->cost[_stmt_NT] = c + 0;
    #####: 4032:			p->rule._stmt = 73;
        -: 4033:		}
    #####: 4034:		break;
        -: 4035:	case 4609: /* GTF4 */
    #####: 4036:		_label(LEFT_CHILD(a));
    #####: 4037:		_label(RIGHT_CHILD(a));
        -: 4038:		/* stmt: GTF4(cmpf,reg) */
    #####: 4039:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_cmpf_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
    #####: 4040:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 4041:			p->cost[_stmt_NT] = c + 0;
    #####: 4042:			p->rule._stmt = 86;
        -: 4043:		}
    #####: 4044:		break;
        -: 4045:	case 4613: /* GTI4 */
    #####: 4046:		_label(LEFT_CHILD(a));
    #####: 4047:		_label(RIGHT_CHILD(a));
        -: 4048:		/* stmt: GTI4(mem,rc) */
    #####: 4049:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_mem_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_rc_NT] + 5;
    #####: 4050:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 4051:			p->cost[_stmt_NT] = c + 0;
    #####: 4052:			p->rule._stmt = 58;
        -: 4053:		}
        -: 4054:		/* stmt: GTI4(reg,mrc1) */
    #####: 4055:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_mrc1_NT] + 4;
    #####: 4056:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 4057:			p->cost[_stmt_NT] = c + 0;
    #####: 4058:			p->rule._stmt = 68;
        -: 4059:		}
    #####: 4060:		break;
        -: 4061:	case 4614: /* GTU4 */
    #####: 4062:		_label(LEFT_CHILD(a));
    #####: 4063:		_label(RIGHT_CHILD(a));
        -: 4064:		/* stmt: GTU4(mem,rc) */
    #####: 4065:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_mem_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_rc_NT] + 5;
    #####: 4066:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 4067:			p->cost[_stmt_NT] = c + 0;
    #####: 4068:			p->rule._stmt = 63;
        -: 4069:		}
        -: 4070:		/* stmt: GTU4(reg,mrc1) */
    #####: 4071:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_mrc1_NT] + 4;
    #####: 4072:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 4073:			p->cost[_stmt_NT] = c + 0;
    #####: 4074:			p->rule._stmt = 74;
        -: 4075:		}
    #####: 4076:		break;
        -: 4077:	case 4625: /* LEF4 */
    #####: 4078:		_label(LEFT_CHILD(a));
    #####: 4079:		_label(RIGHT_CHILD(a));
        -: 4080:		/* stmt: LEF4(cmpf,reg) */
    #####: 4081:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_cmpf_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
    #####: 4082:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 4083:			p->cost[_stmt_NT] = c + 0;
    #####: 4084:			p->rule._stmt = 87;
        -: 4085:		}
    #####: 4086:		break;
        -: 4087:	case 4629: /* LEI4 */
    #####: 4088:		_label(LEFT_CHILD(a));
    #####: 4089:		_label(RIGHT_CHILD(a));
        -: 4090:		/* stmt: LEI4(mem,rc) */
    #####: 4091:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_mem_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_rc_NT] + 5;
    #####: 4092:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 4093:			p->cost[_stmt_NT] = c + 0;
    #####: 4094:			p->rule._stmt = 59;
        -: 4095:		}
        -: 4096:		/* stmt: LEI4(reg,mrc1) */
    #####: 4097:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_mrc1_NT] + 4;
    #####: 4098:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 4099:			p->cost[_stmt_NT] = c + 0;
    #####: 4100:			p->rule._stmt = 69;
        -: 4101:		}
    #####: 4102:		break;
        -: 4103:	case 4630: /* LEU4 */
    #####: 4104:		_label(LEFT_CHILD(a));
    #####: 4105:		_label(RIGHT_CHILD(a));
        -: 4106:		/* stmt: LEU4(mem,rc) */
    #####: 4107:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_mem_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_rc_NT] + 5;
    #####: 4108:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 4109:			p->cost[_stmt_NT] = c + 0;
    #####: 4110:			p->rule._stmt = 64;
        -: 4111:		}
        -: 4112:		/* stmt: LEU4(reg,mrc1) */
    #####: 4113:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_mrc1_NT] + 4;
    #####: 4114:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 4115:			p->cost[_stmt_NT] = c + 0;
    #####: 4116:			p->rule._stmt = 75;
        -: 4117:		}
    #####: 4118:		break;
        -: 4119:	case 4641: /* LTF4 */
    #####: 4120:		_label(LEFT_CHILD(a));
    #####: 4121:		_label(RIGHT_CHILD(a));
        -: 4122:		/* stmt: LTF4(cmpf,reg) */
    #####: 4123:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_cmpf_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
    #####: 4124:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 4125:			p->cost[_stmt_NT] = c + 0;
    #####: 4126:			p->rule._stmt = 88;
        -: 4127:		}
    #####: 4128:		break;
        -: 4129:	case 4645: /* LTI4 */
    #####: 4130:		_label(LEFT_CHILD(a));
    #####: 4131:		_label(RIGHT_CHILD(a));
        -: 4132:		/* stmt: LTI4(mem,rc) */
    #####: 4133:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_mem_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_rc_NT] + 5;
    #####: 4134:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 4135:			p->cost[_stmt_NT] = c + 0;
    #####: 4136:			p->rule._stmt = 60;
        -: 4137:		}
        -: 4138:		/* stmt: LTI4(reg,mrc1) */
    #####: 4139:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_mrc1_NT] + 4;
    #####: 4140:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 4141:			p->cost[_stmt_NT] = c + 0;
    #####: 4142:			p->rule._stmt = 70;
        -: 4143:		}
    #####: 4144:		break;
        -: 4145:	case 4646: /* LTU4 */
    #####: 4146:		_label(LEFT_CHILD(a));
    #####: 4147:		_label(RIGHT_CHILD(a));
        -: 4148:		/* stmt: LTU4(mem,rc) */
    #####: 4149:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_mem_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_rc_NT] + 5;
    #####: 4150:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 4151:			p->cost[_stmt_NT] = c + 0;
    #####: 4152:			p->rule._stmt = 65;
        -: 4153:		}
        -: 4154:		/* stmt: LTU4(reg,mrc1) */
    #####: 4155:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_mrc1_NT] + 4;
    #####: 4156:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 4157:			p->cost[_stmt_NT] = c + 0;
    #####: 4158:			p->rule._stmt = 76;
        -: 4159:		}
    #####: 4160:		break;
        -: 4161:	case 4657: /* NEF4 */
    #####: 4162:		_label(LEFT_CHILD(a));
    #####: 4163:		_label(RIGHT_CHILD(a));
        -: 4164:		/* stmt: NEF4(cmpf,reg) */
    #####: 4165:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_cmpf_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
    #####: 4166:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 4167:			p->cost[_stmt_NT] = c + 0;
    #####: 4168:			p->rule._stmt = 89;
        -: 4169:		}
    #####: 4170:		break;
        -: 4171:	case 4661: /* NEI4 */
    #####: 4172:		_label(LEFT_CHILD(a));
    #####: 4173:		_label(RIGHT_CHILD(a));
        -: 4174:		/* stmt: NEI4(mem,rc) */
    #####: 4175:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_mem_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_rc_NT] + 5;
    #####: 4176:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 4177:			p->cost[_stmt_NT] = c + 0;
    #####: 4178:			p->rule._stmt = 61;
        -: 4179:		}
        -: 4180:		/* stmt: NEI4(reg,mrc1) */
    #####: 4181:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_mrc1_NT] + 4;
    #####: 4182:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 4183:			p->cost[_stmt_NT] = c + 0;
    #####: 4184:			p->rule._stmt = 71;
        -: 4185:		}
    #####: 4186:		break;
        -: 4187:	case 4662: /* NEU4 */
    #####: 4188:		_label(LEFT_CHILD(a));
    #####: 4189:		_label(RIGHT_CHILD(a));
        -: 4190:		/* stmt: NEU4(reg,mrc1) */
    #####: 4191:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_mrc1_NT] + 4;
    #####: 4192:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 4193:			p->cost[_stmt_NT] = c + 0;
    #####: 4194:			p->rule._stmt = 77;
        -: 4195:		}
    #####: 4196:		break;
        -: 4197:	case 8209: /* CNSTF8 */
    #####: 4198:		break;
        -: 4199:	case 8213: /* CNSTI8 */
        -: 4200:		/* con: CNSTI8 */
    #####: 4201:		if (0 + 0 < p->cost[_con_NT]) {
    #####: 4202:			p->cost[_con_NT] = 0 + 0;
    #####: 4203:			p->rule._con = 8;
    #####: 4204:			_closure_con(a, 0 + 0);
        -: 4205:		}
    #####: 4206:		break;
        -: 4207:	case 8214: /* CNSTU8 */
        -: 4208:		/* con: CNSTU8 */
    #####: 4209:		if (0 + 0 < p->cost[_con_NT]) {
    #####: 4210:			p->cost[_con_NT] = 0 + 0;
    #####: 4211:			p->rule._con = 9;
    #####: 4212:			_closure_con(a, 0 + 0);
        -: 4213:		}
    #####: 4214:		break;
        -: 4215:	case 8215: /* CNSTP8 */
        -: 4216:		/* con: CNSTP8 */
    #####: 4217:		if (0 + 0 < p->cost[_con_NT]) {
    #####: 4218:			p->cost[_con_NT] = 0 + 0;
    #####: 4219:			p->rule._con = 10;
    #####: 4220:			_closure_con(a, 0 + 0);
        -: 4221:		}
    #####: 4222:		break;
        -: 4223:	case 8225: /* ARGF8 */
    #####: 4224:		_label(LEFT_CHILD(a));
        -: 4225:		/* stmt: ARGF8(reg) */
    #####: 4226:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
    #####: 4227:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 4228:			p->cost[_stmt_NT] = c + 0;
    #####: 4229:			p->rule._stmt = 52;
        -: 4230:		}
    #####: 4231:		break;
        -: 4232:	case 8229: /* ARGI8 */
    #####: 4233:		break;
        -: 4234:	case 8230: /* ARGU8 */
    #####: 4235:		break;
        -: 4236:	case 8231: /* ARGP8 */
    #####: 4237:		break;
        -: 4238:	case 8241: /* ASGNF8 */
    #####: 4239:		_label(LEFT_CHILD(a));
    #####: 4240:		_label(RIGHT_CHILD(a));
    #####: 4241:		if (	/* stmt: ASGNF8(VREGP,reg) */
        -: 4242:			LEFT_CHILD(a)->op == 711 /* VREGP */
        -: 4243:		) {
    #####: 4244:			c = ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
    #####: 4245:			if (c + 0 < p->cost[_stmt_NT]) {
    #####: 4246:				p->cost[_stmt_NT] = c + 0;
    #####: 4247:				p->rule._stmt = 9;
        -: 4248:			}
        -: 4249:		}
        -: 4250:		/* stmt: ASGNF8(addr,reg) */
    #####: 4251:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_reg_NT] + 7;
    #####: 4252:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 4253:			p->cost[_stmt_NT] = c + 0;
    #####: 4254:			p->rule._stmt = 49;
        -: 4255:		}
    #####: 4256:		break;
        -: 4257:	case 8245: /* ASGNI8 */
    #####: 4258:		_label(LEFT_CHILD(a));
    #####: 4259:		_label(RIGHT_CHILD(a));
    #####: 4260:		if (	/* stmt: ASGNI8(VREGP,reg) */
        -: 4261:			LEFT_CHILD(a)->op == 711 /* VREGP */
        -: 4262:		) {
    #####: 4263:			c = ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
    #####: 4264:			if (c + 0 < p->cost[_stmt_NT]) {
    #####: 4265:				p->cost[_stmt_NT] = c + 0;
    #####: 4266:				p->rule._stmt = 10;
        -: 4267:			}
        -: 4268:		}
    #####: 4269:		break;
        -: 4270:	case 8246: /* ASGNU8 */
    #####: 4271:		_label(LEFT_CHILD(a));
    #####: 4272:		_label(RIGHT_CHILD(a));
    #####: 4273:		if (	/* stmt: ASGNU8(VREGP,reg) */
        -: 4274:			LEFT_CHILD(a)->op == 711 /* VREGP */
        -: 4275:		) {
    #####: 4276:			c = ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
    #####: 4277:			if (c + 0 < p->cost[_stmt_NT]) {
    #####: 4278:				p->cost[_stmt_NT] = c + 0;
    #####: 4279:				p->rule._stmt = 12;
        -: 4280:			}
        -: 4281:		}
    #####: 4282:		break;
        -: 4283:	case 8247: /* ASGNP8 */
    #####: 4284:		_label(LEFT_CHILD(a));
    #####: 4285:		_label(RIGHT_CHILD(a));
    #####: 4286:		if (	/* stmt: ASGNP8(VREGP,reg) */
        -: 4287:			LEFT_CHILD(a)->op == 711 /* VREGP */
        -: 4288:		) {
    #####: 4289:			c = ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
    #####: 4290:			if (c + 0 < p->cost[_stmt_NT]) {
    #####: 4291:				p->cost[_stmt_NT] = c + 0;
    #####: 4292:				p->rule._stmt = 11;
        -: 4293:			}
        -: 4294:		}
    #####: 4295:		break;
        -: 4296:	case 8257: /* INDIRF8 */
    #####: 4297:		_label(LEFT_CHILD(a));
    #####: 4298:		if (	/* reg: INDIRF8(VREGP) */
        -: 4299:			LEFT_CHILD(a)->op == 711 /* VREGP */
        -: 4300:		) {
    #####: 4301:			if (mayrecalc(a)) {
    #####: 4302:				struct _state *q = a->syms[RX]->u.t.cse->x.state;
    #####: 4303:				if (q->cost[_stmt_NT] == 0) {
    #####: 4304:					p->cost[_stmt_NT] = 0;
    #####: 4305:					p->rule._stmt = q->rule._stmt;
        -: 4306:				}
    #####: 4307:				if (q->cost[_reg_NT] == 0) {
    #####: 4308:					p->cost[_reg_NT] = 0;
    #####: 4309:					p->rule._reg = q->rule._reg;
        -: 4310:				}
    #####: 4311:				if (q->cost[_con_NT] == 0) {
    #####: 4312:					p->cost[_con_NT] = 0;
    #####: 4313:					p->rule._con = q->rule._con;
        -: 4314:				}
    #####: 4315:				if (q->cost[_acon_NT] == 0) {
    #####: 4316:					p->cost[_acon_NT] = 0;
    #####: 4317:					p->rule._acon = q->rule._acon;
        -: 4318:				}
    #####: 4319:				if (q->cost[_base_NT] == 0) {
    #####: 4320:					p->cost[_base_NT] = 0;
    #####: 4321:					p->rule._base = q->rule._base;
        -: 4322:				}
    #####: 4323:				if (q->cost[_index_NT] == 0) {
    #####: 4324:					p->cost[_index_NT] = 0;
    #####: 4325:					p->rule._index = q->rule._index;
        -: 4326:				}
    #####: 4327:				if (q->cost[_con1_NT] == 0) {
    #####: 4328:					p->cost[_con1_NT] = 0;
    #####: 4329:					p->rule._con1 = q->rule._con1;
        -: 4330:				}
    #####: 4331:				if (q->cost[_con2_NT] == 0) {
    #####: 4332:					p->cost[_con2_NT] = 0;
    #####: 4333:					p->rule._con2 = q->rule._con2;
        -: 4334:				}
    #####: 4335:				if (q->cost[_con3_NT] == 0) {
    #####: 4336:					p->cost[_con3_NT] = 0;
    #####: 4337:					p->rule._con3 = q->rule._con3;
        -: 4338:				}
    #####: 4339:				if (q->cost[_addr_NT] == 0) {
    #####: 4340:					p->cost[_addr_NT] = 0;
    #####: 4341:					p->rule._addr = q->rule._addr;
        -: 4342:				}
    #####: 4343:				if (q->cost[_mem_NT] == 0) {
    #####: 4344:					p->cost[_mem_NT] = 0;
    #####: 4345:					p->rule._mem = q->rule._mem;
        -: 4346:				}
    #####: 4347:				if (q->cost[_rc_NT] == 0) {
    #####: 4348:					p->cost[_rc_NT] = 0;
    #####: 4349:					p->rule._rc = q->rule._rc;
        -: 4350:				}
    #####: 4351:				if (q->cost[_mr_NT] == 0) {
    #####: 4352:					p->cost[_mr_NT] = 0;
    #####: 4353:					p->rule._mr = q->rule._mr;
        -: 4354:				}
    #####: 4355:				if (q->cost[_mrc0_NT] == 0) {
    #####: 4356:					p->cost[_mrc0_NT] = 0;
    #####: 4357:					p->rule._mrc0 = q->rule._mrc0;
        -: 4358:				}
    #####: 4359:				if (q->cost[_mrc1_NT] == 0) {
    #####: 4360:					p->cost[_mrc1_NT] = 0;
    #####: 4361:					p->rule._mrc1 = q->rule._mrc1;
        -: 4362:				}
    #####: 4363:				if (q->cost[_mrc3_NT] == 0) {
    #####: 4364:					p->cost[_mrc3_NT] = 0;
    #####: 4365:					p->rule._mrc3 = q->rule._mrc3;
        -: 4366:				}
    #####: 4367:				if (q->cost[_con5_NT] == 0) {
    #####: 4368:					p->cost[_con5_NT] = 0;
    #####: 4369:					p->rule._con5 = q->rule._con5;
        -: 4370:				}
    #####: 4371:				if (q->cost[_memf_NT] == 0) {
    #####: 4372:					p->cost[_memf_NT] = 0;
    #####: 4373:					p->rule._memf = q->rule._memf;
        -: 4374:				}
    #####: 4375:				if (q->cost[_flt_NT] == 0) {
    #####: 4376:					p->cost[_flt_NT] = 0;
    #####: 4377:					p->rule._flt = q->rule._flt;
        -: 4378:				}
    #####: 4379:				if (q->cost[_addrj_NT] == 0) {
    #####: 4380:					p->cost[_addrj_NT] = 0;
    #####: 4381:					p->rule._addrj = q->rule._addrj;
        -: 4382:				}
    #####: 4383:				if (q->cost[_cmpf_NT] == 0) {
    #####: 4384:					p->cost[_cmpf_NT] = 0;
    #####: 4385:					p->rule._cmpf = q->rule._cmpf;
        -: 4386:				}
        -: 4387:			}
    #####: 4388:			c = 0;
    #####: 4389:			if (c + 0 < p->cost[_reg_NT]) {
    #####: 4390:				p->cost[_reg_NT] = c + 0;
    #####: 4391:				p->rule._reg = 9;
    #####: 4392:				_closure_reg(a, c + 0);
        -: 4393:			}
        -: 4394:		}
        -: 4395:		/* memf: INDIRF8(addr) */
    #####: 4396:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + 0;
    #####: 4397:		if (c + 0 < p->cost[_memf_NT]) {
    #####: 4398:			p->cost[_memf_NT] = c + 0;
    #####: 4399:			p->rule._memf = 1;
    #####: 4400:			_closure_memf(a, c + 0);
        -: 4401:		}
    #####: 4402:		break;
        -: 4403:	case 8261: /* INDIRI8 */
    #####: 4404:		_label(LEFT_CHILD(a));
    #####: 4405:		if (	/* reg: INDIRI8(VREGP) */
        -: 4406:			LEFT_CHILD(a)->op == 711 /* VREGP */
        -: 4407:		) {
    #####: 4408:			if (mayrecalc(a)) {
    #####: 4409:				struct _state *q = a->syms[RX]->u.t.cse->x.state;
    #####: 4410:				if (q->cost[_stmt_NT] == 0) {
    #####: 4411:					p->cost[_stmt_NT] = 0;
    #####: 4412:					p->rule._stmt = q->rule._stmt;
        -: 4413:				}
    #####: 4414:				if (q->cost[_reg_NT] == 0) {
    #####: 4415:					p->cost[_reg_NT] = 0;
    #####: 4416:					p->rule._reg = q->rule._reg;
        -: 4417:				}
    #####: 4418:				if (q->cost[_con_NT] == 0) {
    #####: 4419:					p->cost[_con_NT] = 0;
    #####: 4420:					p->rule._con = q->rule._con;
        -: 4421:				}
    #####: 4422:				if (q->cost[_acon_NT] == 0) {
    #####: 4423:					p->cost[_acon_NT] = 0;
    #####: 4424:					p->rule._acon = q->rule._acon;
        -: 4425:				}
    #####: 4426:				if (q->cost[_base_NT] == 0) {
    #####: 4427:					p->cost[_base_NT] = 0;
    #####: 4428:					p->rule._base = q->rule._base;
        -: 4429:				}
    #####: 4430:				if (q->cost[_index_NT] == 0) {
    #####: 4431:					p->cost[_index_NT] = 0;
    #####: 4432:					p->rule._index = q->rule._index;
        -: 4433:				}
    #####: 4434:				if (q->cost[_con1_NT] == 0) {
    #####: 4435:					p->cost[_con1_NT] = 0;
    #####: 4436:					p->rule._con1 = q->rule._con1;
        -: 4437:				}
    #####: 4438:				if (q->cost[_con2_NT] == 0) {
    #####: 4439:					p->cost[_con2_NT] = 0;
    #####: 4440:					p->rule._con2 = q->rule._con2;
        -: 4441:				}
    #####: 4442:				if (q->cost[_con3_NT] == 0) {
    #####: 4443:					p->cost[_con3_NT] = 0;
    #####: 4444:					p->rule._con3 = q->rule._con3;
        -: 4445:				}
    #####: 4446:				if (q->cost[_addr_NT] == 0) {
    #####: 4447:					p->cost[_addr_NT] = 0;
    #####: 4448:					p->rule._addr = q->rule._addr;
        -: 4449:				}
    #####: 4450:				if (q->cost[_mem_NT] == 0) {
    #####: 4451:					p->cost[_mem_NT] = 0;
    #####: 4452:					p->rule._mem = q->rule._mem;
        -: 4453:				}
    #####: 4454:				if (q->cost[_rc_NT] == 0) {
    #####: 4455:					p->cost[_rc_NT] = 0;
    #####: 4456:					p->rule._rc = q->rule._rc;
        -: 4457:				}
    #####: 4458:				if (q->cost[_mr_NT] == 0) {
    #####: 4459:					p->cost[_mr_NT] = 0;
    #####: 4460:					p->rule._mr = q->rule._mr;
        -: 4461:				}
    #####: 4462:				if (q->cost[_mrc0_NT] == 0) {
    #####: 4463:					p->cost[_mrc0_NT] = 0;
    #####: 4464:					p->rule._mrc0 = q->rule._mrc0;
        -: 4465:				}
    #####: 4466:				if (q->cost[_mrc1_NT] == 0) {
    #####: 4467:					p->cost[_mrc1_NT] = 0;
    #####: 4468:					p->rule._mrc1 = q->rule._mrc1;
        -: 4469:				}
    #####: 4470:				if (q->cost[_mrc3_NT] == 0) {
    #####: 4471:					p->cost[_mrc3_NT] = 0;
    #####: 4472:					p->rule._mrc3 = q->rule._mrc3;
        -: 4473:				}
    #####: 4474:				if (q->cost[_con5_NT] == 0) {
    #####: 4475:					p->cost[_con5_NT] = 0;
    #####: 4476:					p->rule._con5 = q->rule._con5;
        -: 4477:				}
    #####: 4478:				if (q->cost[_memf_NT] == 0) {
    #####: 4479:					p->cost[_memf_NT] = 0;
    #####: 4480:					p->rule._memf = q->rule._memf;
        -: 4481:				}
    #####: 4482:				if (q->cost[_flt_NT] == 0) {
    #####: 4483:					p->cost[_flt_NT] = 0;
    #####: 4484:					p->rule._flt = q->rule._flt;
        -: 4485:				}
    #####: 4486:				if (q->cost[_addrj_NT] == 0) {
    #####: 4487:					p->cost[_addrj_NT] = 0;
    #####: 4488:					p->rule._addrj = q->rule._addrj;
        -: 4489:				}
    #####: 4490:				if (q->cost[_cmpf_NT] == 0) {
    #####: 4491:					p->cost[_cmpf_NT] = 0;
    #####: 4492:					p->rule._cmpf = q->rule._cmpf;
        -: 4493:				}
        -: 4494:			}
    #####: 4495:			c = 0;
    #####: 4496:			if (c + 0 < p->cost[_reg_NT]) {
    #####: 4497:				p->cost[_reg_NT] = c + 0;
    #####: 4498:				p->rule._reg = 10;
    #####: 4499:				_closure_reg(a, c + 0);
        -: 4500:			}
        -: 4501:		}
    #####: 4502:		break;
        -: 4503:	case 8262: /* INDIRU8 */
    #####: 4504:		_label(LEFT_CHILD(a));
    #####: 4505:		if (	/* reg: INDIRU8(VREGP) */
        -: 4506:			LEFT_CHILD(a)->op == 711 /* VREGP */
        -: 4507:		) {
    #####: 4508:			if (mayrecalc(a)) {
    #####: 4509:				struct _state *q = a->syms[RX]->u.t.cse->x.state;
    #####: 4510:				if (q->cost[_stmt_NT] == 0) {
    #####: 4511:					p->cost[_stmt_NT] = 0;
    #####: 4512:					p->rule._stmt = q->rule._stmt;
        -: 4513:				}
    #####: 4514:				if (q->cost[_reg_NT] == 0) {
    #####: 4515:					p->cost[_reg_NT] = 0;
    #####: 4516:					p->rule._reg = q->rule._reg;
        -: 4517:				}
    #####: 4518:				if (q->cost[_con_NT] == 0) {
    #####: 4519:					p->cost[_con_NT] = 0;
    #####: 4520:					p->rule._con = q->rule._con;
        -: 4521:				}
    #####: 4522:				if (q->cost[_acon_NT] == 0) {
    #####: 4523:					p->cost[_acon_NT] = 0;
    #####: 4524:					p->rule._acon = q->rule._acon;
        -: 4525:				}
    #####: 4526:				if (q->cost[_base_NT] == 0) {
    #####: 4527:					p->cost[_base_NT] = 0;
    #####: 4528:					p->rule._base = q->rule._base;
        -: 4529:				}
    #####: 4530:				if (q->cost[_index_NT] == 0) {
    #####: 4531:					p->cost[_index_NT] = 0;
    #####: 4532:					p->rule._index = q->rule._index;
        -: 4533:				}
    #####: 4534:				if (q->cost[_con1_NT] == 0) {
    #####: 4535:					p->cost[_con1_NT] = 0;
    #####: 4536:					p->rule._con1 = q->rule._con1;
        -: 4537:				}
    #####: 4538:				if (q->cost[_con2_NT] == 0) {
    #####: 4539:					p->cost[_con2_NT] = 0;
    #####: 4540:					p->rule._con2 = q->rule._con2;
        -: 4541:				}
    #####: 4542:				if (q->cost[_con3_NT] == 0) {
    #####: 4543:					p->cost[_con3_NT] = 0;
    #####: 4544:					p->rule._con3 = q->rule._con3;
        -: 4545:				}
    #####: 4546:				if (q->cost[_addr_NT] == 0) {
    #####: 4547:					p->cost[_addr_NT] = 0;
    #####: 4548:					p->rule._addr = q->rule._addr;
        -: 4549:				}
    #####: 4550:				if (q->cost[_mem_NT] == 0) {
    #####: 4551:					p->cost[_mem_NT] = 0;
    #####: 4552:					p->rule._mem = q->rule._mem;
        -: 4553:				}
    #####: 4554:				if (q->cost[_rc_NT] == 0) {
    #####: 4555:					p->cost[_rc_NT] = 0;
    #####: 4556:					p->rule._rc = q->rule._rc;
        -: 4557:				}
    #####: 4558:				if (q->cost[_mr_NT] == 0) {
    #####: 4559:					p->cost[_mr_NT] = 0;
    #####: 4560:					p->rule._mr = q->rule._mr;
        -: 4561:				}
    #####: 4562:				if (q->cost[_mrc0_NT] == 0) {
    #####: 4563:					p->cost[_mrc0_NT] = 0;
    #####: 4564:					p->rule._mrc0 = q->rule._mrc0;
        -: 4565:				}
    #####: 4566:				if (q->cost[_mrc1_NT] == 0) {
    #####: 4567:					p->cost[_mrc1_NT] = 0;
    #####: 4568:					p->rule._mrc1 = q->rule._mrc1;
        -: 4569:				}
    #####: 4570:				if (q->cost[_mrc3_NT] == 0) {
    #####: 4571:					p->cost[_mrc3_NT] = 0;
    #####: 4572:					p->rule._mrc3 = q->rule._mrc3;
        -: 4573:				}
    #####: 4574:				if (q->cost[_con5_NT] == 0) {
    #####: 4575:					p->cost[_con5_NT] = 0;
    #####: 4576:					p->rule._con5 = q->rule._con5;
        -: 4577:				}
    #####: 4578:				if (q->cost[_memf_NT] == 0) {
    #####: 4579:					p->cost[_memf_NT] = 0;
    #####: 4580:					p->rule._memf = q->rule._memf;
        -: 4581:				}
    #####: 4582:				if (q->cost[_flt_NT] == 0) {
    #####: 4583:					p->cost[_flt_NT] = 0;
    #####: 4584:					p->rule._flt = q->rule._flt;
        -: 4585:				}
    #####: 4586:				if (q->cost[_addrj_NT] == 0) {
    #####: 4587:					p->cost[_addrj_NT] = 0;
    #####: 4588:					p->rule._addrj = q->rule._addrj;
        -: 4589:				}
    #####: 4590:				if (q->cost[_cmpf_NT] == 0) {
    #####: 4591:					p->cost[_cmpf_NT] = 0;
    #####: 4592:					p->rule._cmpf = q->rule._cmpf;
        -: 4593:				}
        -: 4594:			}
    #####: 4595:			c = 0;
    #####: 4596:			if (c + 0 < p->cost[_reg_NT]) {
    #####: 4597:				p->cost[_reg_NT] = c + 0;
    #####: 4598:				p->rule._reg = 12;
    #####: 4599:				_closure_reg(a, c + 0);
        -: 4600:			}
        -: 4601:		}
    #####: 4602:		break;
        -: 4603:	case 8263: /* INDIRP8 */
    #####: 4604:		_label(LEFT_CHILD(a));
    #####: 4605:		if (	/* reg: INDIRP8(VREGP) */
        -: 4606:			LEFT_CHILD(a)->op == 711 /* VREGP */
        -: 4607:		) {
    #####: 4608:			if (mayrecalc(a)) {
    #####: 4609:				struct _state *q = a->syms[RX]->u.t.cse->x.state;
    #####: 4610:				if (q->cost[_stmt_NT] == 0) {
    #####: 4611:					p->cost[_stmt_NT] = 0;
    #####: 4612:					p->rule._stmt = q->rule._stmt;
        -: 4613:				}
    #####: 4614:				if (q->cost[_reg_NT] == 0) {
    #####: 4615:					p->cost[_reg_NT] = 0;
    #####: 4616:					p->rule._reg = q->rule._reg;
        -: 4617:				}
    #####: 4618:				if (q->cost[_con_NT] == 0) {
    #####: 4619:					p->cost[_con_NT] = 0;
    #####: 4620:					p->rule._con = q->rule._con;
        -: 4621:				}
    #####: 4622:				if (q->cost[_acon_NT] == 0) {
    #####: 4623:					p->cost[_acon_NT] = 0;
    #####: 4624:					p->rule._acon = q->rule._acon;
        -: 4625:				}
    #####: 4626:				if (q->cost[_base_NT] == 0) {
    #####: 4627:					p->cost[_base_NT] = 0;
    #####: 4628:					p->rule._base = q->rule._base;
        -: 4629:				}
    #####: 4630:				if (q->cost[_index_NT] == 0) {
    #####: 4631:					p->cost[_index_NT] = 0;
    #####: 4632:					p->rule._index = q->rule._index;
        -: 4633:				}
    #####: 4634:				if (q->cost[_con1_NT] == 0) {
    #####: 4635:					p->cost[_con1_NT] = 0;
    #####: 4636:					p->rule._con1 = q->rule._con1;
        -: 4637:				}
    #####: 4638:				if (q->cost[_con2_NT] == 0) {
    #####: 4639:					p->cost[_con2_NT] = 0;
    #####: 4640:					p->rule._con2 = q->rule._con2;
        -: 4641:				}
    #####: 4642:				if (q->cost[_con3_NT] == 0) {
    #####: 4643:					p->cost[_con3_NT] = 0;
    #####: 4644:					p->rule._con3 = q->rule._con3;
        -: 4645:				}
    #####: 4646:				if (q->cost[_addr_NT] == 0) {
    #####: 4647:					p->cost[_addr_NT] = 0;
    #####: 4648:					p->rule._addr = q->rule._addr;
        -: 4649:				}
    #####: 4650:				if (q->cost[_mem_NT] == 0) {
    #####: 4651:					p->cost[_mem_NT] = 0;
    #####: 4652:					p->rule._mem = q->rule._mem;
        -: 4653:				}
    #####: 4654:				if (q->cost[_rc_NT] == 0) {
    #####: 4655:					p->cost[_rc_NT] = 0;
    #####: 4656:					p->rule._rc = q->rule._rc;
        -: 4657:				}
    #####: 4658:				if (q->cost[_mr_NT] == 0) {
    #####: 4659:					p->cost[_mr_NT] = 0;
    #####: 4660:					p->rule._mr = q->rule._mr;
        -: 4661:				}
    #####: 4662:				if (q->cost[_mrc0_NT] == 0) {
    #####: 4663:					p->cost[_mrc0_NT] = 0;
    #####: 4664:					p->rule._mrc0 = q->rule._mrc0;
        -: 4665:				}
    #####: 4666:				if (q->cost[_mrc1_NT] == 0) {
    #####: 4667:					p->cost[_mrc1_NT] = 0;
    #####: 4668:					p->rule._mrc1 = q->rule._mrc1;
        -: 4669:				}
    #####: 4670:				if (q->cost[_mrc3_NT] == 0) {
    #####: 4671:					p->cost[_mrc3_NT] = 0;
    #####: 4672:					p->rule._mrc3 = q->rule._mrc3;
        -: 4673:				}
    #####: 4674:				if (q->cost[_con5_NT] == 0) {
    #####: 4675:					p->cost[_con5_NT] = 0;
    #####: 4676:					p->rule._con5 = q->rule._con5;
        -: 4677:				}
    #####: 4678:				if (q->cost[_memf_NT] == 0) {
    #####: 4679:					p->cost[_memf_NT] = 0;
    #####: 4680:					p->rule._memf = q->rule._memf;
        -: 4681:				}
    #####: 4682:				if (q->cost[_flt_NT] == 0) {
    #####: 4683:					p->cost[_flt_NT] = 0;
    #####: 4684:					p->rule._flt = q->rule._flt;
        -: 4685:				}
    #####: 4686:				if (q->cost[_addrj_NT] == 0) {
    #####: 4687:					p->cost[_addrj_NT] = 0;
    #####: 4688:					p->rule._addrj = q->rule._addrj;
        -: 4689:				}
    #####: 4690:				if (q->cost[_cmpf_NT] == 0) {
    #####: 4691:					p->cost[_cmpf_NT] = 0;
    #####: 4692:					p->rule._cmpf = q->rule._cmpf;
        -: 4693:				}
        -: 4694:			}
    #####: 4695:			c = 0;
    #####: 4696:			if (c + 0 < p->cost[_reg_NT]) {
    #####: 4697:				p->cost[_reg_NT] = c + 0;
    #####: 4698:				p->rule._reg = 11;
    #####: 4699:				_closure_reg(a, c + 0);
        -: 4700:			}
        -: 4701:		}
    #####: 4702:		break;
        -: 4703:	case 8305: /* CVFF8 */
    #####: 4704:		_label(LEFT_CHILD(a));
    #####: 4705:		if (	/* memf: CVFF8(INDIRF4(addr)) */
        -: 4706:			LEFT_CHILD(a)->op == 4161 /* INDIRF4 */
        -: 4707:		) {
    #####: 4708:			c = ((struct _state *)(LEFT_CHILD(LEFT_CHILD(a))->x.state))->cost[_addr_NT] + 0;
    #####: 4709:			if (c + 0 < p->cost[_memf_NT]) {
    #####: 4710:				p->cost[_memf_NT] = c + 0;
    #####: 4711:				p->rule._memf = 3;
    #####: 4712:				_closure_memf(a, c + 0);
        -: 4713:			}
        -: 4714:		}
        -: 4715:		/* reg: CVFF8(reg) */
    #####: 4716:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
    #####: 4717:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 4718:			p->cost[_reg_NT] = c + 0;
    #####: 4719:			p->rule._reg = 77;
    #####: 4720:			_closure_reg(a, c + 0);
        -: 4721:		}
    #####: 4722:		break;
        -: 4723:	case 8309: /* CVFI8 */
    #####: 4724:		break;
        -: 4725:	case 8321: /* CVIF8 */
    #####: 4726:		_label(LEFT_CHILD(a));
    #####: 4727:		if (	/* reg: CVIF8(INDIRI4(addr)) */
        -: 4728:			LEFT_CHILD(a)->op == 4165 /* INDIRI4 */
        -: 4729:		) {
    #####: 4730:			c = ((struct _state *)(LEFT_CHILD(LEFT_CHILD(a))->x.state))->cost[_addr_NT] + 10;
    #####: 4731:			if (c + 0 < p->cost[_reg_NT]) {
    #####: 4732:				p->cost[_reg_NT] = c + 0;
    #####: 4733:				p->rule._reg = 80;
    #####: 4734:				_closure_reg(a, c + 0);
        -: 4735:			}
        -: 4736:		}
        -: 4737:		/* reg: CVIF8(reg) */
    #####: 4738:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + 12;
    #####: 4739:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 4740:			p->cost[_reg_NT] = c + 0;
    #####: 4741:			p->rule._reg = 82;
    #####: 4742:			_closure_reg(a, c + 0);
        -: 4743:		}
    #####: 4744:		break;
        -: 4745:	case 8325: /* CVII8 */
    #####: 4746:		break;
        -: 4747:	case 8326: /* CVIU8 */
    #####: 4748:		break;
        -: 4749:	case 8342: /* CVPU8 */
    #####: 4750:		break;
        -: 4751:	case 8343: /* CVPP8 */
    #####: 4752:		break;
        -: 4753:	case 8373: /* CVUI8 */
    #####: 4754:		break;
        -: 4755:	case 8374: /* CVUU8 */
    #####: 4756:		break;
        -: 4757:	case 8375: /* CVUP8 */
    #####: 4758:		break;
        -: 4759:	case 8385: /* NEGF8 */
    #####: 4760:		_label(LEFT_CHILD(a));
        -: 4761:		/* reg: NEGF8(reg) */
    #####: 4762:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
    #####: 4763:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 4764:			p->cost[_reg_NT] = c + 0;
    #####: 4765:			p->rule._reg = 67;
    #####: 4766:			_closure_reg(a, c + 0);
        -: 4767:		}
    #####: 4768:		break;
        -: 4769:	case 8389: /* NEGI8 */
    #####: 4770:		break;
        -: 4771:	case 8401: /* CALLF8 */
    #####: 4772:		_label(LEFT_CHILD(a));
        -: 4773:		/* reg: CALLF8(addrj) */
    #####: 4774:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addrj_NT] + 0;
    #####: 4775:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 4776:			p->cost[_reg_NT] = c + 0;
    #####: 4777:			p->rule._reg = 87;
    #####: 4778:			_closure_reg(a, c + 0);
        -: 4779:		}
        -: 4780:		/* stmt: CALLF8(addrj) */
    #####: 4781:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addrj_NT] + 0;
    #####: 4782:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 4783:			p->cost[_stmt_NT] = c + 0;
    #####: 4784:			p->rule._stmt = 92;
        -: 4785:		}
    #####: 4786:		break;
        -: 4787:	case 8405: /* CALLI8 */
    #####: 4788:		break;
        -: 4789:	case 8406: /* CALLU8 */
    #####: 4790:		break;
        -: 4791:	case 8407: /* CALLP8 */
    #####: 4792:		break;
        -: 4793:	case 8417: /* LOADF8 */
    #####: 4794:		break;
        -: 4795:	case 8421: /* LOADI8 */
    #####: 4796:		break;
        -: 4797:	case 8422: /* LOADU8 */
    #####: 4798:		break;
        -: 4799:	case 8423: /* LOADP8 */
    #####: 4800:		break;
        -: 4801:	case 8433: /* RETF8 */
    #####: 4802:		_label(LEFT_CHILD(a));
        -: 4803:		/* stmt: RETF8(reg) */
    #####: 4804:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
    #####: 4805:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 4806:			p->cost[_stmt_NT] = c + 0;
    #####: 4807:			p->rule._stmt = 97;
        -: 4808:		}
    #####: 4809:		break;
        -: 4810:	case 8437: /* RETI8 */
    #####: 4811:		break;
        -: 4812:	case 8438: /* RETU8 */
    #####: 4813:		break;
        -: 4814:	case 8439: /* RETP8 */
    #####: 4815:		break;
        -: 4816:	case 8455: /* ADDRGP8 */
    #####: 4817:		break;
        -: 4818:	case 8471: /* ADDRFP8 */
    #####: 4819:		break;
        -: 4820:	case 8487: /* ADDRLP8 */
    #####: 4821:		break;
        -: 4822:	case 8497: /* ADDF8 */
    #####: 4823:		_label(LEFT_CHILD(a));
    #####: 4824:		_label(RIGHT_CHILD(a));
        -: 4825:		/* reg: ADDF8(reg,flt) */
    #####: 4826:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_flt_NT] + 0;
    #####: 4827:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 4828:			p->cost[_reg_NT] = c + 0;
    #####: 4829:			p->rule._reg = 69;
    #####: 4830:			_closure_reg(a, c + 0);
        -: 4831:		}
    #####: 4832:		break;
        -: 4833:	case 8501: /* ADDI8 */
    #####: 4834:		break;
        -: 4835:	case 8502: /* ADDU8 */
    #####: 4836:		break;
        -: 4837:	case 8503: /* ADDP8 */
    #####: 4838:		break;
        -: 4839:	case 8513: /* SUBF8 */
    #####: 4840:		_label(LEFT_CHILD(a));
    #####: 4841:		_label(RIGHT_CHILD(a));
        -: 4842:		/* reg: SUBF8(reg,flt) */
    #####: 4843:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_flt_NT] + 0;
    #####: 4844:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 4845:			p->cost[_reg_NT] = c + 0;
    #####: 4846:			p->rule._reg = 75;
    #####: 4847:			_closure_reg(a, c + 0);
        -: 4848:		}
    #####: 4849:		break;
        -: 4850:	case 8517: /* SUBI8 */
    #####: 4851:		break;
        -: 4852:	case 8518: /* SUBU8 */
    #####: 4853:		break;
        -: 4854:	case 8519: /* SUBP8 */
    #####: 4855:		break;
        -: 4856:	case 8533: /* LSHI8 */
    #####: 4857:		break;
        -: 4858:	case 8534: /* LSHU8 */
    #####: 4859:		break;
        -: 4860:	case 8549: /* MODI8 */
    #####: 4861:		break;
        -: 4862:	case 8550: /* MODU8 */
    #####: 4863:		break;
        -: 4864:	case 8565: /* RSHI8 */
    #####: 4865:		break;
        -: 4866:	case 8566: /* RSHU8 */
    #####: 4867:		break;
        -: 4868:	case 8581: /* BANDI8 */
    #####: 4869:		break;
        -: 4870:	case 8582: /* BANDU8 */
    #####: 4871:		break;
        -: 4872:	case 8597: /* BCOMI8 */
    #####: 4873:		break;
        -: 4874:	case 8598: /* BCOMU8 */
    #####: 4875:		break;
        -: 4876:	case 8613: /* BORI8 */
    #####: 4877:		break;
        -: 4878:	case 8614: /* BORU8 */
    #####: 4879:		break;
        -: 4880:	case 8629: /* BXORI8 */
    #####: 4881:		break;
        -: 4882:	case 8630: /* BXORU8 */
    #####: 4883:		break;
        -: 4884:	case 8641: /* DIVF8 */
    #####: 4885:		_label(LEFT_CHILD(a));
    #####: 4886:		_label(RIGHT_CHILD(a));
        -: 4887:		/* reg: DIVF8(reg,flt) */
    #####: 4888:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_flt_NT] + 0;
    #####: 4889:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 4890:			p->cost[_reg_NT] = c + 0;
    #####: 4891:			p->rule._reg = 71;
    #####: 4892:			_closure_reg(a, c + 0);
        -: 4893:		}
    #####: 4894:		break;
        -: 4895:	case 8645: /* DIVI8 */
    #####: 4896:		break;
        -: 4897:	case 8646: /* DIVU8 */
    #####: 4898:		break;
        -: 4899:	case 8657: /* MULF8 */
    #####: 4900:		_label(LEFT_CHILD(a));
    #####: 4901:		_label(RIGHT_CHILD(a));
        -: 4902:		/* reg: MULF8(reg,flt) */
    #####: 4903:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_flt_NT] + 0;
    #####: 4904:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 4905:			p->cost[_reg_NT] = c + 0;
    #####: 4906:			p->rule._reg = 73;
    #####: 4907:			_closure_reg(a, c + 0);
        -: 4908:		}
    #####: 4909:		break;
        -: 4910:	case 8661: /* MULI8 */
    #####: 4911:		break;
        -: 4912:	case 8662: /* MULU8 */
    #####: 4913:		break;
        -: 4914:	case 8673: /* EQF8 */
    #####: 4915:		_label(LEFT_CHILD(a));
    #####: 4916:		_label(RIGHT_CHILD(a));
        -: 4917:		/* stmt: EQF8(cmpf,reg) */
    #####: 4918:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_cmpf_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
    #####: 4919:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 4920:			p->cost[_stmt_NT] = c + 0;
    #####: 4921:			p->rule._stmt = 78;
        -: 4922:		}
    #####: 4923:		break;
        -: 4924:	case 8677: /* EQI8 */
    #####: 4925:		break;
        -: 4926:	case 8678: /* EQU8 */
    #####: 4927:		break;
        -: 4928:	case 8689: /* GEF8 */
    #####: 4929:		_label(LEFT_CHILD(a));
    #####: 4930:		_label(RIGHT_CHILD(a));
        -: 4931:		/* stmt: GEF8(cmpf,reg) */
    #####: 4932:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_cmpf_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
    #####: 4933:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 4934:			p->cost[_stmt_NT] = c + 0;
    #####: 4935:			p->rule._stmt = 79;
        -: 4936:		}
    #####: 4937:		break;
        -: 4938:	case 8693: /* GEI8 */
    #####: 4939:		break;
        -: 4940:	case 8694: /* GEU8 */
    #####: 4941:		break;
        -: 4942:	case 8705: /* GTF8 */
    #####: 4943:		_label(LEFT_CHILD(a));
    #####: 4944:		_label(RIGHT_CHILD(a));
        -: 4945:		/* stmt: GTF8(cmpf,reg) */
    #####: 4946:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_cmpf_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
    #####: 4947:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 4948:			p->cost[_stmt_NT] = c + 0;
    #####: 4949:			p->rule._stmt = 80;
        -: 4950:		}
    #####: 4951:		break;
        -: 4952:	case 8709: /* GTI8 */
    #####: 4953:		break;
        -: 4954:	case 8710: /* GTU8 */
    #####: 4955:		break;
        -: 4956:	case 8721: /* LEF8 */
    #####: 4957:		_label(LEFT_CHILD(a));
    #####: 4958:		_label(RIGHT_CHILD(a));
        -: 4959:		/* stmt: LEF8(cmpf,reg) */
    #####: 4960:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_cmpf_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
    #####: 4961:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 4962:			p->cost[_stmt_NT] = c + 0;
    #####: 4963:			p->rule._stmt = 81;
        -: 4964:		}
    #####: 4965:		break;
        -: 4966:	case 8725: /* LEI8 */
    #####: 4967:		break;
        -: 4968:	case 8726: /* LEU8 */
    #####: 4969:		break;
        -: 4970:	case 8737: /* LTF8 */
    #####: 4971:		_label(LEFT_CHILD(a));
    #####: 4972:		_label(RIGHT_CHILD(a));
        -: 4973:		/* stmt: LTF8(cmpf,reg) */
    #####: 4974:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_cmpf_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
    #####: 4975:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 4976:			p->cost[_stmt_NT] = c + 0;
    #####: 4977:			p->rule._stmt = 82;
        -: 4978:		}
    #####: 4979:		break;
        -: 4980:	case 8741: /* LTI8 */
    #####: 4981:		break;
        -: 4982:	case 8742: /* LTU8 */
    #####: 4983:		break;
        -: 4984:	case 8753: /* NEF8 */
    #####: 4985:		_label(LEFT_CHILD(a));
    #####: 4986:		_label(RIGHT_CHILD(a));
        -: 4987:		/* stmt: NEF8(cmpf,reg) */
    #####: 4988:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_cmpf_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
    #####: 4989:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 4990:			p->cost[_stmt_NT] = c + 0;
    #####: 4991:			p->rule._stmt = 83;
        -: 4992:		}
    #####: 4993:		break;
        -: 4994:	case 8757: /* NEI8 */
    #####: 4995:		break;
        -: 4996:	case 8758: /* NEU8 */
    #####: 4997:		break;
        -: 4998:	case 16401: /* CNSTF16 */
    #####: 4999:		break;
        -: 5000:	case 16417: /* ARGF16 */
    #####: 5001:		break;
        -: 5002:	case 16433: /* ASGNF16 */
    #####: 5003:		break;
        -: 5004:	case 16449: /* INDIRF16 */
    #####: 5005:		break;
        -: 5006:	case 16497: /* CVFF16 */
    #####: 5007:		break;
        -: 5008:	case 16513: /* CVIF16 */
    #####: 5009:		break;
        -: 5010:	case 16535: /* CVPP16 */
    #####: 5011:		break;
        -: 5012:	case 16567: /* CVUP16 */
    #####: 5013:		break;
        -: 5014:	case 16577: /* NEGF16 */
    #####: 5015:		break;
        -: 5016:	case 16593: /* CALLF16 */
    #####: 5017:		break;
        -: 5018:	case 16609: /* LOADF16 */
    #####: 5019:		break;
        -: 5020:	case 16625: /* RETF16 */
    #####: 5021:		break;
        -: 5022:	case 16689: /* ADDF16 */
    #####: 5023:		break;
        -: 5024:	case 16705: /* SUBF16 */
    #####: 5025:		break;
        -: 5026:	case 16833: /* DIVF16 */
    #####: 5027:		break;
        -: 5028:	case 16849: /* MULF16 */
    #####: 5029:		break;
        -: 5030:	case 16865: /* EQF16 */
    #####: 5031:		break;
        -: 5032:	case 16885: /* GEI16 */
    #####: 5033:		break;
        -: 5034:	case 16897: /* GTF16 */
    #####: 5035:		break;
        -: 5036:	case 16913: /* LEF16 */
    #####: 5037:		break;
        -: 5038:	case 16929: /* LTF16 */
    #####: 5039:		break;
        -: 5040:	case 16945: /* NEF16 */
    #####: 5041:		break;
        -: 5042:	default:
    #####: 5043:		fatal("_label", "Bad terminal %d\n", OP_LABEL(a));
        -: 5044:	}
        -: 5045:}
        -: 5046:
function _kids called 0 returned 0% blocks executed 0%
    #####: 5047:static void _kids(NODEPTR_TYPE p, int eruleno, NODEPTR_TYPE kids[]) {
    #####: 5048:	if (!p)
    #####: 5049:		fatal("_kids", "Null tree\n", 0);
    #####: 5050:	if (!kids)
    #####: 5051:		fatal("_kids", "Null kids\n", 0);
    #####: 5052:	switch (eruleno) {
        -: 5053:	case 200: /* stmt: LABELV */
        -: 5054:	case 196: /* addrj: ADDRGP4 */
        -: 5055:	case 131: /* con5: CNSTI4 */
        -: 5056:	case 54: /* con3: CNSTU4 */
        -: 5057:	case 53: /* con3: CNSTI4 */
        -: 5058:	case 52: /* con2: CNSTU4 */
        -: 5059:	case 51: /* con2: CNSTI4 */
        -: 5060:	case 50: /* con1: CNSTU4 */
        -: 5061:	case 49: /* con1: CNSTI4 */
        -: 5062:	case 44: /* base: ADDRLP4 */
        -: 5063:	case 43: /* base: ADDRFP4 */
        -: 5064:	case 38: /* base: ADDRGP4 */
        -: 5065:	case 36: /* acon: ADDRGP4 */
        -: 5066:	case 34: /* con: CNSTP8 */
        -: 5067:	case 33: /* con: CNSTU8 */
        -: 5068:	case 32: /* con: CNSTI8 */
        -: 5069:	case 31: /* con: CNSTP4 */
        -: 5070:	case 30: /* con: CNSTU4 */
        -: 5071:	case 29: /* con: CNSTI4 */
        -: 5072:	case 28: /* con: CNSTU2 */
        -: 5073:	case 27: /* con: CNSTI2 */
        -: 5074:	case 26: /* con: CNSTU1 */
        -: 5075:	case 25: /* con: CNSTI1 */
        -: 5076:	case 12: /* reg: INDIRU8(VREGP) */
        -: 5077:	case 11: /* reg: INDIRP8(VREGP) */
        -: 5078:	case 10: /* reg: INDIRI8(VREGP) */
        -: 5079:	case 9: /* reg: INDIRF8(VREGP) */
        -: 5080:	case 8: /* reg: INDIRU4(VREGP) */
        -: 5081:	case 7: /* reg: INDIRP4(VREGP) */
        -: 5082:	case 6: /* reg: INDIRI4(VREGP) */
        -: 5083:	case 5: /* reg: INDIRF4(VREGP) */
        -: 5084:	case 4: /* reg: INDIRU2(VREGP) */
        -: 5085:	case 3: /* reg: INDIRI2(VREGP) */
        -: 5086:	case 2: /* reg: INDIRU1(VREGP) */
        -: 5087:	case 1: /* reg: INDIRI1(VREGP) */
    #####: 5088:		break;
        -: 5089:	case 24: /* stmt: ASGNU8(VREGP,reg) */
        -: 5090:	case 23: /* stmt: ASGNP8(VREGP,reg) */
        -: 5091:	case 22: /* stmt: ASGNI8(VREGP,reg) */
        -: 5092:	case 21: /* stmt: ASGNF8(VREGP,reg) */
        -: 5093:	case 20: /* stmt: ASGNU4(VREGP,reg) */
        -: 5094:	case 19: /* stmt: ASGNP4(VREGP,reg) */
        -: 5095:	case 18: /* stmt: ASGNI4(VREGP,reg) */
        -: 5096:	case 17: /* stmt: ASGNF4(VREGP,reg) */
        -: 5097:	case 16: /* stmt: ASGNU2(VREGP,reg) */
        -: 5098:	case 15: /* stmt: ASGNI2(VREGP,reg) */
        -: 5099:	case 14: /* stmt: ASGNU1(VREGP,reg) */
        -: 5100:	case 13: /* stmt: ASGNI1(VREGP,reg) */
    #####: 5101:		kids[0] = RIGHT_CHILD(p);
    #####: 5102:		break;
        -: 5103:	case 224: /* cmpf: reg */
        -: 5104:	case 223: /* cmpf: memf */
        -: 5105:	case 198: /* addrj: mem */
        -: 5106:	case 197: /* addrj: reg */
        -: 5107:	case 181: /* flt: reg */
        -: 5108:	case 180: /* flt: memf */
        -: 5109:	case 172: /* reg: memf */
        -: 5110:	case 81: /* reg: mrc0 */
        -: 5111:	case 80: /* reg: addr */
        -: 5112:	case 79: /* mrc3: rc */
        -: 5113:	case 78: /* mrc3: mem */
        -: 5114:	case 77: /* mrc1: rc */
        -: 5115:	case 76: /* mrc1: mem */
        -: 5116:	case 75: /* mrc0: rc */
        -: 5117:	case 74: /* mrc0: mem */
        -: 5118:	case 73: /* mr: mem */
        -: 5119:	case 72: /* mr: reg */
        -: 5120:	case 71: /* rc: con */
        -: 5121:	case 70: /* rc: reg */
        -: 5122:	case 62: /* addr: index */
        -: 5123:	case 58: /* addr: base */
        -: 5124:	case 45: /* index: reg */
        -: 5125:	case 39: /* base: reg */
        -: 5126:	case 37: /* acon: con */
        -: 5127:	case 35: /* stmt: reg */
    #####: 5128:		kids[0] = p;
    #####: 5129:		break;
        -: 5130:	case 236: /* stmt: NEF4(cmpf,reg) */
        -: 5131:	case 235: /* stmt: LTF4(cmpf,reg) */
        -: 5132:	case 234: /* stmt: LEF4(cmpf,reg) */
        -: 5133:	case 233: /* stmt: GTF4(cmpf,reg) */
        -: 5134:	case 232: /* stmt: GEF4(cmpf,reg) */
        -: 5135:	case 231: /* stmt: EQF4(cmpf,reg) */
        -: 5136:	case 230: /* stmt: NEF8(cmpf,reg) */
        -: 5137:	case 229: /* stmt: LTF8(cmpf,reg) */
        -: 5138:	case 228: /* stmt: LEF8(cmpf,reg) */
        -: 5139:	case 227: /* stmt: GTF8(cmpf,reg) */
        -: 5140:	case 226: /* stmt: GEF8(cmpf,reg) */
        -: 5141:	case 225: /* stmt: EQF8(cmpf,reg) */
        -: 5142:	case 222: /* stmt: NEU4(reg,mrc1) */
        -: 5143:	case 221: /* stmt: LTU4(reg,mrc1) */
        -: 5144:	case 220: /* stmt: LEU4(reg,mrc1) */
        -: 5145:	case 219: /* stmt: GTU4(reg,mrc1) */
        -: 5146:	case 218: /* stmt: GEU4(reg,mrc1) */
        -: 5147:	case 217: /* stmt: EQU4(reg,mrc1) */
        -: 5148:	case 216: /* stmt: NEI4(reg,mrc1) */
        -: 5149:	case 215: /* stmt: LTI4(reg,mrc1) */
        -: 5150:	case 214: /* stmt: LEI4(reg,mrc1) */
        -: 5151:	case 213: /* stmt: GTI4(reg,mrc1) */
        -: 5152:	case 212: /* stmt: GEI4(reg,mrc1) */
        -: 5153:	case 211: /* stmt: EQI4(reg,mrc1) */
        -: 5154:	case 210: /* stmt: LTU4(mem,rc) */
        -: 5155:	case 209: /* stmt: LEU4(mem,rc) */
        -: 5156:	case 208: /* stmt: GTU4(mem,rc) */
        -: 5157:	case 207: /* stmt: GEU4(mem,rc) */
        -: 5158:	case 206: /* stmt: NEI4(mem,rc) */
        -: 5159:	case 205: /* stmt: LTI4(mem,rc) */
        -: 5160:	case 204: /* stmt: LEI4(mem,rc) */
        -: 5161:	case 203: /* stmt: GTI4(mem,rc) */
        -: 5162:	case 202: /* stmt: GEI4(mem,rc) */
        -: 5163:	case 201: /* stmt: EQI4(mem,rc) */
        -: 5164:	case 189: /* reg: SUBF4(reg,flt) */
        -: 5165:	case 188: /* reg: SUBF8(reg,flt) */
        -: 5166:	case 187: /* reg: MULF4(reg,flt) */
        -: 5167:	case 186: /* reg: MULF8(reg,flt) */
        -: 5168:	case 185: /* reg: DIVF4(reg,flt) */
        -: 5169:	case 184: /* reg: DIVF8(reg,flt) */
        -: 5170:	case 183: /* reg: ADDF4(reg,flt) */
        -: 5171:	case 182: /* reg: ADDF8(reg,flt) */
        -: 5172:	case 174: /* stmt: ASGNF4(addr,reg) */
        -: 5173:	case 173: /* stmt: ASGNF8(addr,reg) */
        -: 5174:	case 163: /* stmt: ASGNP4(addr,rc) */
        -: 5175:	case 162: /* stmt: ASGNU4(addr,rc) */
        -: 5176:	case 161: /* stmt: ASGNU2(addr,rc) */
        -: 5177:	case 160: /* stmt: ASGNU1(addr,rc) */
        -: 5178:	case 159: /* stmt: ASGNI4(addr,rc) */
        -: 5179:	case 158: /* stmt: ASGNI2(addr,rc) */
        -: 5180:	case 157: /* stmt: ASGNI1(addr,rc) */
        -: 5181:	case 142: /* reg: MODI4(reg,reg) */
        -: 5182:	case 141: /* reg: DIVI4(reg,reg) */
        -: 5183:	case 140: /* reg: MODU4(reg,reg) */
        -: 5184:	case 139: /* reg: DIVU4(reg,reg) */
        -: 5185:	case 138: /* reg: MULU4(reg,mr) */
        -: 5186:	case 137: /* reg: MULI4(con,mr) */
        -: 5187:	case 136: /* reg: MULI4(reg,mrc3) */
        -: 5188:	case 135: /* reg: RSHU4(reg,reg) */
        -: 5189:	case 134: /* reg: RSHI4(reg,reg) */
        -: 5190:	case 133: /* reg: LSHU4(reg,reg) */
        -: 5191:	case 132: /* reg: LSHI4(reg,reg) */
        -: 5192:	case 126: /* reg: RSHU4(reg,con5) */
        -: 5193:	case 125: /* reg: RSHI4(reg,con5) */
        -: 5194:	case 124: /* reg: LSHU4(reg,con5) */
        -: 5195:	case 123: /* reg: LSHI4(reg,con5) */
        -: 5196:	case 100: /* reg: BXORU4(reg,mrc1) */
        -: 5197:	case 99: /* reg: BORU4(reg,mrc1) */
        -: 5198:	case 98: /* reg: BANDU4(reg,mrc1) */
        -: 5199:	case 97: /* reg: BXORI4(reg,mrc1) */
        -: 5200:	case 96: /* reg: BORI4(reg,mrc1) */
        -: 5201:	case 95: /* reg: BANDI4(reg,mrc1) */
        -: 5202:	case 94: /* reg: SUBU4(reg,mrc1) */
        -: 5203:	case 93: /* reg: SUBP4(reg,mrc1) */
        -: 5204:	case 92: /* reg: SUBI4(reg,mrc1) */
        -: 5205:	case 91: /* reg: ADDU4(reg,mrc1) */
        -: 5206:	case 90: /* reg: ADDP4(reg,mrc1) */
        -: 5207:	case 89: /* reg: ADDI4(reg,mrc1) */
        -: 5208:	case 61: /* addr: ADDU4(index,base) */
        -: 5209:	case 60: /* addr: ADDP4(index,base) */
        -: 5210:	case 59: /* addr: ADDI4(index,base) */
        -: 5211:	case 57: /* index: LSHU4(reg,con3) */
        -: 5212:	case 56: /* index: LSHU4(reg,con2) */
        -: 5213:	case 55: /* index: LSHU4(reg,con1) */
        -: 5214:	case 48: /* index: LSHI4(reg,con3) */
        -: 5215:	case 47: /* index: LSHI4(reg,con2) */
        -: 5216:	case 46: /* index: LSHI4(reg,con1) */
        -: 5217:	case 42: /* base: ADDU4(reg,acon) */
        -: 5218:	case 41: /* base: ADDP4(reg,acon) */
        -: 5219:	case 40: /* base: ADDI4(reg,acon) */
    #####: 5220:		kids[0] = LEFT_CHILD(p);
    #####: 5221:		kids[1] = RIGHT_CHILD(p);
    #####: 5222:		break;
        -: 5223:	case 249: /* stmt: RETF8(reg) */
        -: 5224:	case 248: /* stmt: RETF4(reg) */
        -: 5225:	case 247: /* stmt: RETP4(reg) */
        -: 5226:	case 246: /* stmt: RETU4(reg) */
        -: 5227:	case 245: /* stmt: RETI4(reg) */
        -: 5228:	case 244: /* stmt: CALLF8(addrj) */
        -: 5229:	case 243: /* stmt: CALLF4(addrj) */
        -: 5230:	case 242: /* reg: CALLF8(addrj) */
        -: 5231:	case 241: /* reg: CALLF4(addrj) */
        -: 5232:	case 240: /* stmt: CALLV(addrj) */
        -: 5233:	case 239: /* reg: CALLP4(addrj) */
        -: 5234:	case 238: /* reg: CALLU4(addrj) */
        -: 5235:	case 237: /* reg: CALLI4(addrj) */
        -: 5236:	case 199: /* stmt: JUMPV(addrj) */
        -: 5237:	case 195: /* reg: CVIF8(reg) */
        -: 5238:	case 194: /* reg: CVIF4(reg) */
        -: 5239:	case 192: /* reg: CVFI4(reg) */
        -: 5240:	case 191: /* reg: CVFF4(reg) */
        -: 5241:	case 190: /* reg: CVFF8(reg) */
        -: 5242:	case 179: /* reg: NEGF4(reg) */
        -: 5243:	case 178: /* reg: NEGF8(reg) */
        -: 5244:	case 177: /* stmt: ARGF4(reg) */
        -: 5245:	case 176: /* stmt: ARGF8(reg) */
        -: 5246:	case 170: /* memf: INDIRF4(addr) */
        -: 5247:	case 169: /* memf: INDIRF8(addr) */
        -: 5248:	case 166: /* stmt: ARGP4(mrc3) */
        -: 5249:	case 165: /* stmt: ARGU4(mrc3) */
        -: 5250:	case 164: /* stmt: ARGI4(mrc3) */
        -: 5251:	case 156: /* reg: CVUU2(reg) */
        -: 5252:	case 155: /* reg: CVUU1(reg) */
        -: 5253:	case 154: /* reg: CVII2(reg) */
        -: 5254:	case 153: /* reg: CVII1(reg) */
        -: 5255:	case 152: /* reg: CVUU4(reg) */
        -: 5256:	case 151: /* reg: CVUI4(reg) */
        -: 5257:	case 150: /* reg: CVIU4(reg) */
        -: 5258:	case 149: /* reg: CVII4(reg) */
        -: 5259:	case 144: /* reg: CVUP4(reg) */
        -: 5260:	case 143: /* reg: CVPU4(reg) */
        -: 5261:	case 119: /* reg: NEGI4(reg) */
        -: 5262:	case 118: /* reg: BCOMU4(reg) */
        -: 5263:	case 117: /* reg: BCOMI4(reg) */
        -: 5264:	case 88: /* reg: LOADP4(reg) */
        -: 5265:	case 87: /* reg: LOADU4(reg) */
        -: 5266:	case 86: /* reg: LOADU2(reg) */
        -: 5267:	case 85: /* reg: LOADU1(reg) */
        -: 5268:	case 84: /* reg: LOADI4(reg) */
        -: 5269:	case 83: /* reg: LOADI2(reg) */
        -: 5270:	case 82: /* reg: LOADI1(reg) */
        -: 5271:	case 69: /* mem: INDIRP4(addr) */
        -: 5272:	case 68: /* mem: INDIRU4(addr) */
        -: 5273:	case 67: /* mem: INDIRU2(addr) */
        -: 5274:	case 66: /* mem: INDIRU1(addr) */
        -: 5275:	case 65: /* mem: INDIRI4(addr) */
        -: 5276:	case 64: /* mem: INDIRI2(addr) */
        -: 5277:	case 63: /* mem: INDIRI1(addr) */
    #####: 5278:		kids[0] = LEFT_CHILD(p);
    #####: 5279:		break;
        -: 5280:	case 130: /* stmt: ASGNI4(addr,RSHU4(mem,con5)) */
        -: 5281:	case 129: /* stmt: ASGNI4(addr,RSHI4(mem,con5)) */
        -: 5282:	case 128: /* stmt: ASGNI4(addr,LSHU4(mem,con5)) */
        -: 5283:	case 127: /* stmt: ASGNI4(addr,LSHI4(mem,con5)) */
        -: 5284:	case 116: /* stmt: ASGNU4(addr,BXORU4(mem,rc)) */
        -: 5285:	case 115: /* stmt: ASGNU4(addr,BORU4(mem,rc)) */
        -: 5286:	case 114: /* stmt: ASGNU4(addr,BANDU4(mem,rc)) */
        -: 5287:	case 113: /* stmt: ASGNI4(addr,BXORI4(mem,rc)) */
        -: 5288:	case 112: /* stmt: ASGNI4(addr,BORI4(mem,rc)) */
        -: 5289:	case 111: /* stmt: ASGNI4(addr,BANDI4(mem,rc)) */
        -: 5290:	case 110: /* stmt: ASGNU4(addr,SUBU4(mem,rc)) */
        -: 5291:	case 109: /* stmt: ASGNU4(addr,ADDU4(mem,rc)) */
        -: 5292:	case 108: /* stmt: ASGNI4(addr,SUBI4(mem,rc)) */
        -: 5293:	case 107: /* stmt: ASGNI4(addr,ADDI4(mem,rc)) */
        -: 5294:	case 106: /* stmt: ASGNP4(addr,SUBP4(mem,con1)) */
        -: 5295:	case 105: /* stmt: ASGNI4(addr,SUBU4(mem,con1)) */
        -: 5296:	case 104: /* stmt: ASGNI4(addr,SUBI4(mem,con1)) */
        -: 5297:	case 103: /* stmt: ASGNP4(addr,ADDP4(mem,con1)) */
        -: 5298:	case 102: /* stmt: ASGNI4(addr,ADDU4(mem,con1)) */
        -: 5299:	case 101: /* stmt: ASGNI4(addr,ADDI4(mem,con1)) */
    #####: 5300:		kids[0] = LEFT_CHILD(p);
    #####: 5301:		kids[1] = LEFT_CHILD(RIGHT_CHILD(p));
    #####: 5302:		kids[2] = RIGHT_CHILD(RIGHT_CHILD(p));
    #####: 5303:		break;
        -: 5304:	case 175: /* stmt: ASGNF4(addr,CVFF4(reg)) */
        -: 5305:	case 167: /* stmt: ASGNB(reg,INDIRB(reg)) */
        -: 5306:	case 122: /* stmt: ASGNI4(addr,NEGI4(mem)) */
        -: 5307:	case 121: /* stmt: ASGNU4(addr,BCOMU4(mem)) */
        -: 5308:	case 120: /* stmt: ASGNI4(addr,BCOMI4(mem)) */
    #####: 5309:		kids[0] = LEFT_CHILD(p);
    #####: 5310:		kids[1] = LEFT_CHILD(RIGHT_CHILD(p));
    #####: 5311:		break;
        -: 5312:	case 193: /* reg: CVIF8(INDIRI4(addr)) */
        -: 5313:	case 171: /* memf: CVFF8(INDIRF4(addr)) */
        -: 5314:	case 168: /* stmt: ARGB(INDIRB(reg)) */
        -: 5315:	case 148: /* reg: CVUU4(INDIRU2(addr)) */
        -: 5316:	case 147: /* reg: CVUU4(INDIRU1(addr)) */
        -: 5317:	case 146: /* reg: CVII4(INDIRI2(addr)) */
        -: 5318:	case 145: /* reg: CVII4(INDIRI1(addr)) */
    #####: 5319:		kids[0] = LEFT_CHILD(LEFT_CHILD(p));
    #####: 5320:		break;
        -: 5321:	default:
    #####: 5322:		fatal("_kids", "Bad rule number %d\n", eruleno);
        -: 5323:	}
        -: 5324:}
        -: 5325:
function progbeg called 0 returned 0% blocks executed 0%
    #####: 5326:static void progbeg(int argc, char *argv[]) {
    #####: 5327:        int i;
        -: 5328:
        -: 5329:        {
        -: 5330:                union {
        -: 5331:                        char c;
        -: 5332:                        int i;
    #####: 5333:                } u;
    #####: 5334:                u.i = 0;
    #####: 5335:                u.c = 1;
    #####: 5336:                swap = ((int)(u.i == 1)) != IR->little_endian;
        -: 5337:        }
    #####: 5338:        parseflags(argc, argv);
    #####: 5339:        intreg[EAX] = mkreg("eax", EAX, 1, IREG);
    #####: 5340:        intreg[EDX] = mkreg("edx", EDX, 1, IREG);
    #####: 5341:        intreg[ECX] = mkreg("ecx", ECX, 1, IREG);
    #####: 5342:        intreg[EBX] = mkreg("ebx", EBX, 1, IREG);
    #####: 5343:        intreg[ESI] = mkreg("esi", ESI, 1, IREG);
    #####: 5344:        intreg[EDI] = mkreg("edi", EDI, 1, IREG);
        -: 5345:
    #####: 5346:        shortreg[EAX] = mkreg("ax", EAX, 1, IREG);
    #####: 5347:        shortreg[ECX] = mkreg("cx", ECX, 1, IREG);
    #####: 5348:        shortreg[EDX] = mkreg("dx", EDX, 1, IREG);
    #####: 5349:        shortreg[EBX] = mkreg("bx", EBX, 1, IREG);
    #####: 5350:        shortreg[ESI] = mkreg("si", ESI, 1, IREG);
    #####: 5351:        shortreg[EDI] = mkreg("di", EDI, 1, IREG);
        -: 5352:
    #####: 5353:        charreg[EAX]  = mkreg("al", EAX, 1, IREG);
    #####: 5354:        charreg[ECX]  = mkreg("cl", ECX, 1, IREG);
    #####: 5355:        charreg[EDX]  = mkreg("dl", EDX, 1, IREG);
    #####: 5356:        charreg[EBX]  = mkreg("bl", EBX, 1, IREG);
    #####: 5357:        for (i = 0; i < 8; i++)
    #####: 5358:                fltreg[i] = mkreg("%d", i, 0, FREG);
    #####: 5359:        charregw = mkwildcard(charreg);
    #####: 5360:        shortregw = mkwildcard(shortreg);
    #####: 5361:        intregw = mkwildcard(intreg);
    #####: 5362:        fltregw = mkwildcard(fltreg);
        -: 5363:
    #####: 5364:        tmask[IREG] = (1<<EDI) | (1<<ESI) | (1<<EBX)
        -: 5365:                    | (1<<EDX) | (1<<ECX) | (1<<EAX);
    #####: 5366:        vmask[IREG] = 0;
    #####: 5367:        tmask[FREG] = 0xff;
    #####: 5368:        vmask[FREG] = 0;
    #####: 5369:        print(".486\n");
    #####: 5370:        print(".model flat\n");
    #####: 5371:        print("extrn __fltused:near\n");
    #####: 5372:        print("extrn __ftol:near\n");
    #####: 5373:        cseg = 0;
    #####: 5374:        quo = mkreg("eax", EAX, 1, IREG);
    #####: 5375:        quo->x.regnode->mask |= 1<<EDX;
    #####: 5376:        rem = mkreg("edx", EDX, 1, IREG);
    #####: 5377:        rem->x.regnode->mask |= 1<<EAX;
        -: 5378:}
function rmap called 0 returned 0% blocks executed 0%
    #####: 5379:static Symbol rmap(int opk) {
    #####: 5380:        switch (optype(opk)) {
        -: 5381:        case B: case P:
    #####: 5382:                return intregw;
        -: 5383:        case I: case U:
    #####: 5384:                if (opsize(opk) == 1)
    #####: 5385:                        return charregw;
    #####: 5386:                else if (opsize(opk) == 2)
    #####: 5387:                        return shortregw;
        -: 5388:                else
    #####: 5389:                        return intregw;
        -: 5390:        case F:
    #####: 5391:                return fltregw;
        -: 5392:        default:
    #####: 5393:                return 0;
        -: 5394:        }
        -: 5395:}
function segment called 0 returned 0% blocks executed 0%
    #####: 5396:static void segment(int n) {
    #####: 5397:        if (n == cseg)
    #####: 5398:                return;
    #####: 5399:        if (cseg == CODE || cseg == LIT)
    #####: 5400:                print("_TEXT ends\n");
    #####: 5401:        else if (cseg == DATA || cseg == BSS)
    #####: 5402:                print("_DATA ends\n");
    #####: 5403:        cseg = n;
    #####: 5404:        if (cseg == CODE || cseg == LIT)
    #####: 5405:                print("_TEXT segment\n");
    #####: 5406:        else if (cseg == DATA || cseg == BSS)
    #####: 5407:                print("_DATA segment\n");
        -: 5408:}
function progend called 0 returned 0% blocks executed 0%
    #####: 5409:static void progend(void) {
    #####: 5410:        segment(0);
    #####: 5411:        print("end\n");
        -: 5412:}
function target called 0 returned 0% blocks executed 0%
    #####: 5413:static void target(Node p) {
    #####: 5414:        assert(p);
    #####: 5415:        switch (specific(p->op)) {
        -: 5416:        case MUL+U:
    #####: 5417:                setreg(p, quo);
    #####: 5418:                rtarget(p, 0, intreg[EAX]);
    #####: 5419:                break;
        -: 5420:        case DIV+I: case DIV+U:
    #####: 5421:                setreg(p, quo);
    #####: 5422:                rtarget(p, 0, quo);
    #####: 5423:                break;
        -: 5424:        case MOD+I: case MOD+U:
    #####: 5425:                setreg(p, rem);
    #####: 5426:                rtarget(p, 0, quo);
    #####: 5427:                break;
        -: 5428:        case ASGN+B:
    #####: 5429:                rtarget(p, 0, intreg[EDI]);
    #####: 5430:                rtarget(p->kids[1], 0, intreg[ESI]);
    #####: 5431:                break;
        -: 5432:        case ARG+B:
    #####: 5433:                rtarget(p->kids[0], 0, intreg[ESI]);
    #####: 5434:                break;
        -: 5435:        case CVF+I:
    #####: 5436:                setreg(p, intreg[EAX]);
    #####: 5437:                break;
        -: 5438:        case CALL+I: case CALL+U: case CALL+P: case CALL+V:
    #####: 5439:                setreg(p, intreg[EAX]);
    #####: 5440:                break;
        -: 5441:        case RET+I: case RET+U: case RET+P:
    #####: 5442:                rtarget(p, 0, intreg[EAX]);
    #####: 5443:                break;
        -: 5444:        }
        -: 5445:}
        -: 5446:
function clobber called 0 returned 0% blocks executed 0%
    #####: 5447:static void clobber(Node p) {
    #####: 5448:        static int nstack = 0;
        -: 5449:
    #####: 5450:        assert(p);
    #####: 5451:        nstack = ckstack(p, nstack);
    #####: 5452:        switch (specific(p->op)) {
        -: 5453:        case RSH+I: case RSH+U: case LSH+I: case LSH+U:
    #####: 5454:                if (generic(p->kids[1]->op) != CNST
        -: 5455:                && !(   generic(p->kids[1]->op) == INDIR
        -: 5456:                     && specific(p->kids[1]->kids[0]->op) == VREG+P
        -: 5457:                     && p->kids[1]->syms[RX]->u.t.cse
        -: 5458:                     && generic(p->kids[1]->syms[RX]->u.t.cse->op) == CNST
        -: 5459:)) {
    #####: 5460:                        spill(1<<ECX, 1, p);
        -: 5461:                }
    #####: 5462:                break;
        -: 5463:        case ASGN+B: case ARG+B:
    #####: 5464:                spill(1<<ECX | 1<<ESI | 1<<EDI, IREG, p);
    #####: 5465:                break;
        -: 5466:        case EQ+F: case LE+F: case GE+F: case LT+F: case GT+F: case NE+F:
    #####: 5467:                spill(1<<EAX, IREG, p);
    #####: 5468:                break;
        -: 5469:        case CALL+F:
    #####: 5470:                spill(1<<EDX | 1<<EAX | 1<<ECX, IREG, p);
    #####: 5471:                break;
        -: 5472:        case CALL+I: case CALL+U: case CALL+P: case CALL+V:
    #####: 5473:                spill(1<<EDX | 1<<ECX, IREG, p);
    #####: 5474:                break;
        -: 5475:        }
        -: 5476:}
        -: 5477:#define isfp(p) (optype((p)->op)==F)
        -: 5478:
function ckstack called 5 returned 100% blocks executed 56%
        5: 5479:int ckstack(Node p, int n) {
        5: 5480:        int i;
        -: 5481:
        8: 5482:        for (i = 0; i < NELEMS(p->x.kids) && p->x.kids[i]; i++)
        3: 5483:                if (isfp(p->x.kids[i]))
    #####: 5484:                        n--;
        5: 5485:        if (isfp(p) && p->count > 0)
    #####: 5486:                n++;
        5: 5487:        if (n > 8)
    #####: 5488:                error("expression too complicated\n");
        5: 5489:        debug(fprint(stderr, "(ckstack(%x)=%d)\n", p, n));
        5: 5490:        assert(n >= 0);
        5: 5491:        return n;
        -: 5492:}
function memop called 0 returned 0% blocks executed 0%
    #####: 5493:int memop(Node p) {
    #####: 5494:        assert(p);
    #####: 5495:        assert(generic(p->op) == ASGN);
    #####: 5496:        assert(p->kids[0]);
    #####: 5497:        assert(p->kids[1]);
    #####: 5498:        if (generic(p->kids[1]->kids[0]->op) == INDIR
        -: 5499:        && sametree(p->kids[0], p->kids[1]->kids[0]->kids[0]))
    #####: 5500:                return 3;
        -: 5501:        else
    #####: 5502:                return LBURG_MAX;
        -: 5503:}
function sametree called 0 returned 0% blocks executed 0%
    #####: 5504:int sametree(Node p, Node q) {
    #####: 5505:        return p == NULL && q == NULL
        -: 5506:        || p && q && p->op == q->op && p->syms[0] == q->syms[0]
        -: 5507:                && sametree(p->kids[0], q->kids[0])
        -: 5508:                && sametree(p->kids[1], q->kids[1]);
        -: 5509:}
function emit2 called 0 returned 0% blocks executed 0%
    #####: 5510:static void emit2(Node p) {
    #####: 5511:        int op = specific(p->op);
        -: 5512:#define preg(f) ((f)[getregnum(p->x.kids[0])]->x.name)
        -: 5513:
    #####: 5514:        if (op == CVI+I && opsize(p->op) == 4 && opsize(p->x.kids[0]->op) == 1)
    #####: 5515:                print("movsx %s,%s\n", p->syms[RX]->x.name
        -: 5516:, preg(charreg));
    #####: 5517:        else if (op == CVI+U && opsize(p->op) == 4 && opsize(p->x.kids[0]->op) == 1)
    #####: 5518:                print("movsx %s,%s\n", p->syms[RX]->x.name
        -: 5519:, preg(charreg));
    #####: 5520:        else if (op == CVI+I && opsize(p->op) == 4 && opsize(p->x.kids[0]->op) == 2)
    #####: 5521:                print("movsx %s,%s\n", p->syms[RX]->x.name
        -: 5522:, preg(shortreg));
    #####: 5523:        else if (op == CVI+U && opsize(p->op) == 4 && opsize(p->x.kids[0]->op) == 2)
    #####: 5524:                print("movsx %s,%s\n", p->syms[RX]->x.name
        -: 5525:, preg(shortreg));
        -: 5526:
    #####: 5527:        else if (op == CVU+I && opsize(p->op) == 4 && opsize(p->x.kids[0]->op) == 1)
    #####: 5528:                print("movzx %s,%s\n", p->syms[RX]->x.name
        -: 5529:, preg(charreg));
    #####: 5530:        else if (op == CVU+U && opsize(p->op) == 4 && opsize(p->x.kids[0]->op) == 1)
    #####: 5531:                print("movzx %s,%s\n", p->syms[RX]->x.name
        -: 5532:, preg(charreg));
    #####: 5533:        else if (op == CVU+I && opsize(p->op) == 4 && opsize(p->x.kids[0]->op) == 2)
    #####: 5534:                print("movzx %s,%s\n", p->syms[RX]->x.name
        -: 5535:, preg(shortreg));
    #####: 5536:        else if (op == CVU+U && opsize(p->op) == 4 && opsize(p->x.kids[0]->op) == 2)
    #####: 5537:                print("movzx %s,%s\n", p->syms[RX]->x.name
        -: 5538:, preg(shortreg));
    #####: 5539:        else if (generic(op) == CVI || generic(op) == CVU || generic(op) == LOAD) {
    #####: 5540:                char *dst = intreg[getregnum(p)]->x.name;
    #####: 5541:                char *src = preg(intreg);
    #####: 5542:                assert(opsize(p->op) <= opsize(p->x.kids[0]->op));
    #####: 5543:                if (dst != src)
    #####: 5544:                        print("mov %s,%s\n", dst, src);
        -: 5545:        }
        -: 5546:}
        -: 5547:
function doarg called 0 returned 0% blocks executed 0%
    #####: 5548:static void doarg(Node p) {
    #####: 5549:        assert(p && p->syms[0]);
    #####: 5550:        mkactual(4, p->syms[0]->u.c.v.i);
        -: 5551:}
function blkfetch called 0 returned 0% blocks executed 0%
    #####: 5552:static void blkfetch(int k, int off, int reg, int tmp) {}
function blkstore called 0 returned 0% blocks executed 0%
    #####: 5553:static void blkstore(int k, int off, int reg, int tmp) {}
        -: 5554:static void blkloop(int dreg, int doff, int sreg, int soff,
function blkloop called 0 returned 0% blocks executed 0%
    #####: 5555:        int size, int tmps[]) {}
function local called 0 returned 0% blocks executed 0%
    #####: 5556:static void local(Symbol p) {
    #####: 5557:        if (isfloat(p->type))
    #####: 5558:                p->sclass = AUTO;
    #####: 5559:        if (askregvar(p, (*IR->x.rmap)(ttob(p->type))) == 0)
    #####: 5560:                mkauto(p);
        -: 5561:}
function function called 0 returned 0% blocks executed 0%
    #####: 5562:static void function(Symbol f, Symbol caller[], Symbol callee[], int n) {
    #####: 5563:        int i;
        -: 5564:
    #####: 5565:        print("%s:\n", f->x.name);
    #####: 5566:        print("push ebx\n");
    #####: 5567:        print("push esi\n");
    #####: 5568:        print("push edi\n");
    #####: 5569:        print("push ebp\n");
    #####: 5570:        print("mov ebp,esp\n");
    #####: 5571:        usedmask[0] = usedmask[1] = 0;
    #####: 5572:        freemask[0] = freemask[1] = ~(unsigned)0;
    #####: 5573:        offset = 16 + 4;
    #####: 5574:        for (i = 0; callee[i]; i++) {
    #####: 5575:                Symbol p = callee[i];
    #####: 5576:                Symbol q = caller[i];
    #####: 5577:                assert(q);
    #####: 5578:                p->x.offset = q->x.offset = offset;
    #####: 5579:                p->x.name = q->x.name = stringf("%d", p->x.offset);
    #####: 5580:                p->sclass = q->sclass = AUTO;
    #####: 5581:                offset += roundup(q->type->size, 4);
        -: 5582:        }
    #####: 5583:        assert(caller[i] == 0);
    #####: 5584:        offset = maxoffset = 0;
    #####: 5585:        gencode(caller, callee);
    #####: 5586:        framesize = roundup(maxoffset, 4);
    #####: 5587:        if (framesize > 0)
    #####: 5588:                print("sub esp,%d\n", framesize);
    #####: 5589:        emitcode();
    #####: 5590:        print("mov esp,ebp\n");
    #####: 5591:        print("pop ebp\n");
    #####: 5592:        print("pop edi\n");
    #####: 5593:        print("pop esi\n");
    #####: 5594:        print("pop ebx\n");
    #####: 5595:        print("ret\n");
        -: 5596:}
function defsymbol called 0 returned 0% blocks executed 0%
    #####: 5597:static void defsymbol(Symbol p) {
    #####: 5598:        if (p->scope >= LOCAL && p->sclass == STATIC)
    #####: 5599:                p->x.name = stringf("L%d", genlabel(1));
    #####: 5600:        else if (p->generated)
    #####: 5601:                p->x.name = stringf("L%s", p->name);
    #####: 5602:        else if (p->scope == GLOBAL || p->sclass == EXTERN)
    #####: 5603:                p->x.name = stringf("_%s", p->name);
    #####: 5604:        else if (p->scope == CONSTANTS
        -: 5605:        && (isint(p->type) || isptr(p->type))
        -: 5606:        && p->name[0] == '0' && p->name[1] == 'x')
    #####: 5607:                p->x.name = stringf("0%sH", &p->name[2]);
        -: 5608:        else
    #####: 5609:                p->x.name = p->name;
        -: 5610:}
function address called 0 returned 0% blocks executed 0%
    #####: 5611:static void address(Symbol q, Symbol p, long n) {
    #####: 5612:        if (p->scope == GLOBAL
        -: 5613:        || p->sclass == STATIC || p->sclass == EXTERN)
    #####: 5614:                q->x.name = stringf("%s%s%D",
        -: 5615:                        p->x.name, n >= 0 ? "+" : "", n);
        -: 5616:        else {
    #####: 5617:                assert(n <= INT_MAX && n >= INT_MIN);
    #####: 5618:                q->x.offset = p->x.offset + n;
    #####: 5619:                q->x.name = stringd(q->x.offset);
        -: 5620:        }
        -: 5621:}
function defconst called 0 returned 0% blocks executed 0%
    #####: 5622:static void defconst(int suffix, int size, Value v) {
    #####: 5623:        if (suffix == I && size == 1)
    #####: 5624:                print("db %d\n",   v.u);
    #####: 5625:        else if (suffix == I && size == 2)
    #####: 5626:                print("dw %d\n",   v.i);
    #####: 5627:        else if (suffix == I && size == 4)
    #####: 5628:                print("dd %d\n",   v.i);
    #####: 5629:        else if (suffix == U && size == 1)
    #####: 5630:                print("db 0%xH\n", v.u);
    #####: 5631:        else if (suffix == U && size == 2)
    #####: 5632:                print("dw 0%xH\n", v.u);
    #####: 5633:        else if (suffix == U && size == 4)
    #####: 5634:                print("dd 0%xH\n", v.u);
    #####: 5635:        else if (suffix == P && size == 4)
    #####: 5636:                print("dd 0%xH\n", v.p);
    #####: 5637:        else if (suffix == F && size == 4) {
    #####: 5638:                float f = v.d;
    #####: 5639:                print("dd 0%xH\n", *(unsigned *)&f);
        -: 5640:        }
    #####: 5641:        else if (suffix == F && size == 8) {
    #####: 5642:                double d = v.d;
    #####: 5643:                unsigned *p = (unsigned *)&d;
    #####: 5644:                print("dd 0%xH\ndd 0%xH\n", p[swap], p[!swap]);
        -: 5645:        }
    #####: 5646:        else assert(0);
        -: 5647:}
function defaddress called 0 returned 0% blocks executed 0%
    #####: 5648:static void defaddress(Symbol p) {
    #####: 5649:        print("dd %s\n", p->x.name);
        -: 5650:}
function defstring called 0 returned 0% blocks executed 0%
    #####: 5651:static void defstring(int n, char *str) {
    #####: 5652:        char *s;
        -: 5653:
    #####: 5654:        for (s = str; s < str + n; s++)
    #####: 5655:                print("db %d\n", (*s)&0377);
        -: 5656:}
function export called 0 returned 0% blocks executed 0%
    #####: 5657:static void export(Symbol p) {
    #####: 5658:        print("public %s\n", p->x.name);
        -: 5659:}
function import called 0 returned 0% blocks executed 0%
    #####: 5660:static void import(Symbol p) {
    #####: 5661:        int oldseg = cseg;
        -: 5662:
    #####: 5663:        if (p->ref > 0) {
    #####: 5664:                segment(0);
    #####: 5665:                print("extrn %s:near\n", p->x.name);
    #####: 5666:                segment(oldseg);
        -: 5667:        }
        -: 5668:}
function global called 0 returned 0% blocks executed 0%
    #####: 5669:static void global(Symbol p) {
    #####: 5670:        print("align %d\n",
        -: 5671:                p->type->align > 4 ? 4 : p->type->align);
    #####: 5672:        print("%s label byte\n", p->x.name);
    #####: 5673:        if (p->u.seg == BSS)
    #####: 5674:                print("db %d dup (0)\n", p->type->size);
        -: 5675:}
function space called 0 returned 0% blocks executed 0%
    #####: 5676:static void space(int n) {
    #####: 5677:        if (cseg != BSS)
    #####: 5678:                print("db %d dup (0)\n", n);
        -: 5679:}
        -: 5680:Interface x86IR = {
        -: 5681:        1, 1, 0,  /* char */
        -: 5682:        2, 2, 0,  /* short */
        -: 5683:        4, 4, 0,  /* int */
        -: 5684:        4, 4, 0,  /* long */
        -: 5685:        4, 4, 0,  /* long long */
        -: 5686:        4, 4, 1,  /* float */
        -: 5687:        8, 4, 1,  /* double */
        -: 5688:        8, 4, 1,  /* long double */
        -: 5689:        4, 4, 0,  /* T * */
        -: 5690:        0, 4, 0,  /* struct; so that ARGB keeps stack aligned */
        -: 5691:        1,        /* little_endian */
        -: 5692:        0,        /* mulops_calls */
        -: 5693:        0,        /* wants_callb */
        -: 5694:        1,        /* wants_argb */
        -: 5695:        0,        /* left_to_right */
        -: 5696:        0,        /* wants_dag */
        -: 5697:        0,        /* unsigned_char */
        -: 5698:        address,
        -: 5699:        blockbeg,
        -: 5700:        blockend,
        -: 5701:        defaddress,
        -: 5702:        defconst,
        -: 5703:        defstring,
        -: 5704:        defsymbol,
        -: 5705:        emit,
        -: 5706:        export,
        -: 5707:        function,
        -: 5708:        gen,
        -: 5709:        global,
        -: 5710:        import,
        -: 5711:        local,
        -: 5712:        progbeg,
        -: 5713:        progend,
        -: 5714:        segment,
        -: 5715:        space,
        -: 5716:        0, 0, 0, 0, 0, 0, 0,
        -: 5717:        {1, rmap,
        -: 5718:            blkfetch, blkstore, blkloop,
        -: 5719:            _label,
        -: 5720:            _rule,
        -: 5721:            _nts,
        -: 5722:            _kids,
        -: 5723:            _string,
        -: 5724:            _templates,
        -: 5725:            _isinstruction,
        -: 5726:            _ntname,
        -: 5727:            emit2,
        -: 5728:            doarg,
        -: 5729:            target,
        -: 5730:            clobber,
        -: 5731:}
        -: 5732:};
        -: 5733:static char rcsid[] = "$Id: x86.nw,v 2.25 1998/07/02 00:26:44 drh Exp $";
