        -:    0:Source:/home/coolbar/Desktop/tmp/lcc-4.1/lcc/x86linux.c
        -:    0:Graph:lcc/x86linux.gcno
        -:    0:Data:lcc/x86linux.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/* x86/linux lburg spec. Derived from x86.md by
        -:    2:Marcos Ramirez <marcos@inf.utfsm.cl>
        -:    3:Horst von Brand <vonbrand@sleipnir.valparaiso.cl>
        -:    4:Jacob Navia <jacob@jacob.remcomp.fr>
        -:    5:*/
        -:    6:enum { EAX=0, ECX=1, EDX=2, EBX=3, ESI=6, EDI=7 };
        -:    7:#include "c.h"
        -:    8:#define NODEPTR_TYPE Node
        -:    9:#define OP_LABEL(p) ((p)->op)
        -:   10:#define LEFT_CHILD(p) ((p)->kids[0])
        -:   11:#define RIGHT_CHILD(p) ((p)->kids[1])
        -:   12:#define STATE_LABEL(p) ((p)->x.state)
        -:   13:extern int ckstack(Node, int);
        -:   14:extern int memop(Node);
        -:   15:extern int sametree(Node, Node);
        -:   16:static Symbol charreg[32], shortreg[32], intreg[32];
        -:   17:static Symbol fltreg[32];
        -:   18:
        -:   19:static Symbol charregw, shortregw, intregw, fltregw;
        -:   20:
        -:   21:static int cseg;
        -:   22:
        -:   23:static Symbol quo, rem;
        -:   24:
        -:   25:extern char *stabprefix;
        -:   26:extern void stabblock(int, int, Symbol*);
        -:   27:extern void stabend(Coordinate *, Symbol, Coordinate **, Symbol *, Symbol *);
        -:   28:extern void stabfend(Symbol, int);
        -:   29:extern void stabinit(char *, int, char *[]);
        -:   30:extern void stabline(Coordinate *);
        -:   31:extern void stabsym(Symbol);
        -:   32:extern void stabtype(Symbol);
        -:   33:
        -:   34:static int pflag = 0;
        -:   35:static char rcsid[] = "$Id: x86.nw,v 2.25 1998/07/02 00:26:44 drh Exp $";
        -:   36:
        -:   37:#define hasargs(p) (p->syms[0] && p->syms[0]->u.c.v.i > 0 ? 0 : LBURG_MAX)
        -:   38:/*
        -:   39:generated at Tue Dec 13 00:36:43 2011
        -:   40:by $Id: lburg.c,v 2.8 1997/10/30 23:41:10 drh Exp $
        -:   41:*/
        -:   42:static void _kids(NODEPTR_TYPE, int, NODEPTR_TYPE[]);
        -:   43:static void _label(NODEPTR_TYPE);
        -:   44:static int _rule(void*, int);
        -:   45:
        -:   46:#define _stmt_NT 1
        -:   47:#define _reg_NT 2
        -:   48:#define _freg_NT 3
        -:   49:#define _cnst_NT 4
        -:   50:#define _con_NT 5
        -:   51:#define _acon_NT 6
        -:   52:#define _baseaddr_NT 7
        -:   53:#define _base_NT 8
        -:   54:#define _index_NT 9
        -:   55:#define _con1_NT 10
        -:   56:#define _con2_NT 11
        -:   57:#define _con3_NT 12
        -:   58:#define _con0_NT 13
        -:   59:#define _addr_NT 14
        -:   60:#define _mem1_NT 15
        -:   61:#define _mem2_NT 16
        -:   62:#define _mem4_NT 17
        -:   63:#define _rc_NT 18
        -:   64:#define _mr_NT 19
        -:   65:#define _mr1_NT 20
        -:   66:#define _mr2_NT 21
        -:   67:#define _mrc_NT 22
        -:   68:#define _rc5_NT 23
        -:   69:#define _mrca_NT 24
        -:   70:#define _memf_NT 25
        -:   71:#define _flt_NT 26
        -:   72:#define _addrj_NT 27
        -:   73:#define _cmpf_NT 28
        -:   74:
        -:   75:static char *_ntname[] = {
        -:   76:	0,
        -:   77:	"stmt",
        -:   78:	"reg",
        -:   79:	"freg",
        -:   80:	"cnst",
        -:   81:	"con",
        -:   82:	"acon",
        -:   83:	"baseaddr",
        -:   84:	"base",
        -:   85:	"index",
        -:   86:	"con1",
        -:   87:	"con2",
        -:   88:	"con3",
        -:   89:	"con0",
        -:   90:	"addr",
        -:   91:	"mem1",
        -:   92:	"mem2",
        -:   93:	"mem4",
        -:   94:	"rc",
        -:   95:	"mr",
        -:   96:	"mr1",
        -:   97:	"mr2",
        -:   98:	"mrc",
        -:   99:	"rc5",
        -:  100:	"mrca",
        -:  101:	"memf",
        -:  102:	"flt",
        -:  103:	"addrj",
        -:  104:	"cmpf",
        -:  105:	0
        -:  106:};
        -:  107:
        -:  108:struct _state {
        -:  109:	short cost[29];
        -:  110:	struct {
        -:  111:		unsigned int _stmt:7;
        -:  112:		unsigned int _reg:7;
        -:  113:		unsigned int _freg:6;
        -:  114:		unsigned int _cnst:4;
        -:  115:		unsigned int _con:1;
        -:  116:		unsigned int _acon:2;
        -:  117:		unsigned int _baseaddr:1;
        -:  118:		unsigned int _base:3;
        -:  119:		unsigned int _index:3;
        -:  120:		unsigned int _con1:2;
        -:  121:		unsigned int _con2:2;
        -:  122:		unsigned int _con3:2;
        -:  123:		unsigned int _con0:2;
        -:  124:		unsigned int _addr:4;
        -:  125:		unsigned int _mem1:2;
        -:  126:		unsigned int _mem2:2;
        -:  127:		unsigned int _mem4:2;
        -:  128:		unsigned int _rc:2;
        -:  129:		unsigned int _mr:2;
        -:  130:		unsigned int _mr1:2;
        -:  131:		unsigned int _mr2:2;
        -:  132:		unsigned int _mrc:3;
        -:  133:		unsigned int _rc5:2;
        -:  134:		unsigned int _mrca:3;
        -:  135:		unsigned int _memf:3;
        -:  136:		unsigned int _flt:2;
        -:  137:		unsigned int _addrj:2;
        -:  138:		unsigned int _cmpf:3;
        -:  139:	} rule;
        -:  140:};
        -:  141:
        -:  142:static short _nts_0[] = { 0 };
        -:  143:static short _nts_1[] = { _reg_NT, 0 };
        -:  144:static short _nts_2[] = { _cnst_NT, 0 };
        -:  145:static short _nts_3[] = { _freg_NT, 0 };
        -:  146:static short _nts_4[] = { _reg_NT, _acon_NT, 0 };
        -:  147:static short _nts_5[] = { _reg_NT, _con1_NT, 0 };
        -:  148:static short _nts_6[] = { _reg_NT, _con2_NT, 0 };
        -:  149:static short _nts_7[] = { _reg_NT, _con3_NT, 0 };
        -:  150:static short _nts_8[] = { _base_NT, 0 };
        -:  151:static short _nts_9[] = { _baseaddr_NT, 0 };
        -:  152:static short _nts_10[] = { _index_NT, _baseaddr_NT, 0 };
        -:  153:static short _nts_11[] = { _reg_NT, _baseaddr_NT, 0 };
        -:  154:static short _nts_12[] = { _index_NT, _reg_NT, 0 };
        -:  155:static short _nts_13[] = { _index_NT, 0 };
        -:  156:static short _nts_14[] = { _addr_NT, 0 };
        -:  157:static short _nts_15[] = { _con_NT, 0 };
        -:  158:static short _nts_16[] = { _mem4_NT, 0 };
        -:  159:static short _nts_17[] = { _mem1_NT, 0 };
        -:  160:static short _nts_18[] = { _mem2_NT, 0 };
        -:  161:static short _nts_19[] = { _rc_NT, 0 };
        -:  162:static short _nts_20[] = { _mr_NT, 0 };
        -:  163:static short _nts_21[] = { _mr1_NT, 0 };
        -:  164:static short _nts_22[] = { _mr2_NT, 0 };
        -:  165:static short _nts_23[] = { _reg_NT, _mrc_NT, 0 };
        -:  166:static short _nts_24[] = { _addr_NT, _mem4_NT, _con1_NT, 0 };
        -:  167:static short _nts_25[] = { _addr_NT, _mem4_NT, _rc_NT, 0 };
        -:  168:static short _nts_26[] = { _addr_NT, _mem4_NT, 0 };
        -:  169:static short _nts_27[] = { _reg_NT, _rc5_NT, 0 };
        -:  170:static short _nts_28[] = { _addr_NT, _mem4_NT, _rc5_NT, 0 };
        -:  171:static short _nts_29[] = { _con_NT, _mr_NT, 0 };
        -:  172:static short _nts_30[] = { _reg_NT, _mr_NT, 0 };
        -:  173:static short _nts_31[] = { _reg_NT, _reg_NT, 0 };
        -:  174:static short _nts_32[] = { _addr_NT, _rc_NT, 0 };
        -:  175:static short _nts_33[] = { _mrca_NT, 0 };
        -:  176:static short _nts_34[] = { _memf_NT, 0 };
        -:  177:static short _nts_35[] = { _addr_NT, _freg_NT, 0 };
        -:  178:static short _nts_36[] = { _freg_NT, _flt_NT, 0 };
        -:  179:static short _nts_37[] = { _addrj_NT, 0 };
        -:  180:static short _nts_38[] = { _mem4_NT, _rc_NT, 0 };
        -:  181:static short _nts_39[] = { _mr_NT, _con_NT, _con0_NT, 0 };
        -:  182:static short _nts_40[] = { _addr_NT, _con_NT, _con0_NT, 0 };
        -:  183:static short _nts_41[] = { _cmpf_NT, _freg_NT, 0 };
        -:  184:static short _nts_42[] = { _freg_NT, _addr_NT, 0 };
        -:  185:
        -:  186:static short *_nts[] = {
        -:  187:	0,	/* 0 */
        -:  188:	_nts_0,	/* 1 */
        -:  189:	_nts_0,	/* 2 */
        -:  190:	_nts_0,	/* 3 */
        -:  191:	_nts_0,	/* 4 */
        -:  192:	_nts_0,	/* 5 */
        -:  193:	_nts_0,	/* 6 */
        -:  194:	_nts_0,	/* 7 */
        -:  195:	_nts_0,	/* 8 */
        -:  196:	_nts_0,	/* 9 */
        -:  197:	_nts_0,	/* 10 */
        -:  198:	_nts_0,	/* 11 */
        -:  199:	_nts_0,	/* 12 */
        -:  200:	_nts_1,	/* 13 */
        -:  201:	_nts_1,	/* 14 */
        -:  202:	_nts_1,	/* 15 */
        -:  203:	_nts_1,	/* 16 */
        -:  204:	_nts_1,	/* 17 */
        -:  205:	_nts_1,	/* 18 */
        -:  206:	_nts_1,	/* 19 */
        -:  207:	_nts_1,	/* 20 */
        -:  208:	_nts_1,	/* 21 */
        -:  209:	_nts_1,	/* 22 */
        -:  210:	_nts_1,	/* 23 */
        -:  211:	_nts_1,	/* 24 */
        -:  212:	_nts_0,	/* 25 */
        -:  213:	_nts_0,	/* 26 */
        -:  214:	_nts_0,	/* 27 */
        -:  215:	_nts_0,	/* 28 */
        -:  216:	_nts_0,	/* 29 */
        -:  217:	_nts_0,	/* 30 */
        -:  218:	_nts_0,	/* 31 */
        -:  219:	_nts_0,	/* 32 */
        -:  220:	_nts_0,	/* 33 */
        -:  221:	_nts_0,	/* 34 */
        -:  222:	_nts_2,	/* 35 */
        -:  223:	_nts_1,	/* 36 */
        -:  224:	_nts_3,	/* 37 */
        -:  225:	_nts_0,	/* 38 */
        -:  226:	_nts_0,	/* 39 */
        -:  227:	_nts_2,	/* 40 */
        -:  228:	_nts_0,	/* 41 */
        -:  229:	_nts_1,	/* 42 */
        -:  230:	_nts_4,	/* 43 */
        -:  231:	_nts_4,	/* 44 */
        -:  232:	_nts_4,	/* 45 */
        -:  233:	_nts_0,	/* 46 */
        -:  234:	_nts_0,	/* 47 */
        -:  235:	_nts_1,	/* 48 */
        -:  236:	_nts_5,	/* 49 */
        -:  237:	_nts_6,	/* 50 */
        -:  238:	_nts_7,	/* 51 */
        -:  239:	_nts_5,	/* 52 */
        -:  240:	_nts_6,	/* 53 */
        -:  241:	_nts_7,	/* 54 */
        -:  242:	_nts_0,	/* 55 */
        -:  243:	_nts_0,	/* 56 */
        -:  244:	_nts_0,	/* 57 */
        -:  245:	_nts_0,	/* 58 */
        -:  246:	_nts_0,	/* 59 */
        -:  247:	_nts_0,	/* 60 */
        -:  248:	_nts_0,	/* 61 */
        -:  249:	_nts_0,	/* 62 */
        -:  250:	_nts_8,	/* 63 */
        -:  251:	_nts_9,	/* 64 */
        -:  252:	_nts_10,	/* 65 */
        -:  253:	_nts_10,	/* 66 */
        -:  254:	_nts_10,	/* 67 */
        -:  255:	_nts_11,	/* 68 */
        -:  256:	_nts_11,	/* 69 */
        -:  257:	_nts_11,	/* 70 */
        -:  258:	_nts_12,	/* 71 */
        -:  259:	_nts_12,	/* 72 */
        -:  260:	_nts_12,	/* 73 */
        -:  261:	_nts_13,	/* 74 */
        -:  262:	_nts_14,	/* 75 */
        -:  263:	_nts_14,	/* 76 */
        -:  264:	_nts_14,	/* 77 */
        -:  265:	_nts_14,	/* 78 */
        -:  266:	_nts_14,	/* 79 */
        -:  267:	_nts_14,	/* 80 */
        -:  268:	_nts_14,	/* 81 */
        -:  269:	_nts_1,	/* 82 */
        -:  270:	_nts_15,	/* 83 */
        -:  271:	_nts_1,	/* 84 */
        -:  272:	_nts_16,	/* 85 */
        -:  273:	_nts_1,	/* 86 */
        -:  274:	_nts_17,	/* 87 */
        -:  275:	_nts_1,	/* 88 */
        -:  276:	_nts_18,	/* 89 */
        -:  277:	_nts_16,	/* 90 */
        -:  278:	_nts_17,	/* 91 */
        -:  279:	_nts_18,	/* 92 */
        -:  280:	_nts_19,	/* 93 */
        -:  281:	_nts_14,	/* 94 */
        -:  282:	_nts_20,	/* 95 */
        -:  283:	_nts_21,	/* 96 */
        -:  284:	_nts_22,	/* 97 */
        -:  285:	_nts_15,	/* 98 */
        -:  286:	_nts_1,	/* 99 */
        -:  287:	_nts_1,	/* 100 */
        -:  288:	_nts_1,	/* 101 */
        -:  289:	_nts_1,	/* 102 */
        -:  290:	_nts_1,	/* 103 */
        -:  291:	_nts_1,	/* 104 */
        -:  292:	_nts_1,	/* 105 */
        -:  293:	_nts_23,	/* 106 */
        -:  294:	_nts_23,	/* 107 */
        -:  295:	_nts_23,	/* 108 */
        -:  296:	_nts_23,	/* 109 */
        -:  297:	_nts_23,	/* 110 */
        -:  298:	_nts_23,	/* 111 */
        -:  299:	_nts_23,	/* 112 */
        -:  300:	_nts_23,	/* 113 */
        -:  301:	_nts_23,	/* 114 */
        -:  302:	_nts_23,	/* 115 */
        -:  303:	_nts_23,	/* 116 */
        -:  304:	_nts_23,	/* 117 */
        -:  305:	_nts_24,	/* 118 */
        -:  306:	_nts_24,	/* 119 */
        -:  307:	_nts_24,	/* 120 */
        -:  308:	_nts_24,	/* 121 */
        -:  309:	_nts_24,	/* 122 */
        -:  310:	_nts_24,	/* 123 */
        -:  311:	_nts_25,	/* 124 */
        -:  312:	_nts_25,	/* 125 */
        -:  313:	_nts_25,	/* 126 */
        -:  314:	_nts_25,	/* 127 */
        -:  315:	_nts_25,	/* 128 */
        -:  316:	_nts_25,	/* 129 */
        -:  317:	_nts_25,	/* 130 */
        -:  318:	_nts_25,	/* 131 */
        -:  319:	_nts_25,	/* 132 */
        -:  320:	_nts_25,	/* 133 */
        -:  321:	_nts_1,	/* 134 */
        -:  322:	_nts_1,	/* 135 */
        -:  323:	_nts_1,	/* 136 */
        -:  324:	_nts_26,	/* 137 */
        -:  325:	_nts_26,	/* 138 */
        -:  326:	_nts_26,	/* 139 */
        -:  327:	_nts_27,	/* 140 */
        -:  328:	_nts_27,	/* 141 */
        -:  329:	_nts_27,	/* 142 */
        -:  330:	_nts_27,	/* 143 */
        -:  331:	_nts_28,	/* 144 */
        -:  332:	_nts_28,	/* 145 */
        -:  333:	_nts_28,	/* 146 */
        -:  334:	_nts_28,	/* 147 */
        -:  335:	_nts_0,	/* 148 */
        -:  336:	_nts_1,	/* 149 */
        -:  337:	_nts_23,	/* 150 */
        -:  338:	_nts_29,	/* 151 */
        -:  339:	_nts_30,	/* 152 */
        -:  340:	_nts_31,	/* 153 */
        -:  341:	_nts_31,	/* 154 */
        -:  342:	_nts_31,	/* 155 */
        -:  343:	_nts_31,	/* 156 */
        -:  344:	_nts_1,	/* 157 */
        -:  345:	_nts_1,	/* 158 */
        -:  346:	_nts_14,	/* 159 */
        -:  347:	_nts_14,	/* 160 */
        -:  348:	_nts_14,	/* 161 */
        -:  349:	_nts_14,	/* 162 */
        -:  350:	_nts_1,	/* 163 */
        -:  351:	_nts_1,	/* 164 */
        -:  352:	_nts_1,	/* 165 */
        -:  353:	_nts_1,	/* 166 */
        -:  354:	_nts_1,	/* 167 */
        -:  355:	_nts_1,	/* 168 */
        -:  356:	_nts_1,	/* 169 */
        -:  357:	_nts_1,	/* 170 */
        -:  358:	_nts_16,	/* 171 */
        -:  359:	_nts_19,	/* 172 */
        -:  360:	_nts_0,	/* 173 */
        -:  361:	_nts_0,	/* 174 */
        -:  362:	_nts_32,	/* 175 */
        -:  363:	_nts_32,	/* 176 */
        -:  364:	_nts_32,	/* 177 */
        -:  365:	_nts_32,	/* 178 */
        -:  366:	_nts_32,	/* 179 */
        -:  367:	_nts_32,	/* 180 */
        -:  368:	_nts_32,	/* 181 */
        -:  369:	_nts_33,	/* 182 */
        -:  370:	_nts_33,	/* 183 */
        -:  371:	_nts_33,	/* 184 */
        -:  372:	_nts_31,	/* 185 */
        -:  373:	_nts_1,	/* 186 */
        -:  374:	_nts_14,	/* 187 */
        -:  375:	_nts_14,	/* 188 */
        -:  376:	_nts_14,	/* 189 */
        -:  377:	_nts_14,	/* 190 */
        -:  378:	_nts_34,	/* 191 */
        -:  379:	_nts_35,	/* 192 */
        -:  380:	_nts_35,	/* 193 */
        -:  381:	_nts_35,	/* 194 */
        -:  382:	_nts_3,	/* 195 */
        -:  383:	_nts_3,	/* 196 */
        -:  384:	_nts_3,	/* 197 */
        -:  385:	_nts_3,	/* 198 */
        -:  386:	_nts_34,	/* 199 */
        -:  387:	_nts_3,	/* 200 */
        -:  388:	_nts_36,	/* 201 */
        -:  389:	_nts_36,	/* 202 */
        -:  390:	_nts_36,	/* 203 */
        -:  391:	_nts_36,	/* 204 */
        -:  392:	_nts_36,	/* 205 */
        -:  393:	_nts_36,	/* 206 */
        -:  394:	_nts_36,	/* 207 */
        -:  395:	_nts_36,	/* 208 */
        -:  396:	_nts_3,	/* 209 */
        -:  397:	_nts_3,	/* 210 */
        -:  398:	_nts_35,	/* 211 */
        -:  399:	_nts_3,	/* 212 */
        -:  400:	_nts_14,	/* 213 */
        -:  401:	_nts_1,	/* 214 */
        -:  402:	_nts_14,	/* 215 */
        -:  403:	_nts_1,	/* 216 */
        -:  404:	_nts_0,	/* 217 */
        -:  405:	_nts_1,	/* 218 */
        -:  406:	_nts_16,	/* 219 */
        -:  407:	_nts_0,	/* 220 */
        -:  408:	_nts_37,	/* 221 */
        -:  409:	_nts_38,	/* 222 */
        -:  410:	_nts_38,	/* 223 */
        -:  411:	_nts_38,	/* 224 */
        -:  412:	_nts_38,	/* 225 */
        -:  413:	_nts_38,	/* 226 */
        -:  414:	_nts_38,	/* 227 */
        -:  415:	_nts_38,	/* 228 */
        -:  416:	_nts_38,	/* 229 */
        -:  417:	_nts_38,	/* 230 */
        -:  418:	_nts_38,	/* 231 */
        -:  419:	_nts_23,	/* 232 */
        -:  420:	_nts_23,	/* 233 */
        -:  421:	_nts_23,	/* 234 */
        -:  422:	_nts_23,	/* 235 */
        -:  423:	_nts_23,	/* 236 */
        -:  424:	_nts_23,	/* 237 */
        -:  425:	_nts_23,	/* 238 */
        -:  426:	_nts_23,	/* 239 */
        -:  427:	_nts_23,	/* 240 */
        -:  428:	_nts_23,	/* 241 */
        -:  429:	_nts_23,	/* 242 */
        -:  430:	_nts_23,	/* 243 */
        -:  431:	_nts_39,	/* 244 */
        -:  432:	_nts_39,	/* 245 */
        -:  433:	_nts_40,	/* 246 */
        -:  434:	_nts_40,	/* 247 */
        -:  435:	_nts_40,	/* 248 */
        -:  436:	_nts_40,	/* 249 */
        -:  437:	_nts_40,	/* 250 */
        -:  438:	_nts_14,	/* 251 */
        -:  439:	_nts_14,	/* 252 */
        -:  440:	_nts_14,	/* 253 */
        -:  441:	_nts_3,	/* 254 */
        -:  442:	_nts_41,	/* 255 */
        -:  443:	_nts_41,	/* 256 */
        -:  444:	_nts_41,	/* 257 */
        -:  445:	_nts_41,	/* 258 */
        -:  446:	_nts_41,	/* 259 */
        -:  447:	_nts_41,	/* 260 */
        -:  448:	_nts_41,	/* 261 */
        -:  449:	_nts_41,	/* 262 */
        -:  450:	_nts_41,	/* 263 */
        -:  451:	_nts_41,	/* 264 */
        -:  452:	_nts_41,	/* 265 */
        -:  453:	_nts_41,	/* 266 */
        -:  454:	_nts_42,	/* 267 */
        -:  455:	_nts_35,	/* 268 */
        -:  456:	_nts_42,	/* 269 */
        -:  457:	_nts_35,	/* 270 */
        -:  458:	_nts_42,	/* 271 */
        -:  459:	_nts_42,	/* 272 */
        -:  460:	_nts_42,	/* 273 */
        -:  461:	_nts_35,	/* 274 */
        -:  462:	_nts_42,	/* 275 */
        -:  463:	_nts_35,	/* 276 */
        -:  464:	_nts_42,	/* 277 */
        -:  465:	_nts_42,	/* 278 */
        -:  466:	_nts_42,	/* 279 */
        -:  467:	_nts_42,	/* 280 */
        -:  468:	_nts_42,	/* 281 */
        -:  469:	_nts_42,	/* 282 */
        -:  470:	_nts_34,	/* 283 */
        -:  471:	_nts_37,	/* 284 */
        -:  472:	_nts_37,	/* 285 */
        -:  473:	_nts_37,	/* 286 */
        -:  474:	_nts_37,	/* 287 */
        -:  475:	_nts_37,	/* 288 */
        -:  476:	_nts_37,	/* 289 */
        -:  477:	_nts_37,	/* 290 */
        -:  478:	_nts_37,	/* 291 */
        -:  479:	_nts_37,	/* 292 */
        -:  480:	_nts_37,	/* 293 */
        -:  481:	_nts_37,	/* 294 */
        -:  482:	_nts_37,	/* 295 */
        -:  483:	_nts_37,	/* 296 */
        -:  484:	_nts_37,	/* 297 */
        -:  485:	_nts_37,	/* 298 */
        -:  486:	_nts_37,	/* 299 */
        -:  487:	_nts_1,	/* 300 */
        -:  488:	_nts_1,	/* 301 */
        -:  489:	_nts_1,	/* 302 */
        -:  490:	_nts_3,	/* 303 */
        -:  491:	_nts_3,	/* 304 */
        -:  492:};
        -:  493:
        -:  494:static char *_templates[] = {
        -:  495:/* 0 */	0,
        -:  496:/* 1 */	"# read register\n",	/* reg: INDIRI1(VREGP) */
        -:  497:/* 2 */	"# read register\n",	/* reg: INDIRU1(VREGP) */
        -:  498:/* 3 */	"# read register\n",	/* reg: INDIRI2(VREGP) */
        -:  499:/* 4 */	"# read register\n",	/* reg: INDIRU2(VREGP) */
        -:  500:/* 5 */	"# read register\n",	/* reg: INDIRI4(VREGP) */
        -:  501:/* 6 */	"# read register\n",	/* reg: INDIRP4(VREGP) */
        -:  502:/* 7 */	"# read register\n",	/* reg: INDIRU4(VREGP) */
        -:  503:/* 8 */	"# read register\n",	/* reg: INDIRI8(VREGP) */
        -:  504:/* 9 */	"# read register\n",	/* reg: INDIRP8(VREGP) */
        -:  505:/* 10 */	"# read register\n",	/* reg: INDIRU8(VREGP) */
        -:  506:/* 11 */	"# read register\n",	/* freg: INDIRF4(VREGP) */
        -:  507:/* 12 */	"# read register\n",	/* freg: INDIRF8(VREGP) */
        -:  508:/* 13 */	"# write register\n",	/* stmt: ASGNI1(VREGP,reg) */
        -:  509:/* 14 */	"# write register\n",	/* stmt: ASGNU1(VREGP,reg) */
        -:  510:/* 15 */	"# write register\n",	/* stmt: ASGNI2(VREGP,reg) */
        -:  511:/* 16 */	"# write register\n",	/* stmt: ASGNU2(VREGP,reg) */
        -:  512:/* 17 */	"# write register\n",	/* stmt: ASGNF4(VREGP,reg) */
        -:  513:/* 18 */	"# write register\n",	/* stmt: ASGNI4(VREGP,reg) */
        -:  514:/* 19 */	"# write register\n",	/* stmt: ASGNP4(VREGP,reg) */
        -:  515:/* 20 */	"# write register\n",	/* stmt: ASGNU4(VREGP,reg) */
        -:  516:/* 21 */	"# write register\n",	/* stmt: ASGNF8(VREGP,reg) */
        -:  517:/* 22 */	"# write register\n",	/* stmt: ASGNI8(VREGP,reg) */
        -:  518:/* 23 */	"# write register\n",	/* stmt: ASGNP8(VREGP,reg) */
        -:  519:/* 24 */	"# write register\n",	/* stmt: ASGNU8(VREGP,reg) */
        -:  520:/* 25 */	"%a",	/* cnst: CNSTI1 */
        -:  521:/* 26 */	"%a",	/* cnst: CNSTU1 */
        -:  522:/* 27 */	"%a",	/* cnst: CNSTI2 */
        -:  523:/* 28 */	"%a",	/* cnst: CNSTU2 */
        -:  524:/* 29 */	"%a",	/* cnst: CNSTI4 */
        -:  525:/* 30 */	"%a",	/* cnst: CNSTU4 */
        -:  526:/* 31 */	"%a",	/* cnst: CNSTP4 */
        -:  527:/* 32 */	"%a",	/* cnst: CNSTI8 */
        -:  528:/* 33 */	"%a",	/* cnst: CNSTU8 */
        -:  529:/* 34 */	"%a",	/* cnst: CNSTP8 */
        -:  530:/* 35 */	"$%0",	/* con: cnst */
        -:  531:/* 36 */	"",	/* stmt: reg */
        -:  532:/* 37 */	"",	/* stmt: freg */
        -:  533:/* 38 */	"%a",	/* acon: ADDRGP4 */
        -:  534:/* 39 */	"%a",	/* acon: ADDRGP8 */
        -:  535:/* 40 */	"%0",	/* acon: cnst */
        -:  536:/* 41 */	"%a",	/* baseaddr: ADDRGP4 */
        -:  537:/* 42 */	"(%0)",	/* base: reg */
        -:  538:/* 43 */	"%1(%0)",	/* base: ADDI4(reg,acon) */
        -:  539:/* 44 */	"%1(%0)",	/* base: ADDP4(reg,acon) */
        -:  540:/* 45 */	"%1(%0)",	/* base: ADDU4(reg,acon) */
        -:  541:/* 46 */	"%a(%%ebp)",	/* base: ADDRFP4 */
        -:  542:/* 47 */	"%a(%%ebp)",	/* base: ADDRLP4 */
        -:  543:/* 48 */	"%0",	/* index: reg */
        -:  544:/* 49 */	"%0,2",	/* index: LSHI4(reg,con1) */
        -:  545:/* 50 */	"%0,4",	/* index: LSHI4(reg,con2) */
        -:  546:/* 51 */	"%0,8",	/* index: LSHI4(reg,con3) */
        -:  547:/* 52 */	"%0,2",	/* index: LSHU4(reg,con1) */
        -:  548:/* 53 */	"%0,4",	/* index: LSHU4(reg,con2) */
        -:  549:/* 54 */	"%0,8",	/* index: LSHU4(reg,con3) */
        -:  550:/* 55 */	"1",	/* con0: CNSTI4 */
        -:  551:/* 56 */	"1",	/* con0: CNSTU4 */
        -:  552:/* 57 */	"1",	/* con1: CNSTI4 */
        -:  553:/* 58 */	"1",	/* con1: CNSTU4 */
        -:  554:/* 59 */	"2",	/* con2: CNSTI4 */
        -:  555:/* 60 */	"2",	/* con2: CNSTU4 */
        -:  556:/* 61 */	"3",	/* con3: CNSTI4 */
        -:  557:/* 62 */	"3",	/* con3: CNSTU4 */
        -:  558:/* 63 */	"%0",	/* addr: base */
        -:  559:/* 64 */	"%0",	/* addr: baseaddr */
        -:  560:/* 65 */	"%1(,%0)",	/* addr: ADDI4(index,baseaddr) */
        -:  561:/* 66 */	"%1(,%0)",	/* addr: ADDP4(index,baseaddr) */
        -:  562:/* 67 */	"%1(,%0)",	/* addr: ADDU4(index,baseaddr) */
        -:  563:/* 68 */	"%1(%0)",	/* addr: ADDI4(reg,baseaddr) */
        -:  564:/* 69 */	"%1(%0)",	/* addr: ADDP4(reg,baseaddr) */
        -:  565:/* 70 */	"%1(%0)",	/* addr: ADDU4(reg,baseaddr) */
        -:  566:/* 71 */	"(%1,%0)",	/* addr: ADDI4(index,reg) */
        -:  567:/* 72 */	"(%1,%0)",	/* addr: ADDP4(index,reg) */
        -:  568:/* 73 */	"(%1,%0)",	/* addr: ADDU4(index,reg) */
        -:  569:/* 74 */	"(,%0)",	/* addr: index */
        -:  570:/* 75 */	"%0",	/* mem1: INDIRI1(addr) */
        -:  571:/* 76 */	"%0",	/* mem1: INDIRU1(addr) */
        -:  572:/* 77 */	"%0",	/* mem2: INDIRI2(addr) */
        -:  573:/* 78 */	"%0",	/* mem2: INDIRU2(addr) */
        -:  574:/* 79 */	"%0",	/* mem4: INDIRI4(addr) */
        -:  575:/* 80 */	"%0",	/* mem4: INDIRU4(addr) */
        -:  576:/* 81 */	"%0",	/* mem4: INDIRP4(addr) */
        -:  577:/* 82 */	"%0",	/* rc: reg */
        -:  578:/* 83 */	"%0",	/* rc: con */
        -:  579:/* 84 */	"%0",	/* mr: reg */
        -:  580:/* 85 */	"%0",	/* mr: mem4 */
        -:  581:/* 86 */	"%0",	/* mr1: reg */
        -:  582:/* 87 */	"%0",	/* mr1: mem1 */
        -:  583:/* 88 */	"%0",	/* mr2: reg */
        -:  584:/* 89 */	"%0",	/* mr2: mem2 */
        -:  585:/* 90 */	"%0",	/* mrc: mem4 */
        -:  586:/* 91 */	"%0",	/* mrc: mem1 */
        -:  587:/* 92 */	"%0",	/* mrc: mem2 */
        -:  588:/* 93 */	"%0",	/* mrc: rc */
        -:  589:/* 94 */	"leal %0,%c\n",	/* reg: addr */
        -:  590:/* 95 */	"movl %0,%c\n",	/* reg: mr */
        -:  591:/* 96 */	"movb %0,%c\n",	/* reg: mr1 */
        -:  592:/* 97 */	"movw %0,%c\n",	/* reg: mr2 */
        -:  593:/* 98 */	"movl %0,%c\n",	/* reg: con */
        -:  594:/* 99 */	"# move\n",	/* reg: LOADI1(reg) */
        -:  595:/* 100 */	"# move\n",	/* reg: LOADI2(reg) */
        -:  596:/* 101 */	"# move\n",	/* reg: LOADI4(reg) */
        -:  597:/* 102 */	"# move\n",	/* reg: LOADU1(reg) */
        -:  598:/* 103 */	"# move\n",	/* reg: LOADU2(reg) */
        -:  599:/* 104 */	"# move\n",	/* reg: LOADU4(reg) */
        -:  600:/* 105 */	"# move\n",	/* reg: LOADP4(reg) */
        -:  601:/* 106 */	"?movl %0,%c\naddl %1,%c\n",	/* reg: ADDI4(reg,mrc) */
        -:  602:/* 107 */	"?movl %0,%c\naddl %1,%c\n",	/* reg: ADDP4(reg,mrc) */
        -:  603:/* 108 */	"?movl %0,%c\naddl %1,%c\n",	/* reg: ADDU4(reg,mrc) */
        -:  604:/* 109 */	"?movl %0,%c\nsubl %1,%c\n",	/* reg: SUBI4(reg,mrc) */
        -:  605:/* 110 */	"?movl %0,%c\nsubl %1,%c\n",	/* reg: SUBP4(reg,mrc) */
        -:  606:/* 111 */	"?movl %0,%c\nsubl %1,%c\n",	/* reg: SUBU4(reg,mrc) */
        -:  607:/* 112 */	"?movl %0,%c\nandl %1,%c\n",	/* reg: BANDI4(reg,mrc) */
        -:  608:/* 113 */	"?movl %0,%c\norl %1,%c\n",	/* reg: BORI4(reg,mrc) */
        -:  609:/* 114 */	"?movl %0,%c\nxorl %1,%c\n",	/* reg: BXORI4(reg,mrc) */
        -:  610:/* 115 */	"?movl %0,%c\nandl %1,%c\n",	/* reg: BANDU4(reg,mrc) */
        -:  611:/* 116 */	"?movl %0,%c\norl %1,%c\n",	/* reg: BORU4(reg,mrc) */
        -:  612:/* 117 */	"?movl %0,%c\nxorl %1,%c\n",	/* reg: BXORU4(reg,mrc) */
        -:  613:/* 118 */	"incl %1\n",	/* stmt: ASGNI4(addr,ADDI4(mem4,con1)) */
        -:  614:/* 119 */	"incl %1\n",	/* stmt: ASGNI4(addr,ADDU4(mem4,con1)) */
        -:  615:/* 120 */	"incl %1\n",	/* stmt: ASGNP4(addr,ADDP4(mem4,con1)) */
        -:  616:/* 121 */	"decl %1\n",	/* stmt: ASGNI4(addr,SUBI4(mem4,con1)) */
        -:  617:/* 122 */	"decl %1\n",	/* stmt: ASGNI4(addr,SUBU4(mem4,con1)) */
        -:  618:/* 123 */	"decl %1\n",	/* stmt: ASGNP4(addr,SUBP4(mem4,con1)) */
        -:  619:/* 124 */	"addl %2,%1\n",	/* stmt: ASGNI4(addr,ADDI4(mem4,rc)) */
        -:  620:/* 125 */	"sub %2,%1\n",	/* stmt: ASGNI4(addr,SUBI4(mem4,rc)) */
        -:  621:/* 126 */	"add %2,%1\n",	/* stmt: ASGNU4(addr,ADDU4(mem4,rc)) */
        -:  622:/* 127 */	"sub %2,%1\n",	/* stmt: ASGNU4(addr,SUBU4(mem4,rc)) */
        -:  623:/* 128 */	"andl %2,%1\n",	/* stmt: ASGNI4(addr,BANDI4(mem4,rc)) */
        -:  624:/* 129 */	"orl %2,%1\n",	/* stmt: ASGNI4(addr,BORI4(mem4,rc)) */
        -:  625:/* 130 */	"xorl %2,%1\n",	/* stmt: ASGNI4(addr,BXORI4(mem4,rc)) */
        -:  626:/* 131 */	"andl %2,%1\n",	/* stmt: ASGNU4(addr,BANDU4(mem4,rc)) */
        -:  627:/* 132 */	"orl %2,%1\n",	/* stmt: ASGNU4(addr,BORU4(mem4,rc)) */
        -:  628:/* 133 */	"xorl %2,%1\n",	/* stmt: ASGNU4(addr,BXORU4(mem4,rc)) */
        -:  629:/* 134 */	"?movl %0,%c\nnotl %c\n",	/* reg: BCOMI4(reg) */
        -:  630:/* 135 */	"?movl %0,%c\nnotl %c\n",	/* reg: BCOMU4(reg) */
        -:  631:/* 136 */	"?movl %0,%c\nnegl %c\n",	/* reg: NEGI4(reg) */
        -:  632:/* 137 */	"notl %1\n",	/* stmt: ASGNI4(addr,BCOMI4(mem4)) */
        -:  633:/* 138 */	"notl %1\n",	/* stmt: ASGNU4(addr,BCOMU4(mem4)) */
        -:  634:/* 139 */	"negl %1\n",	/* stmt: ASGNI4(addr,NEGI4(mem4)) */
        -:  635:/* 140 */	"?movl %0,%c\nsall %1,%c\n",	/* reg: LSHI4(reg,rc5) */
        -:  636:/* 141 */	"?movl %0,%c\nshll %1,%c\n",	/* reg: LSHU4(reg,rc5) */
        -:  637:/* 142 */	"?movl %0,%c\nsarl %1,%c\n",	/* reg: RSHI4(reg,rc5) */
        -:  638:/* 143 */	"?movl %0,%c\nshrl %1,%c\n",	/* reg: RSHU4(reg,rc5) */
        -:  639:/* 144 */	"sall %2,%1\n",	/* stmt: ASGNI4(addr,LSHI4(mem4,rc5)) */
        -:  640:/* 145 */	"shll %2,%1\n",	/* stmt: ASGNI4(addr,LSHU4(mem4,rc5)) */
        -:  641:/* 146 */	"sarl %2,%1\n",	/* stmt: ASGNI4(addr,RSHI4(mem4,rc5)) */
        -:  642:/* 147 */	"shrl %2,%1\n",	/* stmt: ASGNI4(addr,RSHU4(mem4,rc5)) */
        -:  643:/* 148 */	"$%a",	/* rc5: CNSTI4 */
        -:  644:/* 149 */	"%%cl",	/* rc5: reg */
        -:  645:/* 150 */	"?movl %0,%c\nimull %1,%c\n",	/* reg: MULI4(reg,mrc) */
        -:  646:/* 151 */	"imul %0,%1,%c\n",	/* reg: MULI4(con,mr) */
        -:  647:/* 152 */	"mull %1\n",	/* reg: MULU4(reg,mr) */
        -:  648:/* 153 */	"xorl %%edx,%%edx\ndivl %1\n",	/* reg: DIVU4(reg,reg) */
        -:  649:/* 154 */	"xorl %%edx,%%edx\ndivl %1\n",	/* reg: MODU4(reg,reg) */
        -:  650:/* 155 */	"cdq\nidivl %1\n",	/* reg: DIVI4(reg,reg) */
        -:  651:/* 156 */	"cdq\nidivl %1\n",	/* reg: MODI4(reg,reg) */
        -:  652:/* 157 */	"movl %0,%c\n",	/* reg: CVPU4(reg) */
        -:  653:/* 158 */	"movl %0,%c\n",	/* reg: CVUP4(reg) */
        -:  654:/* 159 */	"movsbl %0,%c\n",	/* reg: CVII4(INDIRI1(addr)) */
        -:  655:/* 160 */	"movswl %0,%c\n",	/* reg: CVII4(INDIRI2(addr)) */
        -:  656:/* 161 */	"movzbl %0,%c\n",	/* reg: CVUU4(INDIRU1(addr)) */
        -:  657:/* 162 */	"movzwl %0,%c\n",	/* reg: CVUU4(INDIRU2(addr)) */
        -:  658:/* 163 */	"# extend\n",	/* reg: CVII4(reg) */
        -:  659:/* 164 */	"# extend\n",	/* reg: CVIU4(reg) */
        -:  660:/* 165 */	"# extend\n",	/* reg: CVUI4(reg) */
        -:  661:/* 166 */	"# extend\n",	/* reg: CVUU4(reg) */
        -:  662:/* 167 */	"# truncate\n",	/* reg: CVII1(reg) */
        -:  663:/* 168 */	"# truncate\n",	/* reg: CVII2(reg) */
        -:  664:/* 169 */	"# truncate\n",	/* reg: CVUU1(reg) */
        -:  665:/* 170 */	"# truncate\n",	/* reg: CVUU2(reg) */
        -:  666:/* 171 */	"%0",	/* mrca: mem4 */
        -:  667:/* 172 */	"%0",	/* mrca: rc */
        -:  668:/* 173 */	"$%a",	/* mrca: ADDRGP4 */
        -:  669:/* 174 */	"$%a",	/* mrca: ADDRGP8 */
        -:  670:/* 175 */	"movb %1,%0\n",	/* stmt: ASGNI1(addr,rc) */
        -:  671:/* 176 */	"movw %1,%0\n",	/* stmt: ASGNI2(addr,rc) */
        -:  672:/* 177 */	"movl %1,%0\n",	/* stmt: ASGNI4(addr,rc) */
        -:  673:/* 178 */	"movb %1,%0\n",	/* stmt: ASGNU1(addr,rc) */
        -:  674:/* 179 */	"movw %1,%0\n",	/* stmt: ASGNU2(addr,rc) */
        -:  675:/* 180 */	"movl %1,%0\n",	/* stmt: ASGNU4(addr,rc) */
        -:  676:/* 181 */	"movl %1,%0\n",	/* stmt: ASGNP4(addr,rc) */
        -:  677:/* 182 */	"pushl %0\n",	/* stmt: ARGI4(mrca) */
        -:  678:/* 183 */	"pushl %0\n",	/* stmt: ARGU4(mrca) */
        -:  679:/* 184 */	"pushl %0\n",	/* stmt: ARGP4(mrca) */
        -:  680:/* 185 */	"movl $%a,%%ecx\nrep\nmovsb\n",	/* stmt: ASGNB(reg,INDIRB(reg)) */
        -:  681:/* 186 */	"subl $%a,%%esp\nmovl %%esp,%%edi\nmovl $%a,%%ecx\nrep\nmovsb\n",	/* stmt: ARGB(INDIRB(reg)) */
        -:  682:/* 187 */	"l %0",	/* memf: INDIRF8(addr) */
        -:  683:/* 188 */	"s %0",	/* memf: INDIRF4(addr) */
        -:  684:/* 189 */	"s %0",	/* memf: CVFF8(INDIRF4(addr)) */
        -:  685:/* 190 */	"l %0",	/* memf: CVFF4(INDIRF8(addr)) */
        -:  686:/* 191 */	"fld%0\n",	/* freg: memf */
        -:  687:/* 192 */	"fstpl %0\n",	/* stmt: ASGNF8(addr,freg) */
        -:  688:/* 193 */	"fstps %0\n",	/* stmt: ASGNF4(addr,freg) */
        -:  689:/* 194 */	"fstps %0\n",	/* stmt: ASGNF4(addr,CVFF4(freg)) */
        -:  690:/* 195 */	"subl $8,%%esp\nfstpl (%%esp)\n",	/* stmt: ARGF8(freg) */
        -:  691:/* 196 */	"subl $4,%%esp\nfstps (%%esp)\n",	/* stmt: ARGF4(freg) */
        -:  692:/* 197 */	"fchs\n",	/* freg: NEGF8(freg) */
        -:  693:/* 198 */	"fchs\n",	/* freg: NEGF4(freg) */
        -:  694:/* 199 */	"%0",	/* flt: memf */
        -:  695:/* 200 */	"p %%st(1),%%st",	/* flt: freg */
        -:  696:/* 201 */	"fadd%1\n",	/* freg: ADDF4(freg,flt) */
        -:  697:/* 202 */	"fadd%1\n",	/* freg: ADDF8(freg,flt) */
        -:  698:/* 203 */	"fdiv%1\n",	/* freg: DIVF4(freg,flt) */
        -:  699:/* 204 */	"fdiv%1\n",	/* freg: DIVF8(freg,flt) */
        -:  700:/* 205 */	"fmul%1\n",	/* freg: MULF4(freg,flt) */
        -:  701:/* 206 */	"fmul%1\n",	/* freg: MULF8(freg,flt) */
        -:  702:/* 207 */	"fsub%1\n",	/* freg: SUBF4(freg,flt) */
        -:  703:/* 208 */	"fsub%1\n",	/* freg: SUBF8(freg,flt) */
        -:  704:/* 209 */	"# CVFF8\n",	/* freg: CVFF8(freg) */
        -:  705:/* 210 */	"sub $4,%%esp\nfstps (%%esp)\nflds (%%esp)\naddl $4,%%esp\n",	/* freg: CVFF4(freg) */
        -:  706:/* 211 */	"fistpl %0\n",	/* stmt: ASGNI4(addr,CVFI4(freg)) */
        -:  707:/* 212 */	"subl $4,%%esp\nfistpl 0(%%esp)\npopl %c\n",	/* reg: CVFI4(freg) */
        -:  708:/* 213 */	"fildl %0\n",	/* freg: CVIF8(INDIRI4(addr)) */
        -:  709:/* 214 */	"pushl %0\nfildl (%%esp)\naddl $4,%%esp\n",	/* freg: CVIF8(reg) */
        -:  710:/* 215 */	"fildl %0\n",	/* freg: CVIF4(INDIRI4(addr)) */
        -:  711:/* 216 */	"pushl %0\nfildl (%%esp)\naddl $4,%%esp\n",	/* freg: CVIF4(reg) */
        -:  712:/* 217 */	"%a",	/* addrj: ADDRGP4 */
        -:  713:/* 218 */	"*%0",	/* addrj: reg */
        -:  714:/* 219 */	"*%0",	/* addrj: mem4 */
        -:  715:/* 220 */	"%a:\n",	/* stmt: LABELV */
        -:  716:/* 221 */	"jmp %0\n",	/* stmt: JUMPV(addrj) */
        -:  717:/* 222 */	"cmpl %1,%0\nje %a\n",	/* stmt: EQI4(mem4,rc) */
        -:  718:/* 223 */	"cmpl %1,%0\njge %a\n",	/* stmt: GEI4(mem4,rc) */
        -:  719:/* 224 */	"cmpl %1,%0\njg %a\n",	/* stmt: GTI4(mem4,rc) */
        -:  720:/* 225 */	"cmpl %1,%0\njle %a\n",	/* stmt: LEI4(mem4,rc) */
        -:  721:/* 226 */	"cmpl %1,%0\njl %a\n",	/* stmt: LTI4(mem4,rc) */
        -:  722:/* 227 */	"cmpl %1,%0\njne %a\n",	/* stmt: NEI4(mem4,rc) */
        -:  723:/* 228 */	"cmpl %1,%0\njae %a\n",	/* stmt: GEU4(mem4,rc) */
        -:  724:/* 229 */	"cmpl %1,%0\nja  %a\n",	/* stmt: GTU4(mem4,rc) */
        -:  725:/* 230 */	"cmpl %1,%0\njbe %a\n",	/* stmt: LEU4(mem4,rc) */
        -:  726:/* 231 */	"cmpl %1,%0\njb  %a\n",	/* stmt: LTU4(mem4,rc) */
        -:  727:/* 232 */	"cmpl %1,%0\nje %a\n",	/* stmt: EQI4(reg,mrc) */
        -:  728:/* 233 */	"cmpl %1,%0\njge %a\n",	/* stmt: GEI4(reg,mrc) */
        -:  729:/* 234 */	"cmpl %1,%0\njg %a\n",	/* stmt: GTI4(reg,mrc) */
        -:  730:/* 235 */	"cmpl %1,%0\njle %a\n",	/* stmt: LEI4(reg,mrc) */
        -:  731:/* 236 */	"cmpl %1,%0\njl %a\n",	/* stmt: LTI4(reg,mrc) */
        -:  732:/* 237 */	"cmpl %1,%0\njne %a\n",	/* stmt: NEI4(reg,mrc) */
        -:  733:/* 238 */	"cmpl %1,%0\nje %a\n",	/* stmt: EQU4(reg,mrc) */
        -:  734:/* 239 */	"cmpl %1,%0\njae %a\n",	/* stmt: GEU4(reg,mrc) */
        -:  735:/* 240 */	"cmpl %1,%0\nja %a\n",	/* stmt: GTU4(reg,mrc) */
        -:  736:/* 241 */	"cmpl %1,%0\njbe %a\n",	/* stmt: LEU4(reg,mrc) */
        -:  737:/* 242 */	"cmpl %1,%0\njb %a\n",	/* stmt: LTU4(reg,mrc) */
        -:  738:/* 243 */	"cmpl %1,%0\njne %a\n",	/* stmt: NEU4(reg,mrc) */
        -:  739:/* 244 */	"testl %1,%0\nje %a\n",	/* stmt: EQI4(BANDU4(mr,con),con0) */
        -:  740:/* 245 */	"testl %1,%0\njne %a\n",	/* stmt: NEI4(BANDU4(mr,con),con0) */
        -:  741:/* 246 */	"testw %1,%0\nje %a\n",	/* stmt: EQI4(BANDU4(CVII2(INDIRI2(addr)),con),con0) */
        -:  742:/* 247 */	"testw %1,%0\njne %a\n",	/* stmt: NEI4(BANDU4(CVII2(INDIRI2(addr)),con),con0) */
        -:  743:/* 248 */	"testw %1,%0\nje %a\n",	/* stmt: EQI4(BANDU4(CVIU2(INDIRI2(addr)),con),con0) */
        -:  744:/* 249 */	"testw %1,%0\njne %a\n",	/* stmt: NEI4(BANDU4(CVIU2(INDIRI2(addr)),con),con0) */
        -:  745:/* 250 */	"testb %1,%0\nje %a\n",	/* stmt: EQI4(BANDU4(CVII1(INDIRI1(addr)),con),con0) */
        -:  746:/* 251 */	"l %0",	/* cmpf: INDIRF8(addr) */
        -:  747:/* 252 */	"s %0",	/* cmpf: INDIRF4(addr) */
        -:  748:/* 253 */	"s %0",	/* cmpf: CVFF8(INDIRF4(addr)) */
        -:  749:/* 254 */	"p",	/* cmpf: freg */
        -:  750:/* 255 */	"fcomp%0\nfstsw %%ax\nsahf\nje %a\n",	/* stmt: EQF8(cmpf,freg) */
        -:  751:/* 256 */	"fcomp%0\nfstsw %%ax\nsahf\njbe %a\n",	/* stmt: GEF8(cmpf,freg) */
        -:  752:/* 257 */	"fcomp%0\nfstsw %%ax\nsahf\njb %a\n",	/* stmt: GTF8(cmpf,freg) */
        -:  753:/* 258 */	"fcomp%0\nfstsw %%ax\nsahf\njae %a\n",	/* stmt: LEF8(cmpf,freg) */
        -:  754:/* 259 */	"fcomp%0\nfstsw %%ax\nsahf\nja %a\n",	/* stmt: LTF8(cmpf,freg) */
        -:  755:/* 260 */	"fcomp%0\nfstsw %%ax\nsahf\njne %a\n",	/* stmt: NEF8(cmpf,freg) */
        -:  756:/* 261 */	"fcomp%0\nfstsw %%ax\nsahf\nje %a\n",	/* stmt: EQF4(cmpf,freg) */
        -:  757:/* 262 */	"fcomp%0\nfstsw %%ax\nsahf\njbe %a\n",	/* stmt: GEF4(cmpf,freg) */
        -:  758:/* 263 */	"fcomp%0\nfstsw %%ax\nsahf\njb %a\n",	/* stmt: GTF4(cmpf,freg) */
        -:  759:/* 264 */	"fcomp%0\nfstsw %%ax\nsahf\njae %a\n",	/* stmt: LEF4(cmpf,freg) */
        -:  760:/* 265 */	"fcomp%0\nfstsw %%ax\nsahf\nja %a\n",	/* stmt: LTF4(cmpf,freg) */
        -:  761:/* 266 */	"fcomp%0\nfstsw %%ax\nsahf\njne %a\n",	/* stmt: NEF4(cmpf,freg) */
        -:  762:/* 267 */	"fidivl %1\n",	/* freg: DIVF8(freg,CVIF8(INDIRI4(addr))) */
        -:  763:/* 268 */	"fidivrl %0\n",	/* freg: DIVF8(CVIF8(INDIRI4(addr)),freg) */
        -:  764:/* 269 */	"fidivs %1\n",	/* freg: DIVF8(freg,CVIF8(CVII2(INDIRI2(addr)))) */
        -:  765:/* 270 */	"fidivrs %0\n",	/* freg: DIVF8(CVIF8(CVII2(INDIRI2(addr))),freg) */
        -:  766:/* 271 */	"fimull %1\n",	/* freg: MULF8(freg,CVIF8(INDIRI4(addr))) */
        -:  767:/* 272 */	"fimuls %1\n",	/* freg: MULF8(freg,CVIF8(CVII2(INDIRI2(addr)))) */
        -:  768:/* 273 */	"fisubl %1\n",	/* freg: SUBF8(freg,CVIF8(INDIRI4(addr))) */
        -:  769:/* 274 */	"fisubrl %0\n",	/* freg: SUBF8(CVIF8(INDIRI4(addr)),freg) */
        -:  770:/* 275 */	"fisubs %1\n",	/* freg: SUBF8(freg,CVIF8(CVII2(INDIRI2(addr)))) */
        -:  771:/* 276 */	"fisubrs %0\n",	/* freg: SUBF8(CVIF8(CVII2(INDIRI2(addr))),freg) */
        -:  772:/* 277 */	"fiaddl %1\n",	/* freg: ADDF8(freg,CVIF8(INDIRI4(addr))) */
        -:  773:/* 278 */	"fiadds %1\n",	/* freg: ADDF8(freg,CVIF8(CVII2(INDIRI2(addr)))) */
        -:  774:/* 279 */	"fdivs %1\n",	/* freg: ADDF8(freg,CVFF8(INDIRF4(addr))) */
        -:  775:/* 280 */	"fsubs %1\n",	/* freg: SUBF8(freg,CVFF8(INDIRF4(addr))) */
        -:  776:/* 281 */	"fmuls %1\n",	/* freg: MULF8(freg,CVFF8(INDIRF4(addr))) */
        -:  777:/* 282 */	"fdivs %1\n",	/* freg: DIVF8(freg,CVFF8(INDIRF4(addr))) */
        -:  778:/* 283 */	"fld%0\n",	/* freg: LOADF8(memf) */
        -:  779:/* 284 */	"call %0\naddl $%a,%%esp\n",	/* reg: CALLI4(addrj) */
        -:  780:/* 285 */	"call %0\naddl $%a,%%esp\n",	/* reg: CALLU4(addrj) */
        -:  781:/* 286 */	"call %0\naddl $%a,%%esp\n",	/* reg: CALLP4(addrj) */
        -:  782:/* 287 */	"call %0\n",	/* reg: CALLI4(addrj) */
        -:  783:/* 288 */	"call %0\n",	/* reg: CALLU4(addrj) */
        -:  784:/* 289 */	"call %0\n",	/* reg: CALLP4(addrj) */
        -:  785:/* 290 */	"call %0\naddl $%a,%%esp\n",	/* stmt: CALLV(addrj) */
        -:  786:/* 291 */	"call %0\n",	/* stmt: CALLV(addrj) */
        -:  787:/* 292 */	"call %0\naddl $%a,%%esp\n",	/* freg: CALLF4(addrj) */
        -:  788:/* 293 */	"call %0\n",	/* freg: CALLF4(addrj) */
        -:  789:/* 294 */	"call %0\naddl $%a,%%esp\nfstp %%st(0)\n",	/* stmt: CALLF4(addrj) */
        -:  790:/* 295 */	"call %0\nfstp %%st(0)\n",	/* stmt: CALLF4(addrj) */
        -:  791:/* 296 */	"call %0\naddl $%a,%%esp\n",	/* freg: CALLF8(addrj) */
        -:  792:/* 297 */	"call %0\n",	/* freg: CALLF8(addrj) */
        -:  793:/* 298 */	"call %0\naddl $%a,%%esp\nfstp %%st(0)\n",	/* stmt: CALLF8(addrj) */
        -:  794:/* 299 */	"call %0\nfstp %%st(0)\n",	/* stmt: CALLF8(addrj) */
        -:  795:/* 300 */	"# ret\n",	/* stmt: RETI4(reg) */
        -:  796:/* 301 */	"# ret\n",	/* stmt: RETU4(reg) */
        -:  797:/* 302 */	"# ret\n",	/* stmt: RETP4(reg) */
        -:  798:/* 303 */	"# ret\n",	/* stmt: RETF4(freg) */
        -:  799:/* 304 */	"# ret\n",	/* stmt: RETF8(freg) */
        -:  800:};
        -:  801:
        -:  802:static char _isinstruction[] = {
        -:  803:/* 0 */	0,
        -:  804:/* 1 */	1,	/* # read register\n */
        -:  805:/* 2 */	1,	/* # read register\n */
        -:  806:/* 3 */	1,	/* # read register\n */
        -:  807:/* 4 */	1,	/* # read register\n */
        -:  808:/* 5 */	1,	/* # read register\n */
        -:  809:/* 6 */	1,	/* # read register\n */
        -:  810:/* 7 */	1,	/* # read register\n */
        -:  811:/* 8 */	1,	/* # read register\n */
        -:  812:/* 9 */	1,	/* # read register\n */
        -:  813:/* 10 */	1,	/* # read register\n */
        -:  814:/* 11 */	1,	/* # read register\n */
        -:  815:/* 12 */	1,	/* # read register\n */
        -:  816:/* 13 */	1,	/* # write register\n */
        -:  817:/* 14 */	1,	/* # write register\n */
        -:  818:/* 15 */	1,	/* # write register\n */
        -:  819:/* 16 */	1,	/* # write register\n */
        -:  820:/* 17 */	1,	/* # write register\n */
        -:  821:/* 18 */	1,	/* # write register\n */
        -:  822:/* 19 */	1,	/* # write register\n */
        -:  823:/* 20 */	1,	/* # write register\n */
        -:  824:/* 21 */	1,	/* # write register\n */
        -:  825:/* 22 */	1,	/* # write register\n */
        -:  826:/* 23 */	1,	/* # write register\n */
        -:  827:/* 24 */	1,	/* # write register\n */
        -:  828:/* 25 */	0,	/* %a */
        -:  829:/* 26 */	0,	/* %a */
        -:  830:/* 27 */	0,	/* %a */
        -:  831:/* 28 */	0,	/* %a */
        -:  832:/* 29 */	0,	/* %a */
        -:  833:/* 30 */	0,	/* %a */
        -:  834:/* 31 */	0,	/* %a */
        -:  835:/* 32 */	0,	/* %a */
        -:  836:/* 33 */	0,	/* %a */
        -:  837:/* 34 */	0,	/* %a */
        -:  838:/* 35 */	0,	/* $%0 */
        -:  839:/* 36 */	0,	/*  */
        -:  840:/* 37 */	0,	/*  */
        -:  841:/* 38 */	0,	/* %a */
        -:  842:/* 39 */	0,	/* %a */
        -:  843:/* 40 */	0,	/* %0 */
        -:  844:/* 41 */	0,	/* %a */
        -:  845:/* 42 */	0,	/* (%0) */
        -:  846:/* 43 */	0,	/* %1(%0) */
        -:  847:/* 44 */	0,	/* %1(%0) */
        -:  848:/* 45 */	0,	/* %1(%0) */
        -:  849:/* 46 */	0,	/* %a(%%ebp) */
        -:  850:/* 47 */	0,	/* %a(%%ebp) */
        -:  851:/* 48 */	0,	/* %0 */
        -:  852:/* 49 */	0,	/* %0,2 */
        -:  853:/* 50 */	0,	/* %0,4 */
        -:  854:/* 51 */	0,	/* %0,8 */
        -:  855:/* 52 */	0,	/* %0,2 */
        -:  856:/* 53 */	0,	/* %0,4 */
        -:  857:/* 54 */	0,	/* %0,8 */
        -:  858:/* 55 */	0,	/* 1 */
        -:  859:/* 56 */	0,	/* 1 */
        -:  860:/* 57 */	0,	/* 1 */
        -:  861:/* 58 */	0,	/* 1 */
        -:  862:/* 59 */	0,	/* 2 */
        -:  863:/* 60 */	0,	/* 2 */
        -:  864:/* 61 */	0,	/* 3 */
        -:  865:/* 62 */	0,	/* 3 */
        -:  866:/* 63 */	0,	/* %0 */
        -:  867:/* 64 */	0,	/* %0 */
        -:  868:/* 65 */	0,	/* %1(,%0) */
        -:  869:/* 66 */	0,	/* %1(,%0) */
        -:  870:/* 67 */	0,	/* %1(,%0) */
        -:  871:/* 68 */	0,	/* %1(%0) */
        -:  872:/* 69 */	0,	/* %1(%0) */
        -:  873:/* 70 */	0,	/* %1(%0) */
        -:  874:/* 71 */	0,	/* (%1,%0) */
        -:  875:/* 72 */	0,	/* (%1,%0) */
        -:  876:/* 73 */	0,	/* (%1,%0) */
        -:  877:/* 74 */	0,	/* (,%0) */
        -:  878:/* 75 */	0,	/* %0 */
        -:  879:/* 76 */	0,	/* %0 */
        -:  880:/* 77 */	0,	/* %0 */
        -:  881:/* 78 */	0,	/* %0 */
        -:  882:/* 79 */	0,	/* %0 */
        -:  883:/* 80 */	0,	/* %0 */
        -:  884:/* 81 */	0,	/* %0 */
        -:  885:/* 82 */	0,	/* %0 */
        -:  886:/* 83 */	0,	/* %0 */
        -:  887:/* 84 */	0,	/* %0 */
        -:  888:/* 85 */	0,	/* %0 */
        -:  889:/* 86 */	0,	/* %0 */
        -:  890:/* 87 */	0,	/* %0 */
        -:  891:/* 88 */	0,	/* %0 */
        -:  892:/* 89 */	0,	/* %0 */
        -:  893:/* 90 */	0,	/* %0 */
        -:  894:/* 91 */	0,	/* %0 */
        -:  895:/* 92 */	0,	/* %0 */
        -:  896:/* 93 */	0,	/* %0 */
        -:  897:/* 94 */	1,	/* leal %0,%c\n */
        -:  898:/* 95 */	1,	/* movl %0,%c\n */
        -:  899:/* 96 */	1,	/* movb %0,%c\n */
        -:  900:/* 97 */	1,	/* movw %0,%c\n */
        -:  901:/* 98 */	1,	/* movl %0,%c\n */
        -:  902:/* 99 */	1,	/* # move\n */
        -:  903:/* 100 */	1,	/* # move\n */
        -:  904:/* 101 */	1,	/* # move\n */
        -:  905:/* 102 */	1,	/* # move\n */
        -:  906:/* 103 */	1,	/* # move\n */
        -:  907:/* 104 */	1,	/* # move\n */
        -:  908:/* 105 */	1,	/* # move\n */
        -:  909:/* 106 */	1,	/* ?movl %0,%c\naddl %1,%c\n */
        -:  910:/* 107 */	1,	/* ?movl %0,%c\naddl %1,%c\n */
        -:  911:/* 108 */	1,	/* ?movl %0,%c\naddl %1,%c\n */
        -:  912:/* 109 */	1,	/* ?movl %0,%c\nsubl %1,%c\n */
        -:  913:/* 110 */	1,	/* ?movl %0,%c\nsubl %1,%c\n */
        -:  914:/* 111 */	1,	/* ?movl %0,%c\nsubl %1,%c\n */
        -:  915:/* 112 */	1,	/* ?movl %0,%c\nandl %1,%c\n */
        -:  916:/* 113 */	1,	/* ?movl %0,%c\norl %1,%c\n */
        -:  917:/* 114 */	1,	/* ?movl %0,%c\nxorl %1,%c\n */
        -:  918:/* 115 */	1,	/* ?movl %0,%c\nandl %1,%c\n */
        -:  919:/* 116 */	1,	/* ?movl %0,%c\norl %1,%c\n */
        -:  920:/* 117 */	1,	/* ?movl %0,%c\nxorl %1,%c\n */
        -:  921:/* 118 */	1,	/* incl %1\n */
        -:  922:/* 119 */	1,	/* incl %1\n */
        -:  923:/* 120 */	1,	/* incl %1\n */
        -:  924:/* 121 */	1,	/* decl %1\n */
        -:  925:/* 122 */	1,	/* decl %1\n */
        -:  926:/* 123 */	1,	/* decl %1\n */
        -:  927:/* 124 */	1,	/* addl %2,%1\n */
        -:  928:/* 125 */	1,	/* sub %2,%1\n */
        -:  929:/* 126 */	1,	/* add %2,%1\n */
        -:  930:/* 127 */	1,	/* sub %2,%1\n */
        -:  931:/* 128 */	1,	/* andl %2,%1\n */
        -:  932:/* 129 */	1,	/* orl %2,%1\n */
        -:  933:/* 130 */	1,	/* xorl %2,%1\n */
        -:  934:/* 131 */	1,	/* andl %2,%1\n */
        -:  935:/* 132 */	1,	/* orl %2,%1\n */
        -:  936:/* 133 */	1,	/* xorl %2,%1\n */
        -:  937:/* 134 */	1,	/* ?movl %0,%c\nnotl %c\n */
        -:  938:/* 135 */	1,	/* ?movl %0,%c\nnotl %c\n */
        -:  939:/* 136 */	1,	/* ?movl %0,%c\nnegl %c\n */
        -:  940:/* 137 */	1,	/* notl %1\n */
        -:  941:/* 138 */	1,	/* notl %1\n */
        -:  942:/* 139 */	1,	/* negl %1\n */
        -:  943:/* 140 */	1,	/* ?movl %0,%c\nsall %1,%c\n */
        -:  944:/* 141 */	1,	/* ?movl %0,%c\nshll %1,%c\n */
        -:  945:/* 142 */	1,	/* ?movl %0,%c\nsarl %1,%c\n */
        -:  946:/* 143 */	1,	/* ?movl %0,%c\nshrl %1,%c\n */
        -:  947:/* 144 */	1,	/* sall %2,%1\n */
        -:  948:/* 145 */	1,	/* shll %2,%1\n */
        -:  949:/* 146 */	1,	/* sarl %2,%1\n */
        -:  950:/* 147 */	1,	/* shrl %2,%1\n */
        -:  951:/* 148 */	0,	/* $%a */
        -:  952:/* 149 */	0,	/* %%cl */
        -:  953:/* 150 */	1,	/* ?movl %0,%c\nimull %1,%c\n */
        -:  954:/* 151 */	1,	/* imul %0,%1,%c\n */
        -:  955:/* 152 */	1,	/* mull %1\n */
        -:  956:/* 153 */	1,	/* xorl %%edx,%%edx\ndivl %1\n */
        -:  957:/* 154 */	1,	/* xorl %%edx,%%edx\ndivl %1\n */
        -:  958:/* 155 */	1,	/* cdq\nidivl %1\n */
        -:  959:/* 156 */	1,	/* cdq\nidivl %1\n */
        -:  960:/* 157 */	1,	/* movl %0,%c\n */
        -:  961:/* 158 */	1,	/* movl %0,%c\n */
        -:  962:/* 159 */	1,	/* movsbl %0,%c\n */
        -:  963:/* 160 */	1,	/* movswl %0,%c\n */
        -:  964:/* 161 */	1,	/* movzbl %0,%c\n */
        -:  965:/* 162 */	1,	/* movzwl %0,%c\n */
        -:  966:/* 163 */	1,	/* # extend\n */
        -:  967:/* 164 */	1,	/* # extend\n */
        -:  968:/* 165 */	1,	/* # extend\n */
        -:  969:/* 166 */	1,	/* # extend\n */
        -:  970:/* 167 */	1,	/* # truncate\n */
        -:  971:/* 168 */	1,	/* # truncate\n */
        -:  972:/* 169 */	1,	/* # truncate\n */
        -:  973:/* 170 */	1,	/* # truncate\n */
        -:  974:/* 171 */	0,	/* %0 */
        -:  975:/* 172 */	0,	/* %0 */
        -:  976:/* 173 */	0,	/* $%a */
        -:  977:/* 174 */	0,	/* $%a */
        -:  978:/* 175 */	1,	/* movb %1,%0\n */
        -:  979:/* 176 */	1,	/* movw %1,%0\n */
        -:  980:/* 177 */	1,	/* movl %1,%0\n */
        -:  981:/* 178 */	1,	/* movb %1,%0\n */
        -:  982:/* 179 */	1,	/* movw %1,%0\n */
        -:  983:/* 180 */	1,	/* movl %1,%0\n */
        -:  984:/* 181 */	1,	/* movl %1,%0\n */
        -:  985:/* 182 */	1,	/* pushl %0\n */
        -:  986:/* 183 */	1,	/* pushl %0\n */
        -:  987:/* 184 */	1,	/* pushl %0\n */
        -:  988:/* 185 */	1,	/* movl $%a,%%ecx\nrep\nmovsb\n */
        -:  989:/* 186 */	1,	/* subl $%a,%%esp\nmovl %%esp,%%edi\nmovl $%a,%%ecx\nrep\nmovsb\n */
        -:  990:/* 187 */	0,	/* l %0 */
        -:  991:/* 188 */	0,	/* s %0 */
        -:  992:/* 189 */	0,	/* s %0 */
        -:  993:/* 190 */	0,	/* l %0 */
        -:  994:/* 191 */	1,	/* fld%0\n */
        -:  995:/* 192 */	1,	/* fstpl %0\n */
        -:  996:/* 193 */	1,	/* fstps %0\n */
        -:  997:/* 194 */	1,	/* fstps %0\n */
        -:  998:/* 195 */	1,	/* subl $8,%%esp\nfstpl (%%esp)\n */
        -:  999:/* 196 */	1,	/* subl $4,%%esp\nfstps (%%esp)\n */
        -: 1000:/* 197 */	1,	/* fchs\n */
        -: 1001:/* 198 */	1,	/* fchs\n */
        -: 1002:/* 199 */	0,	/* %0 */
        -: 1003:/* 200 */	0,	/* p %%st(1),%%st */
        -: 1004:/* 201 */	1,	/* fadd%1\n */
        -: 1005:/* 202 */	1,	/* fadd%1\n */
        -: 1006:/* 203 */	1,	/* fdiv%1\n */
        -: 1007:/* 204 */	1,	/* fdiv%1\n */
        -: 1008:/* 205 */	1,	/* fmul%1\n */
        -: 1009:/* 206 */	1,	/* fmul%1\n */
        -: 1010:/* 207 */	1,	/* fsub%1\n */
        -: 1011:/* 208 */	1,	/* fsub%1\n */
        -: 1012:/* 209 */	1,	/* # CVFF8\n */
        -: 1013:/* 210 */	1,	/* sub $4,%%esp\nfstps (%%esp)\nflds (%%esp)\naddl $4,%%esp\n */
        -: 1014:/* 211 */	1,	/* fistpl %0\n */
        -: 1015:/* 212 */	1,	/* subl $4,%%esp\nfistpl 0(%%esp)\npopl %c\n */
        -: 1016:/* 213 */	1,	/* fildl %0\n */
        -: 1017:/* 214 */	1,	/* pushl %0\nfildl (%%esp)\naddl $4,%%esp\n */
        -: 1018:/* 215 */	1,	/* fildl %0\n */
        -: 1019:/* 216 */	1,	/* pushl %0\nfildl (%%esp)\naddl $4,%%esp\n */
        -: 1020:/* 217 */	0,	/* %a */
        -: 1021:/* 218 */	0,	/* *%0 */
        -: 1022:/* 219 */	0,	/* *%0 */
        -: 1023:/* 220 */	1,	/* %a:\n */
        -: 1024:/* 221 */	1,	/* jmp %0\n */
        -: 1025:/* 222 */	1,	/* cmpl %1,%0\nje %a\n */
        -: 1026:/* 223 */	1,	/* cmpl %1,%0\njge %a\n */
        -: 1027:/* 224 */	1,	/* cmpl %1,%0\njg %a\n */
        -: 1028:/* 225 */	1,	/* cmpl %1,%0\njle %a\n */
        -: 1029:/* 226 */	1,	/* cmpl %1,%0\njl %a\n */
        -: 1030:/* 227 */	1,	/* cmpl %1,%0\njne %a\n */
        -: 1031:/* 228 */	1,	/* cmpl %1,%0\njae %a\n */
        -: 1032:/* 229 */	1,	/* cmpl %1,%0\nja  %a\n */
        -: 1033:/* 230 */	1,	/* cmpl %1,%0\njbe %a\n */
        -: 1034:/* 231 */	1,	/* cmpl %1,%0\njb  %a\n */
        -: 1035:/* 232 */	1,	/* cmpl %1,%0\nje %a\n */
        -: 1036:/* 233 */	1,	/* cmpl %1,%0\njge %a\n */
        -: 1037:/* 234 */	1,	/* cmpl %1,%0\njg %a\n */
        -: 1038:/* 235 */	1,	/* cmpl %1,%0\njle %a\n */
        -: 1039:/* 236 */	1,	/* cmpl %1,%0\njl %a\n */
        -: 1040:/* 237 */	1,	/* cmpl %1,%0\njne %a\n */
        -: 1041:/* 238 */	1,	/* cmpl %1,%0\nje %a\n */
        -: 1042:/* 239 */	1,	/* cmpl %1,%0\njae %a\n */
        -: 1043:/* 240 */	1,	/* cmpl %1,%0\nja %a\n */
        -: 1044:/* 241 */	1,	/* cmpl %1,%0\njbe %a\n */
        -: 1045:/* 242 */	1,	/* cmpl %1,%0\njb %a\n */
        -: 1046:/* 243 */	1,	/* cmpl %1,%0\njne %a\n */
        -: 1047:/* 244 */	1,	/* testl %1,%0\nje %a\n */
        -: 1048:/* 245 */	1,	/* testl %1,%0\njne %a\n */
        -: 1049:/* 246 */	1,	/* testw %1,%0\nje %a\n */
        -: 1050:/* 247 */	1,	/* testw %1,%0\njne %a\n */
        -: 1051:/* 248 */	1,	/* testw %1,%0\nje %a\n */
        -: 1052:/* 249 */	1,	/* testw %1,%0\njne %a\n */
        -: 1053:/* 250 */	1,	/* testb %1,%0\nje %a\n */
        -: 1054:/* 251 */	0,	/* l %0 */
        -: 1055:/* 252 */	0,	/* s %0 */
        -: 1056:/* 253 */	0,	/* s %0 */
        -: 1057:/* 254 */	0,	/* p */
        -: 1058:/* 255 */	1,	/* fcomp%0\nfstsw %%ax\nsahf\nje %a\n */
        -: 1059:/* 256 */	1,	/* fcomp%0\nfstsw %%ax\nsahf\njbe %a\n */
        -: 1060:/* 257 */	1,	/* fcomp%0\nfstsw %%ax\nsahf\njb %a\n */
        -: 1061:/* 258 */	1,	/* fcomp%0\nfstsw %%ax\nsahf\njae %a\n */
        -: 1062:/* 259 */	1,	/* fcomp%0\nfstsw %%ax\nsahf\nja %a\n */
        -: 1063:/* 260 */	1,	/* fcomp%0\nfstsw %%ax\nsahf\njne %a\n */
        -: 1064:/* 261 */	1,	/* fcomp%0\nfstsw %%ax\nsahf\nje %a\n */
        -: 1065:/* 262 */	1,	/* fcomp%0\nfstsw %%ax\nsahf\njbe %a\n */
        -: 1066:/* 263 */	1,	/* fcomp%0\nfstsw %%ax\nsahf\njb %a\n */
        -: 1067:/* 264 */	1,	/* fcomp%0\nfstsw %%ax\nsahf\njae %a\n */
        -: 1068:/* 265 */	1,	/* fcomp%0\nfstsw %%ax\nsahf\nja %a\n */
        -: 1069:/* 266 */	1,	/* fcomp%0\nfstsw %%ax\nsahf\njne %a\n */
        -: 1070:/* 267 */	1,	/* fidivl %1\n */
        -: 1071:/* 268 */	1,	/* fidivrl %0\n */
        -: 1072:/* 269 */	1,	/* fidivs %1\n */
        -: 1073:/* 270 */	1,	/* fidivrs %0\n */
        -: 1074:/* 271 */	1,	/* fimull %1\n */
        -: 1075:/* 272 */	1,	/* fimuls %1\n */
        -: 1076:/* 273 */	1,	/* fisubl %1\n */
        -: 1077:/* 274 */	1,	/* fisubrl %0\n */
        -: 1078:/* 275 */	1,	/* fisubs %1\n */
        -: 1079:/* 276 */	1,	/* fisubrs %0\n */
        -: 1080:/* 277 */	1,	/* fiaddl %1\n */
        -: 1081:/* 278 */	1,	/* fiadds %1\n */
        -: 1082:/* 279 */	1,	/* fdivs %1\n */
        -: 1083:/* 280 */	1,	/* fsubs %1\n */
        -: 1084:/* 281 */	1,	/* fmuls %1\n */
        -: 1085:/* 282 */	1,	/* fdivs %1\n */
        -: 1086:/* 283 */	1,	/* fld%0\n */
        -: 1087:/* 284 */	1,	/* call %0\naddl $%a,%%esp\n */
        -: 1088:/* 285 */	1,	/* call %0\naddl $%a,%%esp\n */
        -: 1089:/* 286 */	1,	/* call %0\naddl $%a,%%esp\n */
        -: 1090:/* 287 */	1,	/* call %0\n */
        -: 1091:/* 288 */	1,	/* call %0\n */
        -: 1092:/* 289 */	1,	/* call %0\n */
        -: 1093:/* 290 */	1,	/* call %0\naddl $%a,%%esp\n */
        -: 1094:/* 291 */	1,	/* call %0\n */
        -: 1095:/* 292 */	1,	/* call %0\naddl $%a,%%esp\n */
        -: 1096:/* 293 */	1,	/* call %0\n */
        -: 1097:/* 294 */	1,	/* call %0\naddl $%a,%%esp\nfstp %%st(0)\n */
        -: 1098:/* 295 */	1,	/* call %0\nfstp %%st(0)\n */
        -: 1099:/* 296 */	1,	/* call %0\naddl $%a,%%esp\n */
        -: 1100:/* 297 */	1,	/* call %0\n */
        -: 1101:/* 298 */	1,	/* call %0\naddl $%a,%%esp\nfstp %%st(0)\n */
        -: 1102:/* 299 */	1,	/* call %0\nfstp %%st(0)\n */
        -: 1103:/* 300 */	1,	/* # ret\n */
        -: 1104:/* 301 */	1,	/* # ret\n */
        -: 1105:/* 302 */	1,	/* # ret\n */
        -: 1106:/* 303 */	1,	/* # ret\n */
        -: 1107:/* 304 */	1,	/* # ret\n */
        -: 1108:};
        -: 1109:
        -: 1110:static char *_string[] = {
        -: 1111:/* 0 */	0,
        -: 1112:/* 1 */	"reg: INDIRI1(VREGP)",
        -: 1113:/* 2 */	"reg: INDIRU1(VREGP)",
        -: 1114:/* 3 */	"reg: INDIRI2(VREGP)",
        -: 1115:/* 4 */	"reg: INDIRU2(VREGP)",
        -: 1116:/* 5 */	"reg: INDIRI4(VREGP)",
        -: 1117:/* 6 */	"reg: INDIRP4(VREGP)",
        -: 1118:/* 7 */	"reg: INDIRU4(VREGP)",
        -: 1119:/* 8 */	"reg: INDIRI8(VREGP)",
        -: 1120:/* 9 */	"reg: INDIRP8(VREGP)",
        -: 1121:/* 10 */	"reg: INDIRU8(VREGP)",
        -: 1122:/* 11 */	"freg: INDIRF4(VREGP)",
        -: 1123:/* 12 */	"freg: INDIRF8(VREGP)",
        -: 1124:/* 13 */	"stmt: ASGNI1(VREGP,reg)",
        -: 1125:/* 14 */	"stmt: ASGNU1(VREGP,reg)",
        -: 1126:/* 15 */	"stmt: ASGNI2(VREGP,reg)",
        -: 1127:/* 16 */	"stmt: ASGNU2(VREGP,reg)",
        -: 1128:/* 17 */	"stmt: ASGNF4(VREGP,reg)",
        -: 1129:/* 18 */	"stmt: ASGNI4(VREGP,reg)",
        -: 1130:/* 19 */	"stmt: ASGNP4(VREGP,reg)",
        -: 1131:/* 20 */	"stmt: ASGNU4(VREGP,reg)",
        -: 1132:/* 21 */	"stmt: ASGNF8(VREGP,reg)",
        -: 1133:/* 22 */	"stmt: ASGNI8(VREGP,reg)",
        -: 1134:/* 23 */	"stmt: ASGNP8(VREGP,reg)",
        -: 1135:/* 24 */	"stmt: ASGNU8(VREGP,reg)",
        -: 1136:/* 25 */	"cnst: CNSTI1",
        -: 1137:/* 26 */	"cnst: CNSTU1",
        -: 1138:/* 27 */	"cnst: CNSTI2",
        -: 1139:/* 28 */	"cnst: CNSTU2",
        -: 1140:/* 29 */	"cnst: CNSTI4",
        -: 1141:/* 30 */	"cnst: CNSTU4",
        -: 1142:/* 31 */	"cnst: CNSTP4",
        -: 1143:/* 32 */	"cnst: CNSTI8",
        -: 1144:/* 33 */	"cnst: CNSTU8",
        -: 1145:/* 34 */	"cnst: CNSTP8",
        -: 1146:/* 35 */	"con: cnst",
        -: 1147:/* 36 */	"stmt: reg",
        -: 1148:/* 37 */	"stmt: freg",
        -: 1149:/* 38 */	"acon: ADDRGP4",
        -: 1150:/* 39 */	"acon: ADDRGP8",
        -: 1151:/* 40 */	"acon: cnst",
        -: 1152:/* 41 */	"baseaddr: ADDRGP4",
        -: 1153:/* 42 */	"base: reg",
        -: 1154:/* 43 */	"base: ADDI4(reg,acon)",
        -: 1155:/* 44 */	"base: ADDP4(reg,acon)",
        -: 1156:/* 45 */	"base: ADDU4(reg,acon)",
        -: 1157:/* 46 */	"base: ADDRFP4",
        -: 1158:/* 47 */	"base: ADDRLP4",
        -: 1159:/* 48 */	"index: reg",
        -: 1160:/* 49 */	"index: LSHI4(reg,con1)",
        -: 1161:/* 50 */	"index: LSHI4(reg,con2)",
        -: 1162:/* 51 */	"index: LSHI4(reg,con3)",
        -: 1163:/* 52 */	"index: LSHU4(reg,con1)",
        -: 1164:/* 53 */	"index: LSHU4(reg,con2)",
        -: 1165:/* 54 */	"index: LSHU4(reg,con3)",
        -: 1166:/* 55 */	"con0: CNSTI4",
        -: 1167:/* 56 */	"con0: CNSTU4",
        -: 1168:/* 57 */	"con1: CNSTI4",
        -: 1169:/* 58 */	"con1: CNSTU4",
        -: 1170:/* 59 */	"con2: CNSTI4",
        -: 1171:/* 60 */	"con2: CNSTU4",
        -: 1172:/* 61 */	"con3: CNSTI4",
        -: 1173:/* 62 */	"con3: CNSTU4",
        -: 1174:/* 63 */	"addr: base",
        -: 1175:/* 64 */	"addr: baseaddr",
        -: 1176:/* 65 */	"addr: ADDI4(index,baseaddr)",
        -: 1177:/* 66 */	"addr: ADDP4(index,baseaddr)",
        -: 1178:/* 67 */	"addr: ADDU4(index,baseaddr)",
        -: 1179:/* 68 */	"addr: ADDI4(reg,baseaddr)",
        -: 1180:/* 69 */	"addr: ADDP4(reg,baseaddr)",
        -: 1181:/* 70 */	"addr: ADDU4(reg,baseaddr)",
        -: 1182:/* 71 */	"addr: ADDI4(index,reg)",
        -: 1183:/* 72 */	"addr: ADDP4(index,reg)",
        -: 1184:/* 73 */	"addr: ADDU4(index,reg)",
        -: 1185:/* 74 */	"addr: index",
        -: 1186:/* 75 */	"mem1: INDIRI1(addr)",
        -: 1187:/* 76 */	"mem1: INDIRU1(addr)",
        -: 1188:/* 77 */	"mem2: INDIRI2(addr)",
        -: 1189:/* 78 */	"mem2: INDIRU2(addr)",
        -: 1190:/* 79 */	"mem4: INDIRI4(addr)",
        -: 1191:/* 80 */	"mem4: INDIRU4(addr)",
        -: 1192:/* 81 */	"mem4: INDIRP4(addr)",
        -: 1193:/* 82 */	"rc: reg",
        -: 1194:/* 83 */	"rc: con",
        -: 1195:/* 84 */	"mr: reg",
        -: 1196:/* 85 */	"mr: mem4",
        -: 1197:/* 86 */	"mr1: reg",
        -: 1198:/* 87 */	"mr1: mem1",
        -: 1199:/* 88 */	"mr2: reg",
        -: 1200:/* 89 */	"mr2: mem2",
        -: 1201:/* 90 */	"mrc: mem4",
        -: 1202:/* 91 */	"mrc: mem1",
        -: 1203:/* 92 */	"mrc: mem2",
        -: 1204:/* 93 */	"mrc: rc",
        -: 1205:/* 94 */	"reg: addr",
        -: 1206:/* 95 */	"reg: mr",
        -: 1207:/* 96 */	"reg: mr1",
        -: 1208:/* 97 */	"reg: mr2",
        -: 1209:/* 98 */	"reg: con",
        -: 1210:/* 99 */	"reg: LOADI1(reg)",
        -: 1211:/* 100 */	"reg: LOADI2(reg)",
        -: 1212:/* 101 */	"reg: LOADI4(reg)",
        -: 1213:/* 102 */	"reg: LOADU1(reg)",
        -: 1214:/* 103 */	"reg: LOADU2(reg)",
        -: 1215:/* 104 */	"reg: LOADU4(reg)",
        -: 1216:/* 105 */	"reg: LOADP4(reg)",
        -: 1217:/* 106 */	"reg: ADDI4(reg,mrc)",
        -: 1218:/* 107 */	"reg: ADDP4(reg,mrc)",
        -: 1219:/* 108 */	"reg: ADDU4(reg,mrc)",
        -: 1220:/* 109 */	"reg: SUBI4(reg,mrc)",
        -: 1221:/* 110 */	"reg: SUBP4(reg,mrc)",
        -: 1222:/* 111 */	"reg: SUBU4(reg,mrc)",
        -: 1223:/* 112 */	"reg: BANDI4(reg,mrc)",
        -: 1224:/* 113 */	"reg: BORI4(reg,mrc)",
        -: 1225:/* 114 */	"reg: BXORI4(reg,mrc)",
        -: 1226:/* 115 */	"reg: BANDU4(reg,mrc)",
        -: 1227:/* 116 */	"reg: BORU4(reg,mrc)",
        -: 1228:/* 117 */	"reg: BXORU4(reg,mrc)",
        -: 1229:/* 118 */	"stmt: ASGNI4(addr,ADDI4(mem4,con1))",
        -: 1230:/* 119 */	"stmt: ASGNI4(addr,ADDU4(mem4,con1))",
        -: 1231:/* 120 */	"stmt: ASGNP4(addr,ADDP4(mem4,con1))",
        -: 1232:/* 121 */	"stmt: ASGNI4(addr,SUBI4(mem4,con1))",
        -: 1233:/* 122 */	"stmt: ASGNI4(addr,SUBU4(mem4,con1))",
        -: 1234:/* 123 */	"stmt: ASGNP4(addr,SUBP4(mem4,con1))",
        -: 1235:/* 124 */	"stmt: ASGNI4(addr,ADDI4(mem4,rc))",
        -: 1236:/* 125 */	"stmt: ASGNI4(addr,SUBI4(mem4,rc))",
        -: 1237:/* 126 */	"stmt: ASGNU4(addr,ADDU4(mem4,rc))",
        -: 1238:/* 127 */	"stmt: ASGNU4(addr,SUBU4(mem4,rc))",
        -: 1239:/* 128 */	"stmt: ASGNI4(addr,BANDI4(mem4,rc))",
        -: 1240:/* 129 */	"stmt: ASGNI4(addr,BORI4(mem4,rc))",
        -: 1241:/* 130 */	"stmt: ASGNI4(addr,BXORI4(mem4,rc))",
        -: 1242:/* 131 */	"stmt: ASGNU4(addr,BANDU4(mem4,rc))",
        -: 1243:/* 132 */	"stmt: ASGNU4(addr,BORU4(mem4,rc))",
        -: 1244:/* 133 */	"stmt: ASGNU4(addr,BXORU4(mem4,rc))",
        -: 1245:/* 134 */	"reg: BCOMI4(reg)",
        -: 1246:/* 135 */	"reg: BCOMU4(reg)",
        -: 1247:/* 136 */	"reg: NEGI4(reg)",
        -: 1248:/* 137 */	"stmt: ASGNI4(addr,BCOMI4(mem4))",
        -: 1249:/* 138 */	"stmt: ASGNU4(addr,BCOMU4(mem4))",
        -: 1250:/* 139 */	"stmt: ASGNI4(addr,NEGI4(mem4))",
        -: 1251:/* 140 */	"reg: LSHI4(reg,rc5)",
        -: 1252:/* 141 */	"reg: LSHU4(reg,rc5)",
        -: 1253:/* 142 */	"reg: RSHI4(reg,rc5)",
        -: 1254:/* 143 */	"reg: RSHU4(reg,rc5)",
        -: 1255:/* 144 */	"stmt: ASGNI4(addr,LSHI4(mem4,rc5))",
        -: 1256:/* 145 */	"stmt: ASGNI4(addr,LSHU4(mem4,rc5))",
        -: 1257:/* 146 */	"stmt: ASGNI4(addr,RSHI4(mem4,rc5))",
        -: 1258:/* 147 */	"stmt: ASGNI4(addr,RSHU4(mem4,rc5))",
        -: 1259:/* 148 */	"rc5: CNSTI4",
        -: 1260:/* 149 */	"rc5: reg",
        -: 1261:/* 150 */	"reg: MULI4(reg,mrc)",
        -: 1262:/* 151 */	"reg: MULI4(con,mr)",
        -: 1263:/* 152 */	"reg: MULU4(reg,mr)",
        -: 1264:/* 153 */	"reg: DIVU4(reg,reg)",
        -: 1265:/* 154 */	"reg: MODU4(reg,reg)",
        -: 1266:/* 155 */	"reg: DIVI4(reg,reg)",
        -: 1267:/* 156 */	"reg: MODI4(reg,reg)",
        -: 1268:/* 157 */	"reg: CVPU4(reg)",
        -: 1269:/* 158 */	"reg: CVUP4(reg)",
        -: 1270:/* 159 */	"reg: CVII4(INDIRI1(addr))",
        -: 1271:/* 160 */	"reg: CVII4(INDIRI2(addr))",
        -: 1272:/* 161 */	"reg: CVUU4(INDIRU1(addr))",
        -: 1273:/* 162 */	"reg: CVUU4(INDIRU2(addr))",
        -: 1274:/* 163 */	"reg: CVII4(reg)",
        -: 1275:/* 164 */	"reg: CVIU4(reg)",
        -: 1276:/* 165 */	"reg: CVUI4(reg)",
        -: 1277:/* 166 */	"reg: CVUU4(reg)",
        -: 1278:/* 167 */	"reg: CVII1(reg)",
        -: 1279:/* 168 */	"reg: CVII2(reg)",
        -: 1280:/* 169 */	"reg: CVUU1(reg)",
        -: 1281:/* 170 */	"reg: CVUU2(reg)",
        -: 1282:/* 171 */	"mrca: mem4",
        -: 1283:/* 172 */	"mrca: rc",
        -: 1284:/* 173 */	"mrca: ADDRGP4",
        -: 1285:/* 174 */	"mrca: ADDRGP8",
        -: 1286:/* 175 */	"stmt: ASGNI1(addr,rc)",
        -: 1287:/* 176 */	"stmt: ASGNI2(addr,rc)",
        -: 1288:/* 177 */	"stmt: ASGNI4(addr,rc)",
        -: 1289:/* 178 */	"stmt: ASGNU1(addr,rc)",
        -: 1290:/* 179 */	"stmt: ASGNU2(addr,rc)",
        -: 1291:/* 180 */	"stmt: ASGNU4(addr,rc)",
        -: 1292:/* 181 */	"stmt: ASGNP4(addr,rc)",
        -: 1293:/* 182 */	"stmt: ARGI4(mrca)",
        -: 1294:/* 183 */	"stmt: ARGU4(mrca)",
        -: 1295:/* 184 */	"stmt: ARGP4(mrca)",
        -: 1296:/* 185 */	"stmt: ASGNB(reg,INDIRB(reg))",
        -: 1297:/* 186 */	"stmt: ARGB(INDIRB(reg))",
        -: 1298:/* 187 */	"memf: INDIRF8(addr)",
        -: 1299:/* 188 */	"memf: INDIRF4(addr)",
        -: 1300:/* 189 */	"memf: CVFF8(INDIRF4(addr))",
        -: 1301:/* 190 */	"memf: CVFF4(INDIRF8(addr))",
        -: 1302:/* 191 */	"freg: memf",
        -: 1303:/* 192 */	"stmt: ASGNF8(addr,freg)",
        -: 1304:/* 193 */	"stmt: ASGNF4(addr,freg)",
        -: 1305:/* 194 */	"stmt: ASGNF4(addr,CVFF4(freg))",
        -: 1306:/* 195 */	"stmt: ARGF8(freg)",
        -: 1307:/* 196 */	"stmt: ARGF4(freg)",
        -: 1308:/* 197 */	"freg: NEGF8(freg)",
        -: 1309:/* 198 */	"freg: NEGF4(freg)",
        -: 1310:/* 199 */	"flt: memf",
        -: 1311:/* 200 */	"flt: freg",
        -: 1312:/* 201 */	"freg: ADDF4(freg,flt)",
        -: 1313:/* 202 */	"freg: ADDF8(freg,flt)",
        -: 1314:/* 203 */	"freg: DIVF4(freg,flt)",
        -: 1315:/* 204 */	"freg: DIVF8(freg,flt)",
        -: 1316:/* 205 */	"freg: MULF4(freg,flt)",
        -: 1317:/* 206 */	"freg: MULF8(freg,flt)",
        -: 1318:/* 207 */	"freg: SUBF4(freg,flt)",
        -: 1319:/* 208 */	"freg: SUBF8(freg,flt)",
        -: 1320:/* 209 */	"freg: CVFF8(freg)",
        -: 1321:/* 210 */	"freg: CVFF4(freg)",
        -: 1322:/* 211 */	"stmt: ASGNI4(addr,CVFI4(freg))",
        -: 1323:/* 212 */	"reg: CVFI4(freg)",
        -: 1324:/* 213 */	"freg: CVIF8(INDIRI4(addr))",
        -: 1325:/* 214 */	"freg: CVIF8(reg)",
        -: 1326:/* 215 */	"freg: CVIF4(INDIRI4(addr))",
        -: 1327:/* 216 */	"freg: CVIF4(reg)",
        -: 1328:/* 217 */	"addrj: ADDRGP4",
        -: 1329:/* 218 */	"addrj: reg",
        -: 1330:/* 219 */	"addrj: mem4",
        -: 1331:/* 220 */	"stmt: LABELV",
        -: 1332:/* 221 */	"stmt: JUMPV(addrj)",
        -: 1333:/* 222 */	"stmt: EQI4(mem4,rc)",
        -: 1334:/* 223 */	"stmt: GEI4(mem4,rc)",
        -: 1335:/* 224 */	"stmt: GTI4(mem4,rc)",
        -: 1336:/* 225 */	"stmt: LEI4(mem4,rc)",
        -: 1337:/* 226 */	"stmt: LTI4(mem4,rc)",
        -: 1338:/* 227 */	"stmt: NEI4(mem4,rc)",
        -: 1339:/* 228 */	"stmt: GEU4(mem4,rc)",
        -: 1340:/* 229 */	"stmt: GTU4(mem4,rc)",
        -: 1341:/* 230 */	"stmt: LEU4(mem4,rc)",
        -: 1342:/* 231 */	"stmt: LTU4(mem4,rc)",
        -: 1343:/* 232 */	"stmt: EQI4(reg,mrc)",
        -: 1344:/* 233 */	"stmt: GEI4(reg,mrc)",
        -: 1345:/* 234 */	"stmt: GTI4(reg,mrc)",
        -: 1346:/* 235 */	"stmt: LEI4(reg,mrc)",
        -: 1347:/* 236 */	"stmt: LTI4(reg,mrc)",
        -: 1348:/* 237 */	"stmt: NEI4(reg,mrc)",
        -: 1349:/* 238 */	"stmt: EQU4(reg,mrc)",
        -: 1350:/* 239 */	"stmt: GEU4(reg,mrc)",
        -: 1351:/* 240 */	"stmt: GTU4(reg,mrc)",
        -: 1352:/* 241 */	"stmt: LEU4(reg,mrc)",
        -: 1353:/* 242 */	"stmt: LTU4(reg,mrc)",
        -: 1354:/* 243 */	"stmt: NEU4(reg,mrc)",
        -: 1355:/* 244 */	"stmt: EQI4(BANDU4(mr,con),con0)",
        -: 1356:/* 245 */	"stmt: NEI4(BANDU4(mr,con),con0)",
        -: 1357:/* 246 */	"stmt: EQI4(BANDU4(CVII2(INDIRI2(addr)),con),con0)",
        -: 1358:/* 247 */	"stmt: NEI4(BANDU4(CVII2(INDIRI2(addr)),con),con0)",
        -: 1359:/* 248 */	"stmt: EQI4(BANDU4(CVIU2(INDIRI2(addr)),con),con0)",
        -: 1360:/* 249 */	"stmt: NEI4(BANDU4(CVIU2(INDIRI2(addr)),con),con0)",
        -: 1361:/* 250 */	"stmt: EQI4(BANDU4(CVII1(INDIRI1(addr)),con),con0)",
        -: 1362:/* 251 */	"cmpf: INDIRF8(addr)",
        -: 1363:/* 252 */	"cmpf: INDIRF4(addr)",
        -: 1364:/* 253 */	"cmpf: CVFF8(INDIRF4(addr))",
        -: 1365:/* 254 */	"cmpf: freg",
        -: 1366:/* 255 */	"stmt: EQF8(cmpf,freg)",
        -: 1367:/* 256 */	"stmt: GEF8(cmpf,freg)",
        -: 1368:/* 257 */	"stmt: GTF8(cmpf,freg)",
        -: 1369:/* 258 */	"stmt: LEF8(cmpf,freg)",
        -: 1370:/* 259 */	"stmt: LTF8(cmpf,freg)",
        -: 1371:/* 260 */	"stmt: NEF8(cmpf,freg)",
        -: 1372:/* 261 */	"stmt: EQF4(cmpf,freg)",
        -: 1373:/* 262 */	"stmt: GEF4(cmpf,freg)",
        -: 1374:/* 263 */	"stmt: GTF4(cmpf,freg)",
        -: 1375:/* 264 */	"stmt: LEF4(cmpf,freg)",
        -: 1376:/* 265 */	"stmt: LTF4(cmpf,freg)",
        -: 1377:/* 266 */	"stmt: NEF4(cmpf,freg)",
        -: 1378:/* 267 */	"freg: DIVF8(freg,CVIF8(INDIRI4(addr)))",
        -: 1379:/* 268 */	"freg: DIVF8(CVIF8(INDIRI4(addr)),freg)",
        -: 1380:/* 269 */	"freg: DIVF8(freg,CVIF8(CVII2(INDIRI2(addr))))",
        -: 1381:/* 270 */	"freg: DIVF8(CVIF8(CVII2(INDIRI2(addr))),freg)",
        -: 1382:/* 271 */	"freg: MULF8(freg,CVIF8(INDIRI4(addr)))",
        -: 1383:/* 272 */	"freg: MULF8(freg,CVIF8(CVII2(INDIRI2(addr))))",
        -: 1384:/* 273 */	"freg: SUBF8(freg,CVIF8(INDIRI4(addr)))",
        -: 1385:/* 274 */	"freg: SUBF8(CVIF8(INDIRI4(addr)),freg)",
        -: 1386:/* 275 */	"freg: SUBF8(freg,CVIF8(CVII2(INDIRI2(addr))))",
        -: 1387:/* 276 */	"freg: SUBF8(CVIF8(CVII2(INDIRI2(addr))),freg)",
        -: 1388:/* 277 */	"freg: ADDF8(freg,CVIF8(INDIRI4(addr)))",
        -: 1389:/* 278 */	"freg: ADDF8(freg,CVIF8(CVII2(INDIRI2(addr))))",
        -: 1390:/* 279 */	"freg: ADDF8(freg,CVFF8(INDIRF4(addr)))",
        -: 1391:/* 280 */	"freg: SUBF8(freg,CVFF8(INDIRF4(addr)))",
        -: 1392:/* 281 */	"freg: MULF8(freg,CVFF8(INDIRF4(addr)))",
        -: 1393:/* 282 */	"freg: DIVF8(freg,CVFF8(INDIRF4(addr)))",
        -: 1394:/* 283 */	"freg: LOADF8(memf)",
        -: 1395:/* 284 */	"reg: CALLI4(addrj)",
        -: 1396:/* 285 */	"reg: CALLU4(addrj)",
        -: 1397:/* 286 */	"reg: CALLP4(addrj)",
        -: 1398:/* 287 */	"reg: CALLI4(addrj)",
        -: 1399:/* 288 */	"reg: CALLU4(addrj)",
        -: 1400:/* 289 */	"reg: CALLP4(addrj)",
        -: 1401:/* 290 */	"stmt: CALLV(addrj)",
        -: 1402:/* 291 */	"stmt: CALLV(addrj)",
        -: 1403:/* 292 */	"freg: CALLF4(addrj)",
        -: 1404:/* 293 */	"freg: CALLF4(addrj)",
        -: 1405:/* 294 */	"stmt: CALLF4(addrj)",
        -: 1406:/* 295 */	"stmt: CALLF4(addrj)",
        -: 1407:/* 296 */	"freg: CALLF8(addrj)",
        -: 1408:/* 297 */	"freg: CALLF8(addrj)",
        -: 1409:/* 298 */	"stmt: CALLF8(addrj)",
        -: 1410:/* 299 */	"stmt: CALLF8(addrj)",
        -: 1411:/* 300 */	"stmt: RETI4(reg)",
        -: 1412:/* 301 */	"stmt: RETU4(reg)",
        -: 1413:/* 302 */	"stmt: RETP4(reg)",
        -: 1414:/* 303 */	"stmt: RETF4(freg)",
        -: 1415:/* 304 */	"stmt: RETF8(freg)",
        -: 1416:};
        -: 1417:
        -: 1418:static short _decode_stmt[] = {
        -: 1419:	0,
        -: 1420:	13,
        -: 1421:	14,
        -: 1422:	15,
        -: 1423:	16,
        -: 1424:	17,
        -: 1425:	18,
        -: 1426:	19,
        -: 1427:	20,
        -: 1428:	21,
        -: 1429:	22,
        -: 1430:	23,
        -: 1431:	24,
        -: 1432:	36,
        -: 1433:	37,
        -: 1434:	118,
        -: 1435:	119,
        -: 1436:	120,
        -: 1437:	121,
        -: 1438:	122,
        -: 1439:	123,
        -: 1440:	124,
        -: 1441:	125,
        -: 1442:	126,
        -: 1443:	127,
        -: 1444:	128,
        -: 1445:	129,
        -: 1446:	130,
        -: 1447:	131,
        -: 1448:	132,
        -: 1449:	133,
        -: 1450:	137,
        -: 1451:	138,
        -: 1452:	139,
        -: 1453:	144,
        -: 1454:	145,
        -: 1455:	146,
        -: 1456:	147,
        -: 1457:	175,
        -: 1458:	176,
        -: 1459:	177,
        -: 1460:	178,
        -: 1461:	179,
        -: 1462:	180,
        -: 1463:	181,
        -: 1464:	182,
        -: 1465:	183,
        -: 1466:	184,
        -: 1467:	185,
        -: 1468:	186,
        -: 1469:	192,
        -: 1470:	193,
        -: 1471:	194,
        -: 1472:	195,
        -: 1473:	196,
        -: 1474:	211,
        -: 1475:	220,
        -: 1476:	221,
        -: 1477:	222,
        -: 1478:	223,
        -: 1479:	224,
        -: 1480:	225,
        -: 1481:	226,
        -: 1482:	227,
        -: 1483:	228,
        -: 1484:	229,
        -: 1485:	230,
        -: 1486:	231,
        -: 1487:	232,
        -: 1488:	233,
        -: 1489:	234,
        -: 1490:	235,
        -: 1491:	236,
        -: 1492:	237,
        -: 1493:	238,
        -: 1494:	239,
        -: 1495:	240,
        -: 1496:	241,
        -: 1497:	242,
        -: 1498:	243,
        -: 1499:	244,
        -: 1500:	245,
        -: 1501:	246,
        -: 1502:	247,
        -: 1503:	248,
        -: 1504:	249,
        -: 1505:	250,
        -: 1506:	255,
        -: 1507:	256,
        -: 1508:	257,
        -: 1509:	258,
        -: 1510:	259,
        -: 1511:	260,
        -: 1512:	261,
        -: 1513:	262,
        -: 1514:	263,
        -: 1515:	264,
        -: 1516:	265,
        -: 1517:	266,
        -: 1518:	290,
        -: 1519:	291,
        -: 1520:	294,
        -: 1521:	295,
        -: 1522:	298,
        -: 1523:	299,
        -: 1524:	300,
        -: 1525:	301,
        -: 1526:	302,
        -: 1527:	303,
        -: 1528:	304,
        -: 1529:};
        -: 1530:
        -: 1531:static short _decode_reg[] = {
        -: 1532:	0,
        -: 1533:	1,
        -: 1534:	2,
        -: 1535:	3,
        -: 1536:	4,
        -: 1537:	5,
        -: 1538:	6,
        -: 1539:	7,
        -: 1540:	8,
        -: 1541:	9,
        -: 1542:	10,
        -: 1543:	94,
        -: 1544:	95,
        -: 1545:	96,
        -: 1546:	97,
        -: 1547:	98,
        -: 1548:	99,
        -: 1549:	100,
        -: 1550:	101,
        -: 1551:	102,
        -: 1552:	103,
        -: 1553:	104,
        -: 1554:	105,
        -: 1555:	106,
        -: 1556:	107,
        -: 1557:	108,
        -: 1558:	109,
        -: 1559:	110,
        -: 1560:	111,
        -: 1561:	112,
        -: 1562:	113,
        -: 1563:	114,
        -: 1564:	115,
        -: 1565:	116,
        -: 1566:	117,
        -: 1567:	134,
        -: 1568:	135,
        -: 1569:	136,
        -: 1570:	140,
        -: 1571:	141,
        -: 1572:	142,
        -: 1573:	143,
        -: 1574:	150,
        -: 1575:	151,
        -: 1576:	152,
        -: 1577:	153,
        -: 1578:	154,
        -: 1579:	155,
        -: 1580:	156,
        -: 1581:	157,
        -: 1582:	158,
        -: 1583:	159,
        -: 1584:	160,
        -: 1585:	161,
        -: 1586:	162,
        -: 1587:	163,
        -: 1588:	164,
        -: 1589:	165,
        -: 1590:	166,
        -: 1591:	167,
        -: 1592:	168,
        -: 1593:	169,
        -: 1594:	170,
        -: 1595:	212,
        -: 1596:	284,
        -: 1597:	285,
        -: 1598:	286,
        -: 1599:	287,
        -: 1600:	288,
        -: 1601:	289,
        -: 1602:};
        -: 1603:
        -: 1604:static short _decode_freg[] = {
        -: 1605:	0,
        -: 1606:	11,
        -: 1607:	12,
        -: 1608:	191,
        -: 1609:	197,
        -: 1610:	198,
        -: 1611:	201,
        -: 1612:	202,
        -: 1613:	203,
        -: 1614:	204,
        -: 1615:	205,
        -: 1616:	206,
        -: 1617:	207,
        -: 1618:	208,
        -: 1619:	209,
        -: 1620:	210,
        -: 1621:	213,
        -: 1622:	214,
        -: 1623:	215,
        -: 1624:	216,
        -: 1625:	267,
        -: 1626:	268,
        -: 1627:	269,
        -: 1628:	270,
        -: 1629:	271,
        -: 1630:	272,
        -: 1631:	273,
        -: 1632:	274,
        -: 1633:	275,
        -: 1634:	276,
        -: 1635:	277,
        -: 1636:	278,
        -: 1637:	279,
        -: 1638:	280,
        -: 1639:	281,
        -: 1640:	282,
        -: 1641:	283,
        -: 1642:	292,
        -: 1643:	293,
        -: 1644:	296,
        -: 1645:	297,
        -: 1646:};
        -: 1647:
        -: 1648:static short _decode_cnst[] = {
        -: 1649:	0,
        -: 1650:	25,
        -: 1651:	26,
        -: 1652:	27,
        -: 1653:	28,
        -: 1654:	29,
        -: 1655:	30,
        -: 1656:	31,
        -: 1657:	32,
        -: 1658:	33,
        -: 1659:	34,
        -: 1660:};
        -: 1661:
        -: 1662:static short _decode_con[] = {
        -: 1663:	0,
        -: 1664:	35,
        -: 1665:};
        -: 1666:
        -: 1667:static short _decode_acon[] = {
        -: 1668:	0,
        -: 1669:	38,
        -: 1670:	39,
        -: 1671:	40,
        -: 1672:};
        -: 1673:
        -: 1674:static short _decode_baseaddr[] = {
        -: 1675:	0,
        -: 1676:	41,
        -: 1677:};
        -: 1678:
        -: 1679:static short _decode_base[] = {
        -: 1680:	0,
        -: 1681:	42,
        -: 1682:	43,
        -: 1683:	44,
        -: 1684:	45,
        -: 1685:	46,
        -: 1686:	47,
        -: 1687:};
        -: 1688:
        -: 1689:static short _decode_index[] = {
        -: 1690:	0,
        -: 1691:	48,
        -: 1692:	49,
        -: 1693:	50,
        -: 1694:	51,
        -: 1695:	52,
        -: 1696:	53,
        -: 1697:	54,
        -: 1698:};
        -: 1699:
        -: 1700:static short _decode_con1[] = {
        -: 1701:	0,
        -: 1702:	57,
        -: 1703:	58,
        -: 1704:};
        -: 1705:
        -: 1706:static short _decode_con2[] = {
        -: 1707:	0,
        -: 1708:	59,
        -: 1709:	60,
        -: 1710:};
        -: 1711:
        -: 1712:static short _decode_con3[] = {
        -: 1713:	0,
        -: 1714:	61,
        -: 1715:	62,
        -: 1716:};
        -: 1717:
        -: 1718:static short _decode_con0[] = {
        -: 1719:	0,
        -: 1720:	55,
        -: 1721:	56,
        -: 1722:};
        -: 1723:
        -: 1724:static short _decode_addr[] = {
        -: 1725:	0,
        -: 1726:	63,
        -: 1727:	64,
        -: 1728:	65,
        -: 1729:	66,
        -: 1730:	67,
        -: 1731:	68,
        -: 1732:	69,
        -: 1733:	70,
        -: 1734:	71,
        -: 1735:	72,
        -: 1736:	73,
        -: 1737:	74,
        -: 1738:};
        -: 1739:
        -: 1740:static short _decode_mem1[] = {
        -: 1741:	0,
        -: 1742:	75,
        -: 1743:	76,
        -: 1744:};
        -: 1745:
        -: 1746:static short _decode_mem2[] = {
        -: 1747:	0,
        -: 1748:	77,
        -: 1749:	78,
        -: 1750:};
        -: 1751:
        -: 1752:static short _decode_mem4[] = {
        -: 1753:	0,
        -: 1754:	79,
        -: 1755:	80,
        -: 1756:	81,
        -: 1757:};
        -: 1758:
        -: 1759:static short _decode_rc[] = {
        -: 1760:	0,
        -: 1761:	82,
        -: 1762:	83,
        -: 1763:};
        -: 1764:
        -: 1765:static short _decode_mr[] = {
        -: 1766:	0,
        -: 1767:	84,
        -: 1768:	85,
        -: 1769:};
        -: 1770:
        -: 1771:static short _decode_mr1[] = {
        -: 1772:	0,
        -: 1773:	86,
        -: 1774:	87,
        -: 1775:};
        -: 1776:
        -: 1777:static short _decode_mr2[] = {
        -: 1778:	0,
        -: 1779:	88,
        -: 1780:	89,
        -: 1781:};
        -: 1782:
        -: 1783:static short _decode_mrc[] = {
        -: 1784:	0,
        -: 1785:	90,
        -: 1786:	91,
        -: 1787:	92,
        -: 1788:	93,
        -: 1789:};
        -: 1790:
        -: 1791:static short _decode_rc5[] = {
        -: 1792:	0,
        -: 1793:	148,
        -: 1794:	149,
        -: 1795:};
        -: 1796:
        -: 1797:static short _decode_mrca[] = {
        -: 1798:	0,
        -: 1799:	171,
        -: 1800:	172,
        -: 1801:	173,
        -: 1802:	174,
        -: 1803:};
        -: 1804:
        -: 1805:static short _decode_memf[] = {
        -: 1806:	0,
        -: 1807:	187,
        -: 1808:	188,
        -: 1809:	189,
        -: 1810:	190,
        -: 1811:};
        -: 1812:
        -: 1813:static short _decode_flt[] = {
        -: 1814:	0,
        -: 1815:	199,
        -: 1816:	200,
        -: 1817:};
        -: 1818:
        -: 1819:static short _decode_addrj[] = {
        -: 1820:	0,
        -: 1821:	217,
        -: 1822:	218,
        -: 1823:	219,
        -: 1824:};
        -: 1825:
        -: 1826:static short _decode_cmpf[] = {
        -: 1827:	0,
        -: 1828:	251,
        -: 1829:	252,
        -: 1830:	253,
        -: 1831:	254,
        -: 1832:};
        -: 1833:
function _rule called 0 returned 0% blocks executed 0%
    #####: 1834:static int _rule(void *state, int goalnt) {
    #####: 1835:	if (goalnt < 1 || goalnt > 28)
    #####: 1836:		fatal("_rule", "Bad goal nonterminal %d\n", goalnt);
    #####: 1837:	if (!state)
    #####: 1838:		return 0;
    #####: 1839:	switch (goalnt) {
    #####: 1840:	case _stmt_NT:	return _decode_stmt[((struct _state *)state)->rule._stmt];
    #####: 1841:	case _reg_NT:	return _decode_reg[((struct _state *)state)->rule._reg];
    #####: 1842:	case _freg_NT:	return _decode_freg[((struct _state *)state)->rule._freg];
    #####: 1843:	case _cnst_NT:	return _decode_cnst[((struct _state *)state)->rule._cnst];
    #####: 1844:	case _con_NT:	return _decode_con[((struct _state *)state)->rule._con];
    #####: 1845:	case _acon_NT:	return _decode_acon[((struct _state *)state)->rule._acon];
    #####: 1846:	case _baseaddr_NT:	return _decode_baseaddr[((struct _state *)state)->rule._baseaddr];
    #####: 1847:	case _base_NT:	return _decode_base[((struct _state *)state)->rule._base];
    #####: 1848:	case _index_NT:	return _decode_index[((struct _state *)state)->rule._index];
    #####: 1849:	case _con1_NT:	return _decode_con1[((struct _state *)state)->rule._con1];
    #####: 1850:	case _con2_NT:	return _decode_con2[((struct _state *)state)->rule._con2];
    #####: 1851:	case _con3_NT:	return _decode_con3[((struct _state *)state)->rule._con3];
    #####: 1852:	case _con0_NT:	return _decode_con0[((struct _state *)state)->rule._con0];
    #####: 1853:	case _addr_NT:	return _decode_addr[((struct _state *)state)->rule._addr];
    #####: 1854:	case _mem1_NT:	return _decode_mem1[((struct _state *)state)->rule._mem1];
    #####: 1855:	case _mem2_NT:	return _decode_mem2[((struct _state *)state)->rule._mem2];
    #####: 1856:	case _mem4_NT:	return _decode_mem4[((struct _state *)state)->rule._mem4];
    #####: 1857:	case _rc_NT:	return _decode_rc[((struct _state *)state)->rule._rc];
    #####: 1858:	case _mr_NT:	return _decode_mr[((struct _state *)state)->rule._mr];
    #####: 1859:	case _mr1_NT:	return _decode_mr1[((struct _state *)state)->rule._mr1];
    #####: 1860:	case _mr2_NT:	return _decode_mr2[((struct _state *)state)->rule._mr2];
    #####: 1861:	case _mrc_NT:	return _decode_mrc[((struct _state *)state)->rule._mrc];
    #####: 1862:	case _rc5_NT:	return _decode_rc5[((struct _state *)state)->rule._rc5];
    #####: 1863:	case _mrca_NT:	return _decode_mrca[((struct _state *)state)->rule._mrca];
    #####: 1864:	case _memf_NT:	return _decode_memf[((struct _state *)state)->rule._memf];
    #####: 1865:	case _flt_NT:	return _decode_flt[((struct _state *)state)->rule._flt];
    #####: 1866:	case _addrj_NT:	return _decode_addrj[((struct _state *)state)->rule._addrj];
    #####: 1867:	case _cmpf_NT:	return _decode_cmpf[((struct _state *)state)->rule._cmpf];
        -: 1868:	default:
    #####: 1869:		fatal("_rule", "Bad goal nonterminal %d\n", goalnt);
    #####: 1870:		return 0;
        -: 1871:	}
        -: 1872:}
        -: 1873:
        -: 1874:static void _closure_reg(NODEPTR_TYPE, int);
        -: 1875:static void _closure_freg(NODEPTR_TYPE, int);
        -: 1876:static void _closure_cnst(NODEPTR_TYPE, int);
        -: 1877:static void _closure_con(NODEPTR_TYPE, int);
        -: 1878:static void _closure_baseaddr(NODEPTR_TYPE, int);
        -: 1879:static void _closure_base(NODEPTR_TYPE, int);
        -: 1880:static void _closure_index(NODEPTR_TYPE, int);
        -: 1881:static void _closure_addr(NODEPTR_TYPE, int);
        -: 1882:static void _closure_mem1(NODEPTR_TYPE, int);
        -: 1883:static void _closure_mem2(NODEPTR_TYPE, int);
        -: 1884:static void _closure_mem4(NODEPTR_TYPE, int);
        -: 1885:static void _closure_rc(NODEPTR_TYPE, int);
        -: 1886:static void _closure_mr(NODEPTR_TYPE, int);
        -: 1887:static void _closure_mr1(NODEPTR_TYPE, int);
        -: 1888:static void _closure_mr2(NODEPTR_TYPE, int);
        -: 1889:static void _closure_memf(NODEPTR_TYPE, int);
        -: 1890:
function _closure_reg called 0 returned 0% blocks executed 0%
    #####: 1891:static void _closure_reg(NODEPTR_TYPE a, int c) {
    #####: 1892:	struct _state *p = STATE_LABEL(a);
    #####: 1893:	if (c + 2 < p->cost[_addrj_NT]) {
    #####: 1894:		p->cost[_addrj_NT] = c + 2;
    #####: 1895:		p->rule._addrj = 2;
        -: 1896:	}
    #####: 1897:	if (c + 0 < p->cost[_rc5_NT]) {
    #####: 1898:		p->cost[_rc5_NT] = c + 0;
    #####: 1899:		p->rule._rc5 = 2;
        -: 1900:	}
    #####: 1901:	if (c + 0 < p->cost[_mr2_NT]) {
    #####: 1902:		p->cost[_mr2_NT] = c + 0;
    #####: 1903:		p->rule._mr2 = 1;
    #####: 1904:		_closure_mr2(a, c + 0);
        -: 1905:	}
    #####: 1906:	if (c + 0 < p->cost[_mr1_NT]) {
    #####: 1907:		p->cost[_mr1_NT] = c + 0;
    #####: 1908:		p->rule._mr1 = 1;
    #####: 1909:		_closure_mr1(a, c + 0);
        -: 1910:	}
    #####: 1911:	if (c + 0 < p->cost[_mr_NT]) {
    #####: 1912:		p->cost[_mr_NT] = c + 0;
    #####: 1913:		p->rule._mr = 1;
    #####: 1914:		_closure_mr(a, c + 0);
        -: 1915:	}
    #####: 1916:	if (c + 0 < p->cost[_rc_NT]) {
    #####: 1917:		p->cost[_rc_NT] = c + 0;
    #####: 1918:		p->rule._rc = 1;
    #####: 1919:		_closure_rc(a, c + 0);
        -: 1920:	}
    #####: 1921:	if (c + 0 < p->cost[_index_NT]) {
    #####: 1922:		p->cost[_index_NT] = c + 0;
    #####: 1923:		p->rule._index = 1;
    #####: 1924:		_closure_index(a, c + 0);
        -: 1925:	}
    #####: 1926:	if (c + 0 < p->cost[_base_NT]) {
    #####: 1927:		p->cost[_base_NT] = c + 0;
    #####: 1928:		p->rule._base = 1;
    #####: 1929:		_closure_base(a, c + 0);
        -: 1930:	}
    #####: 1931:	if (c + 0 < p->cost[_stmt_NT]) {
    #####: 1932:		p->cost[_stmt_NT] = c + 0;
    #####: 1933:		p->rule._stmt = 13;
        -: 1934:	}
        -: 1935:}
        -: 1936:
function _closure_freg called 0 returned 0% blocks executed 0%
    #####: 1937:static void _closure_freg(NODEPTR_TYPE a, int c) {
    #####: 1938:	struct _state *p = STATE_LABEL(a);
    #####: 1939:	if (c + 0 < p->cost[_cmpf_NT]) {
    #####: 1940:		p->cost[_cmpf_NT] = c + 0;
    #####: 1941:		p->rule._cmpf = 4;
        -: 1942:	}
    #####: 1943:	if (c + 0 < p->cost[_flt_NT]) {
    #####: 1944:		p->cost[_flt_NT] = c + 0;
    #####: 1945:		p->rule._flt = 2;
        -: 1946:	}
    #####: 1947:	if (c + 0 < p->cost[_stmt_NT]) {
    #####: 1948:		p->cost[_stmt_NT] = c + 0;
    #####: 1949:		p->rule._stmt = 14;
        -: 1950:	}
        -: 1951:}
        -: 1952:
function _closure_cnst called 0 returned 0% blocks executed 0%
    #####: 1953:static void _closure_cnst(NODEPTR_TYPE a, int c) {
    #####: 1954:	struct _state *p = STATE_LABEL(a);
    #####: 1955:	if (c + 0 < p->cost[_acon_NT]) {
    #####: 1956:		p->cost[_acon_NT] = c + 0;
    #####: 1957:		p->rule._acon = 3;
        -: 1958:	}
    #####: 1959:	if (c + 0 < p->cost[_con_NT]) {
    #####: 1960:		p->cost[_con_NT] = c + 0;
    #####: 1961:		p->rule._con = 1;
    #####: 1962:		_closure_con(a, c + 0);
        -: 1963:	}
        -: 1964:}
        -: 1965:
function _closure_con called 0 returned 0% blocks executed 0%
    #####: 1966:static void _closure_con(NODEPTR_TYPE a, int c) {
    #####: 1967:	struct _state *p = STATE_LABEL(a);
    #####: 1968:	if (c + 1 < p->cost[_reg_NT]) {
    #####: 1969:		p->cost[_reg_NT] = c + 1;
    #####: 1970:		p->rule._reg = 15;
    #####: 1971:		_closure_reg(a, c + 1);
        -: 1972:	}
    #####: 1973:	if (c + 0 < p->cost[_rc_NT]) {
    #####: 1974:		p->cost[_rc_NT] = c + 0;
    #####: 1975:		p->rule._rc = 2;
    #####: 1976:		_closure_rc(a, c + 0);
        -: 1977:	}
        -: 1978:}
        -: 1979:
function _closure_baseaddr called 0 returned 0% blocks executed 0%
    #####: 1980:static void _closure_baseaddr(NODEPTR_TYPE a, int c) {
    #####: 1981:	struct _state *p = STATE_LABEL(a);
    #####: 1982:	if (c + 0 < p->cost[_addr_NT]) {
    #####: 1983:		p->cost[_addr_NT] = c + 0;
    #####: 1984:		p->rule._addr = 2;
    #####: 1985:		_closure_addr(a, c + 0);
        -: 1986:	}
        -: 1987:}
        -: 1988:
function _closure_base called 0 returned 0% blocks executed 0%
    #####: 1989:static void _closure_base(NODEPTR_TYPE a, int c) {
    #####: 1990:	struct _state *p = STATE_LABEL(a);
    #####: 1991:	if (c + 0 < p->cost[_addr_NT]) {
    #####: 1992:		p->cost[_addr_NT] = c + 0;
    #####: 1993:		p->rule._addr = 1;
    #####: 1994:		_closure_addr(a, c + 0);
        -: 1995:	}
        -: 1996:}
        -: 1997:
function _closure_index called 0 returned 0% blocks executed 0%
    #####: 1998:static void _closure_index(NODEPTR_TYPE a, int c) {
    #####: 1999:	struct _state *p = STATE_LABEL(a);
    #####: 2000:	if (c + 0 < p->cost[_addr_NT]) {
    #####: 2001:		p->cost[_addr_NT] = c + 0;
    #####: 2002:		p->rule._addr = 12;
    #####: 2003:		_closure_addr(a, c + 0);
        -: 2004:	}
        -: 2005:}
        -: 2006:
function _closure_addr called 0 returned 0% blocks executed 0%
    #####: 2007:static void _closure_addr(NODEPTR_TYPE a, int c) {
    #####: 2008:	struct _state *p = STATE_LABEL(a);
    #####: 2009:	if (c + 1 < p->cost[_reg_NT]) {
    #####: 2010:		p->cost[_reg_NT] = c + 1;
    #####: 2011:		p->rule._reg = 11;
    #####: 2012:		_closure_reg(a, c + 1);
        -: 2013:	}
        -: 2014:}
        -: 2015:
function _closure_mem1 called 0 returned 0% blocks executed 0%
    #####: 2016:static void _closure_mem1(NODEPTR_TYPE a, int c) {
    #####: 2017:	struct _state *p = STATE_LABEL(a);
    #####: 2018:	if (c + 1 < p->cost[_mrc_NT]) {
    #####: 2019:		p->cost[_mrc_NT] = c + 1;
    #####: 2020:		p->rule._mrc = 2;
        -: 2021:	}
    #####: 2022:	if (c + 0 < p->cost[_mr1_NT]) {
    #####: 2023:		p->cost[_mr1_NT] = c + 0;
    #####: 2024:		p->rule._mr1 = 2;
    #####: 2025:		_closure_mr1(a, c + 0);
        -: 2026:	}
        -: 2027:}
        -: 2028:
function _closure_mem2 called 0 returned 0% blocks executed 0%
    #####: 2029:static void _closure_mem2(NODEPTR_TYPE a, int c) {
    #####: 2030:	struct _state *p = STATE_LABEL(a);
    #####: 2031:	if (c + 1 < p->cost[_mrc_NT]) {
    #####: 2032:		p->cost[_mrc_NT] = c + 1;
    #####: 2033:		p->rule._mrc = 3;
        -: 2034:	}
    #####: 2035:	if (c + 0 < p->cost[_mr2_NT]) {
    #####: 2036:		p->cost[_mr2_NT] = c + 0;
    #####: 2037:		p->rule._mr2 = 2;
    #####: 2038:		_closure_mr2(a, c + 0);
        -: 2039:	}
        -: 2040:}
        -: 2041:
function _closure_mem4 called 0 returned 0% blocks executed 0%
    #####: 2042:static void _closure_mem4(NODEPTR_TYPE a, int c) {
    #####: 2043:	struct _state *p = STATE_LABEL(a);
    #####: 2044:	if (c + 2 < p->cost[_addrj_NT]) {
    #####: 2045:		p->cost[_addrj_NT] = c + 2;
    #####: 2046:		p->rule._addrj = 3;
        -: 2047:	}
    #####: 2048:	if (c + 0 < p->cost[_mrca_NT]) {
    #####: 2049:		p->cost[_mrca_NT] = c + 0;
    #####: 2050:		p->rule._mrca = 1;
        -: 2051:	}
    #####: 2052:	if (c + 1 < p->cost[_mrc_NT]) {
    #####: 2053:		p->cost[_mrc_NT] = c + 1;
    #####: 2054:		p->rule._mrc = 1;
        -: 2055:	}
    #####: 2056:	if (c + 0 < p->cost[_mr_NT]) {
    #####: 2057:		p->cost[_mr_NT] = c + 0;
    #####: 2058:		p->rule._mr = 2;
    #####: 2059:		_closure_mr(a, c + 0);
        -: 2060:	}
        -: 2061:}
        -: 2062:
function _closure_rc called 0 returned 0% blocks executed 0%
    #####: 2063:static void _closure_rc(NODEPTR_TYPE a, int c) {
    #####: 2064:	struct _state *p = STATE_LABEL(a);
    #####: 2065:	if (c + 0 < p->cost[_mrca_NT]) {
    #####: 2066:		p->cost[_mrca_NT] = c + 0;
    #####: 2067:		p->rule._mrca = 2;
        -: 2068:	}
    #####: 2069:	if (c + 0 < p->cost[_mrc_NT]) {
    #####: 2070:		p->cost[_mrc_NT] = c + 0;
    #####: 2071:		p->rule._mrc = 4;
        -: 2072:	}
        -: 2073:}
        -: 2074:
function _closure_mr called 0 returned 0% blocks executed 0%
    #####: 2075:static void _closure_mr(NODEPTR_TYPE a, int c) {
    #####: 2076:	struct _state *p = STATE_LABEL(a);
    #####: 2077:	if (c + 1 < p->cost[_reg_NT]) {
    #####: 2078:		p->cost[_reg_NT] = c + 1;
    #####: 2079:		p->rule._reg = 12;
    #####: 2080:		_closure_reg(a, c + 1);
        -: 2081:	}
        -: 2082:}
        -: 2083:
function _closure_mr1 called 0 returned 0% blocks executed 0%
    #####: 2084:static void _closure_mr1(NODEPTR_TYPE a, int c) {
    #####: 2085:	struct _state *p = STATE_LABEL(a);
    #####: 2086:	if (c + 1 < p->cost[_reg_NT]) {
    #####: 2087:		p->cost[_reg_NT] = c + 1;
    #####: 2088:		p->rule._reg = 13;
    #####: 2089:		_closure_reg(a, c + 1);
        -: 2090:	}
        -: 2091:}
        -: 2092:
function _closure_mr2 called 0 returned 0% blocks executed 0%
    #####: 2093:static void _closure_mr2(NODEPTR_TYPE a, int c) {
    #####: 2094:	struct _state *p = STATE_LABEL(a);
    #####: 2095:	if (c + 1 < p->cost[_reg_NT]) {
    #####: 2096:		p->cost[_reg_NT] = c + 1;
    #####: 2097:		p->rule._reg = 14;
    #####: 2098:		_closure_reg(a, c + 1);
        -: 2099:	}
        -: 2100:}
        -: 2101:
function _closure_memf called 0 returned 0% blocks executed 0%
    #####: 2102:static void _closure_memf(NODEPTR_TYPE a, int c) {
    #####: 2103:	struct _state *p = STATE_LABEL(a);
    #####: 2104:	if (c + 0 < p->cost[_flt_NT]) {
    #####: 2105:		p->cost[_flt_NT] = c + 0;
    #####: 2106:		p->rule._flt = 1;
        -: 2107:	}
    #####: 2108:	if (c + 3 < p->cost[_freg_NT]) {
    #####: 2109:		p->cost[_freg_NT] = c + 3;
    #####: 2110:		p->rule._freg = 3;
    #####: 2111:		_closure_freg(a, c + 3);
        -: 2112:	}
        -: 2113:}
        -: 2114:
function _label called 0 returned 0% blocks executed 0%
    #####: 2115:static void _label(NODEPTR_TYPE a) {
    #####: 2116:	int c;
    #####: 2117:	struct _state *p;
        -: 2118:
    #####: 2119:	if (!a)
    #####: 2120:		fatal("_label", "Null tree\n", 0);
    #####: 2121:	STATE_LABEL(a) = p = allocate(sizeof *p, FUNC);
    #####: 2122:	p->rule._stmt = 0;
    #####: 2123:	p->cost[1] =
        -: 2124:	p->cost[2] =
        -: 2125:	p->cost[3] =
        -: 2126:	p->cost[4] =
        -: 2127:	p->cost[5] =
        -: 2128:	p->cost[6] =
        -: 2129:	p->cost[7] =
        -: 2130:	p->cost[8] =
        -: 2131:	p->cost[9] =
        -: 2132:	p->cost[10] =
        -: 2133:	p->cost[11] =
        -: 2134:	p->cost[12] =
        -: 2135:	p->cost[13] =
        -: 2136:	p->cost[14] =
        -: 2137:	p->cost[15] =
        -: 2138:	p->cost[16] =
        -: 2139:	p->cost[17] =
        -: 2140:	p->cost[18] =
        -: 2141:	p->cost[19] =
        -: 2142:	p->cost[20] =
        -: 2143:	p->cost[21] =
        -: 2144:	p->cost[22] =
        -: 2145:	p->cost[23] =
        -: 2146:	p->cost[24] =
        -: 2147:	p->cost[25] =
        -: 2148:	p->cost[26] =
        -: 2149:	p->cost[27] =
        -: 2150:	p->cost[28] =
        -: 2151:		0x7fff;
    #####: 2152:	switch (OP_LABEL(a)) {
        -: 2153:	case 41: /* ARGB */
    #####: 2154:		_label(LEFT_CHILD(a));
    #####: 2155:		if (	/* stmt: ARGB(INDIRB(reg)) */
        -: 2156:			LEFT_CHILD(a)->op == 73 /* INDIRB */
        -: 2157:		) {
    #####: 2158:			c = ((struct _state *)(LEFT_CHILD(LEFT_CHILD(a))->x.state))->cost[_reg_NT] + 0;
    #####: 2159:			if (c + 0 < p->cost[_stmt_NT]) {
    #####: 2160:				p->cost[_stmt_NT] = c + 0;
    #####: 2161:				p->rule._stmt = 49;
        -: 2162:			}
        -: 2163:		}
    #####: 2164:		break;
        -: 2165:	case 57: /* ASGNB */
    #####: 2166:		_label(LEFT_CHILD(a));
    #####: 2167:		_label(RIGHT_CHILD(a));
    #####: 2168:		if (	/* stmt: ASGNB(reg,INDIRB(reg)) */
        -: 2169:			RIGHT_CHILD(a)->op == 73 /* INDIRB */
        -: 2170:		) {
    #####: 2171:			c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(LEFT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_reg_NT] + 0;
    #####: 2172:			if (c + 0 < p->cost[_stmt_NT]) {
    #####: 2173:				p->cost[_stmt_NT] = c + 0;
    #####: 2174:				p->rule._stmt = 48;
        -: 2175:			}
        -: 2176:		}
    #####: 2177:		break;
        -: 2178:	case 73: /* INDIRB */
    #####: 2179:		_label(LEFT_CHILD(a));
    #####: 2180:		break;
        -: 2181:	case 216: /* CALLV */
    #####: 2182:		_label(LEFT_CHILD(a));
        -: 2183:		/* stmt: CALLV(addrj) */
    #####: 2184:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addrj_NT] + (hasargs(a));
    #####: 2185:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 2186:			p->cost[_stmt_NT] = c + 0;
    #####: 2187:			p->rule._stmt = 99;
        -: 2188:		}
        -: 2189:		/* stmt: CALLV(addrj) */
    #####: 2190:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addrj_NT] + 1;
    #####: 2191:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 2192:			p->cost[_stmt_NT] = c + 0;
    #####: 2193:			p->rule._stmt = 100;
        -: 2194:		}
    #####: 2195:		break;
        -: 2196:	case 217: /* CALLB */
    #####: 2197:		break;
        -: 2198:	case 233: /* LOADB */
    #####: 2199:		break;
        -: 2200:	case 248: /* RETV */
    #####: 2201:		break;
        -: 2202:	case 584: /* JUMPV */
    #####: 2203:		_label(LEFT_CHILD(a));
        -: 2204:		/* stmt: JUMPV(addrj) */
    #####: 2205:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addrj_NT] + 3;
    #####: 2206:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 2207:			p->cost[_stmt_NT] = c + 0;
    #####: 2208:			p->rule._stmt = 57;
        -: 2209:		}
    #####: 2210:		break;
        -: 2211:	case 600: /* LABELV */
        -: 2212:		/* stmt: LABELV */
    #####: 2213:		if (0 + 0 < p->cost[_stmt_NT]) {
    #####: 2214:			p->cost[_stmt_NT] = 0 + 0;
    #####: 2215:			p->rule._stmt = 56;
        -: 2216:		}
    #####: 2217:		break;
        -: 2218:	case 711: /* VREGP */
    #####: 2219:		break;
        -: 2220:	case 1045: /* CNSTI1 */
        -: 2221:		/* cnst: CNSTI1 */
    #####: 2222:		if (0 + 0 < p->cost[_cnst_NT]) {
    #####: 2223:			p->cost[_cnst_NT] = 0 + 0;
    #####: 2224:			p->rule._cnst = 1;
    #####: 2225:			_closure_cnst(a, 0 + 0);
        -: 2226:		}
    #####: 2227:		break;
        -: 2228:	case 1046: /* CNSTU1 */
        -: 2229:		/* cnst: CNSTU1 */
    #####: 2230:		if (0 + 0 < p->cost[_cnst_NT]) {
    #####: 2231:			p->cost[_cnst_NT] = 0 + 0;
    #####: 2232:			p->rule._cnst = 2;
    #####: 2233:			_closure_cnst(a, 0 + 0);
        -: 2234:		}
    #####: 2235:		break;
        -: 2236:	case 1077: /* ASGNI1 */
    #####: 2237:		_label(LEFT_CHILD(a));
    #####: 2238:		_label(RIGHT_CHILD(a));
    #####: 2239:		if (	/* stmt: ASGNI1(VREGP,reg) */
        -: 2240:			LEFT_CHILD(a)->op == 711 /* VREGP */
        -: 2241:		) {
    #####: 2242:			c = ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
    #####: 2243:			if (c + 0 < p->cost[_stmt_NT]) {
    #####: 2244:				p->cost[_stmt_NT] = c + 0;
    #####: 2245:				p->rule._stmt = 1;
        -: 2246:			}
        -: 2247:		}
        -: 2248:		/* stmt: ASGNI1(addr,rc) */
    #####: 2249:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_rc_NT] + 1;
    #####: 2250:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 2251:			p->cost[_stmt_NT] = c + 0;
    #####: 2252:			p->rule._stmt = 38;
        -: 2253:		}
    #####: 2254:		break;
        -: 2255:	case 1078: /* ASGNU1 */
    #####: 2256:		_label(LEFT_CHILD(a));
    #####: 2257:		_label(RIGHT_CHILD(a));
    #####: 2258:		if (	/* stmt: ASGNU1(VREGP,reg) */
        -: 2259:			LEFT_CHILD(a)->op == 711 /* VREGP */
        -: 2260:		) {
    #####: 2261:			c = ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
    #####: 2262:			if (c + 0 < p->cost[_stmt_NT]) {
    #####: 2263:				p->cost[_stmt_NT] = c + 0;
    #####: 2264:				p->rule._stmt = 2;
        -: 2265:			}
        -: 2266:		}
        -: 2267:		/* stmt: ASGNU1(addr,rc) */
    #####: 2268:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_rc_NT] + 1;
    #####: 2269:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 2270:			p->cost[_stmt_NT] = c + 0;
    #####: 2271:			p->rule._stmt = 41;
        -: 2272:		}
    #####: 2273:		break;
        -: 2274:	case 1093: /* INDIRI1 */
    #####: 2275:		_label(LEFT_CHILD(a));
    #####: 2276:		if (	/* reg: INDIRI1(VREGP) */
        -: 2277:			LEFT_CHILD(a)->op == 711 /* VREGP */
        -: 2278:		) {
    #####: 2279:			if (mayrecalc(a)) {
    #####: 2280:				struct _state *q = a->syms[RX]->u.t.cse->x.state;
    #####: 2281:				if (q->cost[_stmt_NT] == 0) {
    #####: 2282:					p->cost[_stmt_NT] = 0;
    #####: 2283:					p->rule._stmt = q->rule._stmt;
        -: 2284:				}
    #####: 2285:				if (q->cost[_reg_NT] == 0) {
    #####: 2286:					p->cost[_reg_NT] = 0;
    #####: 2287:					p->rule._reg = q->rule._reg;
        -: 2288:				}
    #####: 2289:				if (q->cost[_freg_NT] == 0) {
    #####: 2290:					p->cost[_freg_NT] = 0;
    #####: 2291:					p->rule._freg = q->rule._freg;
        -: 2292:				}
    #####: 2293:				if (q->cost[_cnst_NT] == 0) {
    #####: 2294:					p->cost[_cnst_NT] = 0;
    #####: 2295:					p->rule._cnst = q->rule._cnst;
        -: 2296:				}
    #####: 2297:				if (q->cost[_con_NT] == 0) {
    #####: 2298:					p->cost[_con_NT] = 0;
    #####: 2299:					p->rule._con = q->rule._con;
        -: 2300:				}
    #####: 2301:				if (q->cost[_acon_NT] == 0) {
    #####: 2302:					p->cost[_acon_NT] = 0;
    #####: 2303:					p->rule._acon = q->rule._acon;
        -: 2304:				}
    #####: 2305:				if (q->cost[_baseaddr_NT] == 0) {
    #####: 2306:					p->cost[_baseaddr_NT] = 0;
    #####: 2307:					p->rule._baseaddr = q->rule._baseaddr;
        -: 2308:				}
    #####: 2309:				if (q->cost[_base_NT] == 0) {
    #####: 2310:					p->cost[_base_NT] = 0;
    #####: 2311:					p->rule._base = q->rule._base;
        -: 2312:				}
    #####: 2313:				if (q->cost[_index_NT] == 0) {
    #####: 2314:					p->cost[_index_NT] = 0;
    #####: 2315:					p->rule._index = q->rule._index;
        -: 2316:				}
    #####: 2317:				if (q->cost[_con1_NT] == 0) {
    #####: 2318:					p->cost[_con1_NT] = 0;
    #####: 2319:					p->rule._con1 = q->rule._con1;
        -: 2320:				}
    #####: 2321:				if (q->cost[_con2_NT] == 0) {
    #####: 2322:					p->cost[_con2_NT] = 0;
    #####: 2323:					p->rule._con2 = q->rule._con2;
        -: 2324:				}
    #####: 2325:				if (q->cost[_con3_NT] == 0) {
    #####: 2326:					p->cost[_con3_NT] = 0;
    #####: 2327:					p->rule._con3 = q->rule._con3;
        -: 2328:				}
    #####: 2329:				if (q->cost[_con0_NT] == 0) {
    #####: 2330:					p->cost[_con0_NT] = 0;
    #####: 2331:					p->rule._con0 = q->rule._con0;
        -: 2332:				}
    #####: 2333:				if (q->cost[_addr_NT] == 0) {
    #####: 2334:					p->cost[_addr_NT] = 0;
    #####: 2335:					p->rule._addr = q->rule._addr;
        -: 2336:				}
    #####: 2337:				if (q->cost[_mem1_NT] == 0) {
    #####: 2338:					p->cost[_mem1_NT] = 0;
    #####: 2339:					p->rule._mem1 = q->rule._mem1;
        -: 2340:				}
    #####: 2341:				if (q->cost[_mem2_NT] == 0) {
    #####: 2342:					p->cost[_mem2_NT] = 0;
    #####: 2343:					p->rule._mem2 = q->rule._mem2;
        -: 2344:				}
    #####: 2345:				if (q->cost[_mem4_NT] == 0) {
    #####: 2346:					p->cost[_mem4_NT] = 0;
    #####: 2347:					p->rule._mem4 = q->rule._mem4;
        -: 2348:				}
    #####: 2349:				if (q->cost[_rc_NT] == 0) {
    #####: 2350:					p->cost[_rc_NT] = 0;
    #####: 2351:					p->rule._rc = q->rule._rc;
        -: 2352:				}
    #####: 2353:				if (q->cost[_mr_NT] == 0) {
    #####: 2354:					p->cost[_mr_NT] = 0;
    #####: 2355:					p->rule._mr = q->rule._mr;
        -: 2356:				}
    #####: 2357:				if (q->cost[_mr1_NT] == 0) {
    #####: 2358:					p->cost[_mr1_NT] = 0;
    #####: 2359:					p->rule._mr1 = q->rule._mr1;
        -: 2360:				}
    #####: 2361:				if (q->cost[_mr2_NT] == 0) {
    #####: 2362:					p->cost[_mr2_NT] = 0;
    #####: 2363:					p->rule._mr2 = q->rule._mr2;
        -: 2364:				}
    #####: 2365:				if (q->cost[_mrc_NT] == 0) {
    #####: 2366:					p->cost[_mrc_NT] = 0;
    #####: 2367:					p->rule._mrc = q->rule._mrc;
        -: 2368:				}
    #####: 2369:				if (q->cost[_rc5_NT] == 0) {
    #####: 2370:					p->cost[_rc5_NT] = 0;
    #####: 2371:					p->rule._rc5 = q->rule._rc5;
        -: 2372:				}
    #####: 2373:				if (q->cost[_mrca_NT] == 0) {
    #####: 2374:					p->cost[_mrca_NT] = 0;
    #####: 2375:					p->rule._mrca = q->rule._mrca;
        -: 2376:				}
    #####: 2377:				if (q->cost[_memf_NT] == 0) {
    #####: 2378:					p->cost[_memf_NT] = 0;
    #####: 2379:					p->rule._memf = q->rule._memf;
        -: 2380:				}
    #####: 2381:				if (q->cost[_flt_NT] == 0) {
    #####: 2382:					p->cost[_flt_NT] = 0;
    #####: 2383:					p->rule._flt = q->rule._flt;
        -: 2384:				}
    #####: 2385:				if (q->cost[_addrj_NT] == 0) {
    #####: 2386:					p->cost[_addrj_NT] = 0;
    #####: 2387:					p->rule._addrj = q->rule._addrj;
        -: 2388:				}
    #####: 2389:				if (q->cost[_cmpf_NT] == 0) {
    #####: 2390:					p->cost[_cmpf_NT] = 0;
    #####: 2391:					p->rule._cmpf = q->rule._cmpf;
        -: 2392:				}
        -: 2393:			}
    #####: 2394:			c = 0;
    #####: 2395:			if (c + 0 < p->cost[_reg_NT]) {
    #####: 2396:				p->cost[_reg_NT] = c + 0;
    #####: 2397:				p->rule._reg = 1;
    #####: 2398:				_closure_reg(a, c + 0);
        -: 2399:			}
        -: 2400:		}
        -: 2401:		/* mem1: INDIRI1(addr) */
    #####: 2402:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + 0;
    #####: 2403:		if (c + 0 < p->cost[_mem1_NT]) {
    #####: 2404:			p->cost[_mem1_NT] = c + 0;
    #####: 2405:			p->rule._mem1 = 1;
    #####: 2406:			_closure_mem1(a, c + 0);
        -: 2407:		}
    #####: 2408:		break;
        -: 2409:	case 1094: /* INDIRU1 */
    #####: 2410:		_label(LEFT_CHILD(a));
    #####: 2411:		if (	/* reg: INDIRU1(VREGP) */
        -: 2412:			LEFT_CHILD(a)->op == 711 /* VREGP */
        -: 2413:		) {
    #####: 2414:			if (mayrecalc(a)) {
    #####: 2415:				struct _state *q = a->syms[RX]->u.t.cse->x.state;
    #####: 2416:				if (q->cost[_stmt_NT] == 0) {
    #####: 2417:					p->cost[_stmt_NT] = 0;
    #####: 2418:					p->rule._stmt = q->rule._stmt;
        -: 2419:				}
    #####: 2420:				if (q->cost[_reg_NT] == 0) {
    #####: 2421:					p->cost[_reg_NT] = 0;
    #####: 2422:					p->rule._reg = q->rule._reg;
        -: 2423:				}
    #####: 2424:				if (q->cost[_freg_NT] == 0) {
    #####: 2425:					p->cost[_freg_NT] = 0;
    #####: 2426:					p->rule._freg = q->rule._freg;
        -: 2427:				}
    #####: 2428:				if (q->cost[_cnst_NT] == 0) {
    #####: 2429:					p->cost[_cnst_NT] = 0;
    #####: 2430:					p->rule._cnst = q->rule._cnst;
        -: 2431:				}
    #####: 2432:				if (q->cost[_con_NT] == 0) {
    #####: 2433:					p->cost[_con_NT] = 0;
    #####: 2434:					p->rule._con = q->rule._con;
        -: 2435:				}
    #####: 2436:				if (q->cost[_acon_NT] == 0) {
    #####: 2437:					p->cost[_acon_NT] = 0;
    #####: 2438:					p->rule._acon = q->rule._acon;
        -: 2439:				}
    #####: 2440:				if (q->cost[_baseaddr_NT] == 0) {
    #####: 2441:					p->cost[_baseaddr_NT] = 0;
    #####: 2442:					p->rule._baseaddr = q->rule._baseaddr;
        -: 2443:				}
    #####: 2444:				if (q->cost[_base_NT] == 0) {
    #####: 2445:					p->cost[_base_NT] = 0;
    #####: 2446:					p->rule._base = q->rule._base;
        -: 2447:				}
    #####: 2448:				if (q->cost[_index_NT] == 0) {
    #####: 2449:					p->cost[_index_NT] = 0;
    #####: 2450:					p->rule._index = q->rule._index;
        -: 2451:				}
    #####: 2452:				if (q->cost[_con1_NT] == 0) {
    #####: 2453:					p->cost[_con1_NT] = 0;
    #####: 2454:					p->rule._con1 = q->rule._con1;
        -: 2455:				}
    #####: 2456:				if (q->cost[_con2_NT] == 0) {
    #####: 2457:					p->cost[_con2_NT] = 0;
    #####: 2458:					p->rule._con2 = q->rule._con2;
        -: 2459:				}
    #####: 2460:				if (q->cost[_con3_NT] == 0) {
    #####: 2461:					p->cost[_con3_NT] = 0;
    #####: 2462:					p->rule._con3 = q->rule._con3;
        -: 2463:				}
    #####: 2464:				if (q->cost[_con0_NT] == 0) {
    #####: 2465:					p->cost[_con0_NT] = 0;
    #####: 2466:					p->rule._con0 = q->rule._con0;
        -: 2467:				}
    #####: 2468:				if (q->cost[_addr_NT] == 0) {
    #####: 2469:					p->cost[_addr_NT] = 0;
    #####: 2470:					p->rule._addr = q->rule._addr;
        -: 2471:				}
    #####: 2472:				if (q->cost[_mem1_NT] == 0) {
    #####: 2473:					p->cost[_mem1_NT] = 0;
    #####: 2474:					p->rule._mem1 = q->rule._mem1;
        -: 2475:				}
    #####: 2476:				if (q->cost[_mem2_NT] == 0) {
    #####: 2477:					p->cost[_mem2_NT] = 0;
    #####: 2478:					p->rule._mem2 = q->rule._mem2;
        -: 2479:				}
    #####: 2480:				if (q->cost[_mem4_NT] == 0) {
    #####: 2481:					p->cost[_mem4_NT] = 0;
    #####: 2482:					p->rule._mem4 = q->rule._mem4;
        -: 2483:				}
    #####: 2484:				if (q->cost[_rc_NT] == 0) {
    #####: 2485:					p->cost[_rc_NT] = 0;
    #####: 2486:					p->rule._rc = q->rule._rc;
        -: 2487:				}
    #####: 2488:				if (q->cost[_mr_NT] == 0) {
    #####: 2489:					p->cost[_mr_NT] = 0;
    #####: 2490:					p->rule._mr = q->rule._mr;
        -: 2491:				}
    #####: 2492:				if (q->cost[_mr1_NT] == 0) {
    #####: 2493:					p->cost[_mr1_NT] = 0;
    #####: 2494:					p->rule._mr1 = q->rule._mr1;
        -: 2495:				}
    #####: 2496:				if (q->cost[_mr2_NT] == 0) {
    #####: 2497:					p->cost[_mr2_NT] = 0;
    #####: 2498:					p->rule._mr2 = q->rule._mr2;
        -: 2499:				}
    #####: 2500:				if (q->cost[_mrc_NT] == 0) {
    #####: 2501:					p->cost[_mrc_NT] = 0;
    #####: 2502:					p->rule._mrc = q->rule._mrc;
        -: 2503:				}
    #####: 2504:				if (q->cost[_rc5_NT] == 0) {
    #####: 2505:					p->cost[_rc5_NT] = 0;
    #####: 2506:					p->rule._rc5 = q->rule._rc5;
        -: 2507:				}
    #####: 2508:				if (q->cost[_mrca_NT] == 0) {
    #####: 2509:					p->cost[_mrca_NT] = 0;
    #####: 2510:					p->rule._mrca = q->rule._mrca;
        -: 2511:				}
    #####: 2512:				if (q->cost[_memf_NT] == 0) {
    #####: 2513:					p->cost[_memf_NT] = 0;
    #####: 2514:					p->rule._memf = q->rule._memf;
        -: 2515:				}
    #####: 2516:				if (q->cost[_flt_NT] == 0) {
    #####: 2517:					p->cost[_flt_NT] = 0;
    #####: 2518:					p->rule._flt = q->rule._flt;
        -: 2519:				}
    #####: 2520:				if (q->cost[_addrj_NT] == 0) {
    #####: 2521:					p->cost[_addrj_NT] = 0;
    #####: 2522:					p->rule._addrj = q->rule._addrj;
        -: 2523:				}
    #####: 2524:				if (q->cost[_cmpf_NT] == 0) {
    #####: 2525:					p->cost[_cmpf_NT] = 0;
    #####: 2526:					p->rule._cmpf = q->rule._cmpf;
        -: 2527:				}
        -: 2528:			}
    #####: 2529:			c = 0;
    #####: 2530:			if (c + 0 < p->cost[_reg_NT]) {
    #####: 2531:				p->cost[_reg_NT] = c + 0;
    #####: 2532:				p->rule._reg = 2;
    #####: 2533:				_closure_reg(a, c + 0);
        -: 2534:			}
        -: 2535:		}
        -: 2536:		/* mem1: INDIRU1(addr) */
    #####: 2537:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + 0;
    #####: 2538:		if (c + 0 < p->cost[_mem1_NT]) {
    #####: 2539:			p->cost[_mem1_NT] = c + 0;
    #####: 2540:			p->rule._mem1 = 2;
    #####: 2541:			_closure_mem1(a, c + 0);
        -: 2542:		}
    #####: 2543:		break;
        -: 2544:	case 1157: /* CVII1 */
    #####: 2545:		_label(LEFT_CHILD(a));
        -: 2546:		/* reg: CVII1(reg) */
    #####: 2547:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + 1;
    #####: 2548:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 2549:			p->cost[_reg_NT] = c + 0;
    #####: 2550:			p->rule._reg = 59;
    #####: 2551:			_closure_reg(a, c + 0);
        -: 2552:		}
    #####: 2553:		break;
        -: 2554:	case 1158: /* CVIU1 */
    #####: 2555:		break;
        -: 2556:	case 1205: /* CVUI1 */
    #####: 2557:		break;
        -: 2558:	case 1206: /* CVUU1 */
    #####: 2559:		_label(LEFT_CHILD(a));
        -: 2560:		/* reg: CVUU1(reg) */
    #####: 2561:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + 1;
    #####: 2562:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 2563:			p->cost[_reg_NT] = c + 0;
    #####: 2564:			p->rule._reg = 61;
    #####: 2565:			_closure_reg(a, c + 0);
        -: 2566:		}
    #####: 2567:		break;
        -: 2568:	case 1253: /* LOADI1 */
    #####: 2569:		_label(LEFT_CHILD(a));
        -: 2570:		/* reg: LOADI1(reg) */
    #####: 2571:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + 1;
    #####: 2572:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 2573:			p->cost[_reg_NT] = c + 0;
    #####: 2574:			p->rule._reg = 16;
    #####: 2575:			_closure_reg(a, c + 0);
        -: 2576:		}
    #####: 2577:		break;
        -: 2578:	case 1254: /* LOADU1 */
    #####: 2579:		_label(LEFT_CHILD(a));
        -: 2580:		/* reg: LOADU1(reg) */
    #####: 2581:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + 1;
    #####: 2582:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 2583:			p->cost[_reg_NT] = c + 0;
    #####: 2584:			p->rule._reg = 19;
    #####: 2585:			_closure_reg(a, c + 0);
        -: 2586:		}
    #####: 2587:		break;
        -: 2588:	case 2069: /* CNSTI2 */
        -: 2589:		/* cnst: CNSTI2 */
    #####: 2590:		if (0 + 0 < p->cost[_cnst_NT]) {
    #####: 2591:			p->cost[_cnst_NT] = 0 + 0;
    #####: 2592:			p->rule._cnst = 3;
    #####: 2593:			_closure_cnst(a, 0 + 0);
        -: 2594:		}
    #####: 2595:		break;
        -: 2596:	case 2070: /* CNSTU2 */
        -: 2597:		/* cnst: CNSTU2 */
    #####: 2598:		if (0 + 0 < p->cost[_cnst_NT]) {
    #####: 2599:			p->cost[_cnst_NT] = 0 + 0;
    #####: 2600:			p->rule._cnst = 4;
    #####: 2601:			_closure_cnst(a, 0 + 0);
        -: 2602:		}
    #####: 2603:		break;
        -: 2604:	case 2101: /* ASGNI2 */
    #####: 2605:		_label(LEFT_CHILD(a));
    #####: 2606:		_label(RIGHT_CHILD(a));
    #####: 2607:		if (	/* stmt: ASGNI2(VREGP,reg) */
        -: 2608:			LEFT_CHILD(a)->op == 711 /* VREGP */
        -: 2609:		) {
    #####: 2610:			c = ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
    #####: 2611:			if (c + 0 < p->cost[_stmt_NT]) {
    #####: 2612:				p->cost[_stmt_NT] = c + 0;
    #####: 2613:				p->rule._stmt = 3;
        -: 2614:			}
        -: 2615:		}
        -: 2616:		/* stmt: ASGNI2(addr,rc) */
    #####: 2617:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_rc_NT] + 1;
    #####: 2618:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 2619:			p->cost[_stmt_NT] = c + 0;
    #####: 2620:			p->rule._stmt = 39;
        -: 2621:		}
    #####: 2622:		break;
        -: 2623:	case 2102: /* ASGNU2 */
    #####: 2624:		_label(LEFT_CHILD(a));
    #####: 2625:		_label(RIGHT_CHILD(a));
    #####: 2626:		if (	/* stmt: ASGNU2(VREGP,reg) */
        -: 2627:			LEFT_CHILD(a)->op == 711 /* VREGP */
        -: 2628:		) {
    #####: 2629:			c = ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
    #####: 2630:			if (c + 0 < p->cost[_stmt_NT]) {
    #####: 2631:				p->cost[_stmt_NT] = c + 0;
    #####: 2632:				p->rule._stmt = 4;
        -: 2633:			}
        -: 2634:		}
        -: 2635:		/* stmt: ASGNU2(addr,rc) */
    #####: 2636:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_rc_NT] + 1;
    #####: 2637:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 2638:			p->cost[_stmt_NT] = c + 0;
    #####: 2639:			p->rule._stmt = 42;
        -: 2640:		}
    #####: 2641:		break;
        -: 2642:	case 2117: /* INDIRI2 */
    #####: 2643:		_label(LEFT_CHILD(a));
    #####: 2644:		if (	/* reg: INDIRI2(VREGP) */
        -: 2645:			LEFT_CHILD(a)->op == 711 /* VREGP */
        -: 2646:		) {
    #####: 2647:			if (mayrecalc(a)) {
    #####: 2648:				struct _state *q = a->syms[RX]->u.t.cse->x.state;
    #####: 2649:				if (q->cost[_stmt_NT] == 0) {
    #####: 2650:					p->cost[_stmt_NT] = 0;
    #####: 2651:					p->rule._stmt = q->rule._stmt;
        -: 2652:				}
    #####: 2653:				if (q->cost[_reg_NT] == 0) {
    #####: 2654:					p->cost[_reg_NT] = 0;
    #####: 2655:					p->rule._reg = q->rule._reg;
        -: 2656:				}
    #####: 2657:				if (q->cost[_freg_NT] == 0) {
    #####: 2658:					p->cost[_freg_NT] = 0;
    #####: 2659:					p->rule._freg = q->rule._freg;
        -: 2660:				}
    #####: 2661:				if (q->cost[_cnst_NT] == 0) {
    #####: 2662:					p->cost[_cnst_NT] = 0;
    #####: 2663:					p->rule._cnst = q->rule._cnst;
        -: 2664:				}
    #####: 2665:				if (q->cost[_con_NT] == 0) {
    #####: 2666:					p->cost[_con_NT] = 0;
    #####: 2667:					p->rule._con = q->rule._con;
        -: 2668:				}
    #####: 2669:				if (q->cost[_acon_NT] == 0) {
    #####: 2670:					p->cost[_acon_NT] = 0;
    #####: 2671:					p->rule._acon = q->rule._acon;
        -: 2672:				}
    #####: 2673:				if (q->cost[_baseaddr_NT] == 0) {
    #####: 2674:					p->cost[_baseaddr_NT] = 0;
    #####: 2675:					p->rule._baseaddr = q->rule._baseaddr;
        -: 2676:				}
    #####: 2677:				if (q->cost[_base_NT] == 0) {
    #####: 2678:					p->cost[_base_NT] = 0;
    #####: 2679:					p->rule._base = q->rule._base;
        -: 2680:				}
    #####: 2681:				if (q->cost[_index_NT] == 0) {
    #####: 2682:					p->cost[_index_NT] = 0;
    #####: 2683:					p->rule._index = q->rule._index;
        -: 2684:				}
    #####: 2685:				if (q->cost[_con1_NT] == 0) {
    #####: 2686:					p->cost[_con1_NT] = 0;
    #####: 2687:					p->rule._con1 = q->rule._con1;
        -: 2688:				}
    #####: 2689:				if (q->cost[_con2_NT] == 0) {
    #####: 2690:					p->cost[_con2_NT] = 0;
    #####: 2691:					p->rule._con2 = q->rule._con2;
        -: 2692:				}
    #####: 2693:				if (q->cost[_con3_NT] == 0) {
    #####: 2694:					p->cost[_con3_NT] = 0;
    #####: 2695:					p->rule._con3 = q->rule._con3;
        -: 2696:				}
    #####: 2697:				if (q->cost[_con0_NT] == 0) {
    #####: 2698:					p->cost[_con0_NT] = 0;
    #####: 2699:					p->rule._con0 = q->rule._con0;
        -: 2700:				}
    #####: 2701:				if (q->cost[_addr_NT] == 0) {
    #####: 2702:					p->cost[_addr_NT] = 0;
    #####: 2703:					p->rule._addr = q->rule._addr;
        -: 2704:				}
    #####: 2705:				if (q->cost[_mem1_NT] == 0) {
    #####: 2706:					p->cost[_mem1_NT] = 0;
    #####: 2707:					p->rule._mem1 = q->rule._mem1;
        -: 2708:				}
    #####: 2709:				if (q->cost[_mem2_NT] == 0) {
    #####: 2710:					p->cost[_mem2_NT] = 0;
    #####: 2711:					p->rule._mem2 = q->rule._mem2;
        -: 2712:				}
    #####: 2713:				if (q->cost[_mem4_NT] == 0) {
    #####: 2714:					p->cost[_mem4_NT] = 0;
    #####: 2715:					p->rule._mem4 = q->rule._mem4;
        -: 2716:				}
    #####: 2717:				if (q->cost[_rc_NT] == 0) {
    #####: 2718:					p->cost[_rc_NT] = 0;
    #####: 2719:					p->rule._rc = q->rule._rc;
        -: 2720:				}
    #####: 2721:				if (q->cost[_mr_NT] == 0) {
    #####: 2722:					p->cost[_mr_NT] = 0;
    #####: 2723:					p->rule._mr = q->rule._mr;
        -: 2724:				}
    #####: 2725:				if (q->cost[_mr1_NT] == 0) {
    #####: 2726:					p->cost[_mr1_NT] = 0;
    #####: 2727:					p->rule._mr1 = q->rule._mr1;
        -: 2728:				}
    #####: 2729:				if (q->cost[_mr2_NT] == 0) {
    #####: 2730:					p->cost[_mr2_NT] = 0;
    #####: 2731:					p->rule._mr2 = q->rule._mr2;
        -: 2732:				}
    #####: 2733:				if (q->cost[_mrc_NT] == 0) {
    #####: 2734:					p->cost[_mrc_NT] = 0;
    #####: 2735:					p->rule._mrc = q->rule._mrc;
        -: 2736:				}
    #####: 2737:				if (q->cost[_rc5_NT] == 0) {
    #####: 2738:					p->cost[_rc5_NT] = 0;
    #####: 2739:					p->rule._rc5 = q->rule._rc5;
        -: 2740:				}
    #####: 2741:				if (q->cost[_mrca_NT] == 0) {
    #####: 2742:					p->cost[_mrca_NT] = 0;
    #####: 2743:					p->rule._mrca = q->rule._mrca;
        -: 2744:				}
    #####: 2745:				if (q->cost[_memf_NT] == 0) {
    #####: 2746:					p->cost[_memf_NT] = 0;
    #####: 2747:					p->rule._memf = q->rule._memf;
        -: 2748:				}
    #####: 2749:				if (q->cost[_flt_NT] == 0) {
    #####: 2750:					p->cost[_flt_NT] = 0;
    #####: 2751:					p->rule._flt = q->rule._flt;
        -: 2752:				}
    #####: 2753:				if (q->cost[_addrj_NT] == 0) {
    #####: 2754:					p->cost[_addrj_NT] = 0;
    #####: 2755:					p->rule._addrj = q->rule._addrj;
        -: 2756:				}
    #####: 2757:				if (q->cost[_cmpf_NT] == 0) {
    #####: 2758:					p->cost[_cmpf_NT] = 0;
    #####: 2759:					p->rule._cmpf = q->rule._cmpf;
        -: 2760:				}
        -: 2761:			}
    #####: 2762:			c = 0;
    #####: 2763:			if (c + 0 < p->cost[_reg_NT]) {
    #####: 2764:				p->cost[_reg_NT] = c + 0;
    #####: 2765:				p->rule._reg = 3;
    #####: 2766:				_closure_reg(a, c + 0);
        -: 2767:			}
        -: 2768:		}
        -: 2769:		/* mem2: INDIRI2(addr) */
    #####: 2770:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + 0;
    #####: 2771:		if (c + 0 < p->cost[_mem2_NT]) {
    #####: 2772:			p->cost[_mem2_NT] = c + 0;
    #####: 2773:			p->rule._mem2 = 1;
    #####: 2774:			_closure_mem2(a, c + 0);
        -: 2775:		}
    #####: 2776:		break;
        -: 2777:	case 2118: /* INDIRU2 */
    #####: 2778:		_label(LEFT_CHILD(a));
    #####: 2779:		if (	/* reg: INDIRU2(VREGP) */
        -: 2780:			LEFT_CHILD(a)->op == 711 /* VREGP */
        -: 2781:		) {
    #####: 2782:			if (mayrecalc(a)) {
    #####: 2783:				struct _state *q = a->syms[RX]->u.t.cse->x.state;
    #####: 2784:				if (q->cost[_stmt_NT] == 0) {
    #####: 2785:					p->cost[_stmt_NT] = 0;
    #####: 2786:					p->rule._stmt = q->rule._stmt;
        -: 2787:				}
    #####: 2788:				if (q->cost[_reg_NT] == 0) {
    #####: 2789:					p->cost[_reg_NT] = 0;
    #####: 2790:					p->rule._reg = q->rule._reg;
        -: 2791:				}
    #####: 2792:				if (q->cost[_freg_NT] == 0) {
    #####: 2793:					p->cost[_freg_NT] = 0;
    #####: 2794:					p->rule._freg = q->rule._freg;
        -: 2795:				}
    #####: 2796:				if (q->cost[_cnst_NT] == 0) {
    #####: 2797:					p->cost[_cnst_NT] = 0;
    #####: 2798:					p->rule._cnst = q->rule._cnst;
        -: 2799:				}
    #####: 2800:				if (q->cost[_con_NT] == 0) {
    #####: 2801:					p->cost[_con_NT] = 0;
    #####: 2802:					p->rule._con = q->rule._con;
        -: 2803:				}
    #####: 2804:				if (q->cost[_acon_NT] == 0) {
    #####: 2805:					p->cost[_acon_NT] = 0;
    #####: 2806:					p->rule._acon = q->rule._acon;
        -: 2807:				}
    #####: 2808:				if (q->cost[_baseaddr_NT] == 0) {
    #####: 2809:					p->cost[_baseaddr_NT] = 0;
    #####: 2810:					p->rule._baseaddr = q->rule._baseaddr;
        -: 2811:				}
    #####: 2812:				if (q->cost[_base_NT] == 0) {
    #####: 2813:					p->cost[_base_NT] = 0;
    #####: 2814:					p->rule._base = q->rule._base;
        -: 2815:				}
    #####: 2816:				if (q->cost[_index_NT] == 0) {
    #####: 2817:					p->cost[_index_NT] = 0;
    #####: 2818:					p->rule._index = q->rule._index;
        -: 2819:				}
    #####: 2820:				if (q->cost[_con1_NT] == 0) {
    #####: 2821:					p->cost[_con1_NT] = 0;
    #####: 2822:					p->rule._con1 = q->rule._con1;
        -: 2823:				}
    #####: 2824:				if (q->cost[_con2_NT] == 0) {
    #####: 2825:					p->cost[_con2_NT] = 0;
    #####: 2826:					p->rule._con2 = q->rule._con2;
        -: 2827:				}
    #####: 2828:				if (q->cost[_con3_NT] == 0) {
    #####: 2829:					p->cost[_con3_NT] = 0;
    #####: 2830:					p->rule._con3 = q->rule._con3;
        -: 2831:				}
    #####: 2832:				if (q->cost[_con0_NT] == 0) {
    #####: 2833:					p->cost[_con0_NT] = 0;
    #####: 2834:					p->rule._con0 = q->rule._con0;
        -: 2835:				}
    #####: 2836:				if (q->cost[_addr_NT] == 0) {
    #####: 2837:					p->cost[_addr_NT] = 0;
    #####: 2838:					p->rule._addr = q->rule._addr;
        -: 2839:				}
    #####: 2840:				if (q->cost[_mem1_NT] == 0) {
    #####: 2841:					p->cost[_mem1_NT] = 0;
    #####: 2842:					p->rule._mem1 = q->rule._mem1;
        -: 2843:				}
    #####: 2844:				if (q->cost[_mem2_NT] == 0) {
    #####: 2845:					p->cost[_mem2_NT] = 0;
    #####: 2846:					p->rule._mem2 = q->rule._mem2;
        -: 2847:				}
    #####: 2848:				if (q->cost[_mem4_NT] == 0) {
    #####: 2849:					p->cost[_mem4_NT] = 0;
    #####: 2850:					p->rule._mem4 = q->rule._mem4;
        -: 2851:				}
    #####: 2852:				if (q->cost[_rc_NT] == 0) {
    #####: 2853:					p->cost[_rc_NT] = 0;
    #####: 2854:					p->rule._rc = q->rule._rc;
        -: 2855:				}
    #####: 2856:				if (q->cost[_mr_NT] == 0) {
    #####: 2857:					p->cost[_mr_NT] = 0;
    #####: 2858:					p->rule._mr = q->rule._mr;
        -: 2859:				}
    #####: 2860:				if (q->cost[_mr1_NT] == 0) {
    #####: 2861:					p->cost[_mr1_NT] = 0;
    #####: 2862:					p->rule._mr1 = q->rule._mr1;
        -: 2863:				}
    #####: 2864:				if (q->cost[_mr2_NT] == 0) {
    #####: 2865:					p->cost[_mr2_NT] = 0;
    #####: 2866:					p->rule._mr2 = q->rule._mr2;
        -: 2867:				}
    #####: 2868:				if (q->cost[_mrc_NT] == 0) {
    #####: 2869:					p->cost[_mrc_NT] = 0;
    #####: 2870:					p->rule._mrc = q->rule._mrc;
        -: 2871:				}
    #####: 2872:				if (q->cost[_rc5_NT] == 0) {
    #####: 2873:					p->cost[_rc5_NT] = 0;
    #####: 2874:					p->rule._rc5 = q->rule._rc5;
        -: 2875:				}
    #####: 2876:				if (q->cost[_mrca_NT] == 0) {
    #####: 2877:					p->cost[_mrca_NT] = 0;
    #####: 2878:					p->rule._mrca = q->rule._mrca;
        -: 2879:				}
    #####: 2880:				if (q->cost[_memf_NT] == 0) {
    #####: 2881:					p->cost[_memf_NT] = 0;
    #####: 2882:					p->rule._memf = q->rule._memf;
        -: 2883:				}
    #####: 2884:				if (q->cost[_flt_NT] == 0) {
    #####: 2885:					p->cost[_flt_NT] = 0;
    #####: 2886:					p->rule._flt = q->rule._flt;
        -: 2887:				}
    #####: 2888:				if (q->cost[_addrj_NT] == 0) {
    #####: 2889:					p->cost[_addrj_NT] = 0;
    #####: 2890:					p->rule._addrj = q->rule._addrj;
        -: 2891:				}
    #####: 2892:				if (q->cost[_cmpf_NT] == 0) {
    #####: 2893:					p->cost[_cmpf_NT] = 0;
    #####: 2894:					p->rule._cmpf = q->rule._cmpf;
        -: 2895:				}
        -: 2896:			}
    #####: 2897:			c = 0;
    #####: 2898:			if (c + 0 < p->cost[_reg_NT]) {
    #####: 2899:				p->cost[_reg_NT] = c + 0;
    #####: 2900:				p->rule._reg = 4;
    #####: 2901:				_closure_reg(a, c + 0);
        -: 2902:			}
        -: 2903:		}
        -: 2904:		/* mem2: INDIRU2(addr) */
    #####: 2905:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + 0;
    #####: 2906:		if (c + 0 < p->cost[_mem2_NT]) {
    #####: 2907:			p->cost[_mem2_NT] = c + 0;
    #####: 2908:			p->rule._mem2 = 2;
    #####: 2909:			_closure_mem2(a, c + 0);
        -: 2910:		}
    #####: 2911:		break;
        -: 2912:	case 2181: /* CVII2 */
    #####: 2913:		_label(LEFT_CHILD(a));
        -: 2914:		/* reg: CVII2(reg) */
    #####: 2915:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + 1;
    #####: 2916:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 2917:			p->cost[_reg_NT] = c + 0;
    #####: 2918:			p->rule._reg = 60;
    #####: 2919:			_closure_reg(a, c + 0);
        -: 2920:		}
    #####: 2921:		break;
        -: 2922:	case 2182: /* CVIU2 */
    #####: 2923:		_label(LEFT_CHILD(a));
    #####: 2924:		break;
        -: 2925:	case 2229: /* CVUI2 */
    #####: 2926:		break;
        -: 2927:	case 2230: /* CVUU2 */
    #####: 2928:		_label(LEFT_CHILD(a));
        -: 2929:		/* reg: CVUU2(reg) */
    #####: 2930:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + 1;
    #####: 2931:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 2932:			p->cost[_reg_NT] = c + 0;
    #####: 2933:			p->rule._reg = 62;
    #####: 2934:			_closure_reg(a, c + 0);
        -: 2935:		}
    #####: 2936:		break;
        -: 2937:	case 2277: /* LOADI2 */
    #####: 2938:		_label(LEFT_CHILD(a));
        -: 2939:		/* reg: LOADI2(reg) */
    #####: 2940:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + 1;
    #####: 2941:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 2942:			p->cost[_reg_NT] = c + 0;
    #####: 2943:			p->rule._reg = 17;
    #####: 2944:			_closure_reg(a, c + 0);
        -: 2945:		}
    #####: 2946:		break;
        -: 2947:	case 2278: /* LOADU2 */
    #####: 2948:		_label(LEFT_CHILD(a));
        -: 2949:		/* reg: LOADU2(reg) */
    #####: 2950:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + 1;
    #####: 2951:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 2952:			p->cost[_reg_NT] = c + 0;
    #####: 2953:			p->rule._reg = 20;
    #####: 2954:			_closure_reg(a, c + 0);
        -: 2955:		}
    #####: 2956:		break;
        -: 2957:	case 4113: /* CNSTF4 */
    #####: 2958:		break;
        -: 2959:	case 4117: /* CNSTI4 */
        -: 2960:		/* cnst: CNSTI4 */
    #####: 2961:		if (0 + 0 < p->cost[_cnst_NT]) {
    #####: 2962:			p->cost[_cnst_NT] = 0 + 0;
    #####: 2963:			p->rule._cnst = 5;
    #####: 2964:			_closure_cnst(a, 0 + 0);
        -: 2965:		}
        -: 2966:		/* con0: CNSTI4 */
    #####: 2967:		c = (range(a, 0, 0));
    #####: 2968:		if (c + 0 < p->cost[_con0_NT]) {
    #####: 2969:			p->cost[_con0_NT] = c + 0;
    #####: 2970:			p->rule._con0 = 1;
        -: 2971:		}
        -: 2972:		/* con1: CNSTI4 */
    #####: 2973:		c = (range(a, 1, 1));
    #####: 2974:		if (c + 0 < p->cost[_con1_NT]) {
    #####: 2975:			p->cost[_con1_NT] = c + 0;
    #####: 2976:			p->rule._con1 = 1;
        -: 2977:		}
        -: 2978:		/* con2: CNSTI4 */
    #####: 2979:		c = (range(a, 2, 2));
    #####: 2980:		if (c + 0 < p->cost[_con2_NT]) {
    #####: 2981:			p->cost[_con2_NT] = c + 0;
    #####: 2982:			p->rule._con2 = 1;
        -: 2983:		}
        -: 2984:		/* con3: CNSTI4 */
    #####: 2985:		c = (range(a, 3, 3));
    #####: 2986:		if (c + 0 < p->cost[_con3_NT]) {
    #####: 2987:			p->cost[_con3_NT] = c + 0;
    #####: 2988:			p->rule._con3 = 1;
        -: 2989:		}
        -: 2990:		/* rc5: CNSTI4 */
    #####: 2991:		c = (range(a, 0, 31));
    #####: 2992:		if (c + 0 < p->cost[_rc5_NT]) {
    #####: 2993:			p->cost[_rc5_NT] = c + 0;
    #####: 2994:			p->rule._rc5 = 1;
        -: 2995:		}
    #####: 2996:		break;
        -: 2997:	case 4118: /* CNSTU4 */
        -: 2998:		/* cnst: CNSTU4 */
    #####: 2999:		if (0 + 0 < p->cost[_cnst_NT]) {
    #####: 3000:			p->cost[_cnst_NT] = 0 + 0;
    #####: 3001:			p->rule._cnst = 6;
    #####: 3002:			_closure_cnst(a, 0 + 0);
        -: 3003:		}
        -: 3004:		/* con0: CNSTU4 */
    #####: 3005:		c = (range(a, 0, 0));
    #####: 3006:		if (c + 0 < p->cost[_con0_NT]) {
    #####: 3007:			p->cost[_con0_NT] = c + 0;
    #####: 3008:			p->rule._con0 = 2;
        -: 3009:		}
        -: 3010:		/* con1: CNSTU4 */
    #####: 3011:		c = (range(a, 1, 1));
    #####: 3012:		if (c + 0 < p->cost[_con1_NT]) {
    #####: 3013:			p->cost[_con1_NT] = c + 0;
    #####: 3014:			p->rule._con1 = 2;
        -: 3015:		}
        -: 3016:		/* con2: CNSTU4 */
    #####: 3017:		c = (range(a, 2, 2));
    #####: 3018:		if (c + 0 < p->cost[_con2_NT]) {
    #####: 3019:			p->cost[_con2_NT] = c + 0;
    #####: 3020:			p->rule._con2 = 2;
        -: 3021:		}
        -: 3022:		/* con3: CNSTU4 */
    #####: 3023:		c = (range(a, 3, 3));
    #####: 3024:		if (c + 0 < p->cost[_con3_NT]) {
    #####: 3025:			p->cost[_con3_NT] = c + 0;
    #####: 3026:			p->rule._con3 = 2;
        -: 3027:		}
    #####: 3028:		break;
        -: 3029:	case 4119: /* CNSTP4 */
        -: 3030:		/* cnst: CNSTP4 */
    #####: 3031:		if (0 + 0 < p->cost[_cnst_NT]) {
    #####: 3032:			p->cost[_cnst_NT] = 0 + 0;
    #####: 3033:			p->rule._cnst = 7;
    #####: 3034:			_closure_cnst(a, 0 + 0);
        -: 3035:		}
    #####: 3036:		break;
        -: 3037:	case 4129: /* ARGF4 */
    #####: 3038:		_label(LEFT_CHILD(a));
        -: 3039:		/* stmt: ARGF4(freg) */
    #####: 3040:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_freg_NT] + 0;
    #####: 3041:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 3042:			p->cost[_stmt_NT] = c + 0;
    #####: 3043:			p->rule._stmt = 54;
        -: 3044:		}
    #####: 3045:		break;
        -: 3046:	case 4133: /* ARGI4 */
    #####: 3047:		_label(LEFT_CHILD(a));
        -: 3048:		/* stmt: ARGI4(mrca) */
    #####: 3049:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_mrca_NT] + 1;
    #####: 3050:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 3051:			p->cost[_stmt_NT] = c + 0;
    #####: 3052:			p->rule._stmt = 45;
        -: 3053:		}
    #####: 3054:		break;
        -: 3055:	case 4134: /* ARGU4 */
    #####: 3056:		_label(LEFT_CHILD(a));
        -: 3057:		/* stmt: ARGU4(mrca) */
    #####: 3058:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_mrca_NT] + 1;
    #####: 3059:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 3060:			p->cost[_stmt_NT] = c + 0;
    #####: 3061:			p->rule._stmt = 46;
        -: 3062:		}
    #####: 3063:		break;
        -: 3064:	case 4135: /* ARGP4 */
    #####: 3065:		_label(LEFT_CHILD(a));
        -: 3066:		/* stmt: ARGP4(mrca) */
    #####: 3067:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_mrca_NT] + 1;
    #####: 3068:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 3069:			p->cost[_stmt_NT] = c + 0;
    #####: 3070:			p->rule._stmt = 47;
        -: 3071:		}
    #####: 3072:		break;
        -: 3073:	case 4145: /* ASGNF4 */
    #####: 3074:		_label(LEFT_CHILD(a));
    #####: 3075:		_label(RIGHT_CHILD(a));
    #####: 3076:		if (	/* stmt: ASGNF4(VREGP,reg) */
        -: 3077:			LEFT_CHILD(a)->op == 711 /* VREGP */
        -: 3078:		) {
    #####: 3079:			c = ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
    #####: 3080:			if (c + 0 < p->cost[_stmt_NT]) {
    #####: 3081:				p->cost[_stmt_NT] = c + 0;
    #####: 3082:				p->rule._stmt = 5;
        -: 3083:			}
        -: 3084:		}
        -: 3085:		/* stmt: ASGNF4(addr,freg) */
    #####: 3086:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_freg_NT] + 7;
    #####: 3087:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 3088:			p->cost[_stmt_NT] = c + 0;
    #####: 3089:			p->rule._stmt = 51;
        -: 3090:		}
    #####: 3091:		if (	/* stmt: ASGNF4(addr,CVFF4(freg)) */
        -: 3092:			RIGHT_CHILD(a)->op == 4209 /* CVFF4 */
        -: 3093:		) {
    #####: 3094:			c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(LEFT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_freg_NT] + 7;
    #####: 3095:			if (c + 0 < p->cost[_stmt_NT]) {
    #####: 3096:				p->cost[_stmt_NT] = c + 0;
    #####: 3097:				p->rule._stmt = 52;
        -: 3098:			}
        -: 3099:		}
    #####: 3100:		break;
        -: 3101:	case 4149: /* ASGNI4 */
    #####: 3102:		_label(LEFT_CHILD(a));
    #####: 3103:		_label(RIGHT_CHILD(a));
    #####: 3104:		if (	/* stmt: ASGNI4(VREGP,reg) */
        -: 3105:			LEFT_CHILD(a)->op == 711 /* VREGP */
        -: 3106:		) {
    #####: 3107:			c = ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
    #####: 3108:			if (c + 0 < p->cost[_stmt_NT]) {
    #####: 3109:				p->cost[_stmt_NT] = c + 0;
    #####: 3110:				p->rule._stmt = 6;
        -: 3111:			}
        -: 3112:		}
    #####: 3113:		if (	/* stmt: ASGNI4(addr,ADDI4(mem4,con1)) */
        -: 3114:			RIGHT_CHILD(a)->op == 4405 /* ADDI4 */
        -: 3115:		) {
    #####: 3116:			c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(LEFT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_mem4_NT] + ((struct _state *)(RIGHT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_con1_NT] + (memop(a));
    #####: 3117:			if (c + 0 < p->cost[_stmt_NT]) {
    #####: 3118:				p->cost[_stmt_NT] = c + 0;
    #####: 3119:				p->rule._stmt = 15;
        -: 3120:			}
        -: 3121:		}
    #####: 3122:		if (	/* stmt: ASGNI4(addr,ADDU4(mem4,con1)) */
        -: 3123:			RIGHT_CHILD(a)->op == 4406 /* ADDU4 */
        -: 3124:		) {
    #####: 3125:			c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(LEFT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_mem4_NT] + ((struct _state *)(RIGHT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_con1_NT] + (memop(a));
    #####: 3126:			if (c + 0 < p->cost[_stmt_NT]) {
    #####: 3127:				p->cost[_stmt_NT] = c + 0;
    #####: 3128:				p->rule._stmt = 16;
        -: 3129:			}
        -: 3130:		}
    #####: 3131:		if (	/* stmt: ASGNI4(addr,SUBI4(mem4,con1)) */
        -: 3132:			RIGHT_CHILD(a)->op == 4421 /* SUBI4 */
        -: 3133:		) {
    #####: 3134:			c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(LEFT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_mem4_NT] + ((struct _state *)(RIGHT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_con1_NT] + (memop(a));
    #####: 3135:			if (c + 0 < p->cost[_stmt_NT]) {
    #####: 3136:				p->cost[_stmt_NT] = c + 0;
    #####: 3137:				p->rule._stmt = 18;
        -: 3138:			}
        -: 3139:		}
    #####: 3140:		if (	/* stmt: ASGNI4(addr,SUBU4(mem4,con1)) */
        -: 3141:			RIGHT_CHILD(a)->op == 4422 /* SUBU4 */
        -: 3142:		) {
    #####: 3143:			c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(LEFT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_mem4_NT] + ((struct _state *)(RIGHT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_con1_NT] + (memop(a));
    #####: 3144:			if (c + 0 < p->cost[_stmt_NT]) {
    #####: 3145:				p->cost[_stmt_NT] = c + 0;
    #####: 3146:				p->rule._stmt = 19;
        -: 3147:			}
        -: 3148:		}
    #####: 3149:		if (	/* stmt: ASGNI4(addr,ADDI4(mem4,rc)) */
        -: 3150:			RIGHT_CHILD(a)->op == 4405 /* ADDI4 */
        -: 3151:		) {
    #####: 3152:			c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(LEFT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_mem4_NT] + ((struct _state *)(RIGHT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_rc_NT] + (memop(a));
    #####: 3153:			if (c + 0 < p->cost[_stmt_NT]) {
    #####: 3154:				p->cost[_stmt_NT] = c + 0;
    #####: 3155:				p->rule._stmt = 21;
        -: 3156:			}
        -: 3157:		}
    #####: 3158:		if (	/* stmt: ASGNI4(addr,SUBI4(mem4,rc)) */
        -: 3159:			RIGHT_CHILD(a)->op == 4421 /* SUBI4 */
        -: 3160:		) {
    #####: 3161:			c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(LEFT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_mem4_NT] + ((struct _state *)(RIGHT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_rc_NT] + (memop(a));
    #####: 3162:			if (c + 0 < p->cost[_stmt_NT]) {
    #####: 3163:				p->cost[_stmt_NT] = c + 0;
    #####: 3164:				p->rule._stmt = 22;
        -: 3165:			}
        -: 3166:		}
    #####: 3167:		if (	/* stmt: ASGNI4(addr,BANDI4(mem4,rc)) */
        -: 3168:			RIGHT_CHILD(a)->op == 4485 /* BANDI4 */
        -: 3169:		) {
    #####: 3170:			c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(LEFT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_mem4_NT] + ((struct _state *)(RIGHT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_rc_NT] + (memop(a));
    #####: 3171:			if (c + 0 < p->cost[_stmt_NT]) {
    #####: 3172:				p->cost[_stmt_NT] = c + 0;
    #####: 3173:				p->rule._stmt = 25;
        -: 3174:			}
        -: 3175:		}
    #####: 3176:		if (	/* stmt: ASGNI4(addr,BORI4(mem4,rc)) */
        -: 3177:			RIGHT_CHILD(a)->op == 4517 /* BORI4 */
        -: 3178:		) {
    #####: 3179:			c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(LEFT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_mem4_NT] + ((struct _state *)(RIGHT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_rc_NT] + (memop(a));
    #####: 3180:			if (c + 0 < p->cost[_stmt_NT]) {
    #####: 3181:				p->cost[_stmt_NT] = c + 0;
    #####: 3182:				p->rule._stmt = 26;
        -: 3183:			}
        -: 3184:		}
    #####: 3185:		if (	/* stmt: ASGNI4(addr,BXORI4(mem4,rc)) */
        -: 3186:			RIGHT_CHILD(a)->op == 4533 /* BXORI4 */
        -: 3187:		) {
    #####: 3188:			c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(LEFT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_mem4_NT] + ((struct _state *)(RIGHT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_rc_NT] + (memop(a));
    #####: 3189:			if (c + 0 < p->cost[_stmt_NT]) {
    #####: 3190:				p->cost[_stmt_NT] = c + 0;
    #####: 3191:				p->rule._stmt = 27;
        -: 3192:			}
        -: 3193:		}
    #####: 3194:		if (	/* stmt: ASGNI4(addr,BCOMI4(mem4)) */
        -: 3195:			RIGHT_CHILD(a)->op == 4501 /* BCOMI4 */
        -: 3196:		) {
    #####: 3197:			c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(LEFT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_mem4_NT] + (memop(a));
    #####: 3198:			if (c + 0 < p->cost[_stmt_NT]) {
    #####: 3199:				p->cost[_stmt_NT] = c + 0;
    #####: 3200:				p->rule._stmt = 31;
        -: 3201:			}
        -: 3202:		}
    #####: 3203:		if (	/* stmt: ASGNI4(addr,NEGI4(mem4)) */
        -: 3204:			RIGHT_CHILD(a)->op == 4293 /* NEGI4 */
        -: 3205:		) {
    #####: 3206:			c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(LEFT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_mem4_NT] + (memop(a));
    #####: 3207:			if (c + 0 < p->cost[_stmt_NT]) {
    #####: 3208:				p->cost[_stmt_NT] = c + 0;
    #####: 3209:				p->rule._stmt = 33;
        -: 3210:			}
        -: 3211:		}
    #####: 3212:		if (	/* stmt: ASGNI4(addr,LSHI4(mem4,rc5)) */
        -: 3213:			RIGHT_CHILD(a)->op == 4437 /* LSHI4 */
        -: 3214:		) {
    #####: 3215:			c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(LEFT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_mem4_NT] + ((struct _state *)(RIGHT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_rc5_NT] + (memop(a));
    #####: 3216:			if (c + 0 < p->cost[_stmt_NT]) {
    #####: 3217:				p->cost[_stmt_NT] = c + 0;
    #####: 3218:				p->rule._stmt = 34;
        -: 3219:			}
        -: 3220:		}
    #####: 3221:		if (	/* stmt: ASGNI4(addr,LSHU4(mem4,rc5)) */
        -: 3222:			RIGHT_CHILD(a)->op == 4438 /* LSHU4 */
        -: 3223:		) {
    #####: 3224:			c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(LEFT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_mem4_NT] + ((struct _state *)(RIGHT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_rc5_NT] + (memop(a));
    #####: 3225:			if (c + 0 < p->cost[_stmt_NT]) {
    #####: 3226:				p->cost[_stmt_NT] = c + 0;
    #####: 3227:				p->rule._stmt = 35;
        -: 3228:			}
        -: 3229:		}
    #####: 3230:		if (	/* stmt: ASGNI4(addr,RSHI4(mem4,rc5)) */
        -: 3231:			RIGHT_CHILD(a)->op == 4469 /* RSHI4 */
        -: 3232:		) {
    #####: 3233:			c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(LEFT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_mem4_NT] + ((struct _state *)(RIGHT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_rc5_NT] + (memop(a));
    #####: 3234:			if (c + 0 < p->cost[_stmt_NT]) {
    #####: 3235:				p->cost[_stmt_NT] = c + 0;
    #####: 3236:				p->rule._stmt = 36;
        -: 3237:			}
        -: 3238:		}
    #####: 3239:		if (	/* stmt: ASGNI4(addr,RSHU4(mem4,rc5)) */
        -: 3240:			RIGHT_CHILD(a)->op == 4470 /* RSHU4 */
        -: 3241:		) {
    #####: 3242:			c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(LEFT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_mem4_NT] + ((struct _state *)(RIGHT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_rc5_NT] + (memop(a));
    #####: 3243:			if (c + 0 < p->cost[_stmt_NT]) {
    #####: 3244:				p->cost[_stmt_NT] = c + 0;
    #####: 3245:				p->rule._stmt = 37;
        -: 3246:			}
        -: 3247:		}
        -: 3248:		/* stmt: ASGNI4(addr,rc) */
    #####: 3249:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_rc_NT] + 1;
    #####: 3250:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 3251:			p->cost[_stmt_NT] = c + 0;
    #####: 3252:			p->rule._stmt = 40;
        -: 3253:		}
    #####: 3254:		if (	/* stmt: ASGNI4(addr,CVFI4(freg)) */
        -: 3255:			RIGHT_CHILD(a)->op == 4213 /* CVFI4 */
        -: 3256:		) {
    #####: 3257:			c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(LEFT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_freg_NT] + 29;
    #####: 3258:			if (c + 0 < p->cost[_stmt_NT]) {
    #####: 3259:				p->cost[_stmt_NT] = c + 0;
    #####: 3260:				p->rule._stmt = 55;
        -: 3261:			}
        -: 3262:		}
    #####: 3263:		break;
        -: 3264:	case 4150: /* ASGNU4 */
    #####: 3265:		_label(LEFT_CHILD(a));
    #####: 3266:		_label(RIGHT_CHILD(a));
    #####: 3267:		if (	/* stmt: ASGNU4(VREGP,reg) */
        -: 3268:			LEFT_CHILD(a)->op == 711 /* VREGP */
        -: 3269:		) {
    #####: 3270:			c = ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
    #####: 3271:			if (c + 0 < p->cost[_stmt_NT]) {
    #####: 3272:				p->cost[_stmt_NT] = c + 0;
    #####: 3273:				p->rule._stmt = 8;
        -: 3274:			}
        -: 3275:		}
    #####: 3276:		if (	/* stmt: ASGNU4(addr,ADDU4(mem4,rc)) */
        -: 3277:			RIGHT_CHILD(a)->op == 4406 /* ADDU4 */
        -: 3278:		) {
    #####: 3279:			c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(LEFT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_mem4_NT] + ((struct _state *)(RIGHT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_rc_NT] + (memop(a));
    #####: 3280:			if (c + 0 < p->cost[_stmt_NT]) {
    #####: 3281:				p->cost[_stmt_NT] = c + 0;
    #####: 3282:				p->rule._stmt = 23;
        -: 3283:			}
        -: 3284:		}
    #####: 3285:		if (	/* stmt: ASGNU4(addr,SUBU4(mem4,rc)) */
        -: 3286:			RIGHT_CHILD(a)->op == 4422 /* SUBU4 */
        -: 3287:		) {
    #####: 3288:			c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(LEFT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_mem4_NT] + ((struct _state *)(RIGHT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_rc_NT] + (memop(a));
    #####: 3289:			if (c + 0 < p->cost[_stmt_NT]) {
    #####: 3290:				p->cost[_stmt_NT] = c + 0;
    #####: 3291:				p->rule._stmt = 24;
        -: 3292:			}
        -: 3293:		}
    #####: 3294:		if (	/* stmt: ASGNU4(addr,BANDU4(mem4,rc)) */
        -: 3295:			RIGHT_CHILD(a)->op == 4486 /* BANDU4 */
        -: 3296:		) {
    #####: 3297:			c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(LEFT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_mem4_NT] + ((struct _state *)(RIGHT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_rc_NT] + (memop(a));
    #####: 3298:			if (c + 0 < p->cost[_stmt_NT]) {
    #####: 3299:				p->cost[_stmt_NT] = c + 0;
    #####: 3300:				p->rule._stmt = 28;
        -: 3301:			}
        -: 3302:		}
    #####: 3303:		if (	/* stmt: ASGNU4(addr,BORU4(mem4,rc)) */
        -: 3304:			RIGHT_CHILD(a)->op == 4518 /* BORU4 */
        -: 3305:		) {
    #####: 3306:			c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(LEFT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_mem4_NT] + ((struct _state *)(RIGHT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_rc_NT] + (memop(a));
    #####: 3307:			if (c + 0 < p->cost[_stmt_NT]) {
    #####: 3308:				p->cost[_stmt_NT] = c + 0;
    #####: 3309:				p->rule._stmt = 29;
        -: 3310:			}
        -: 3311:		}
    #####: 3312:		if (	/* stmt: ASGNU4(addr,BXORU4(mem4,rc)) */
        -: 3313:			RIGHT_CHILD(a)->op == 4534 /* BXORU4 */
        -: 3314:		) {
    #####: 3315:			c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(LEFT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_mem4_NT] + ((struct _state *)(RIGHT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_rc_NT] + (memop(a));
    #####: 3316:			if (c + 0 < p->cost[_stmt_NT]) {
    #####: 3317:				p->cost[_stmt_NT] = c + 0;
    #####: 3318:				p->rule._stmt = 30;
        -: 3319:			}
        -: 3320:		}
    #####: 3321:		if (	/* stmt: ASGNU4(addr,BCOMU4(mem4)) */
        -: 3322:			RIGHT_CHILD(a)->op == 4502 /* BCOMU4 */
        -: 3323:		) {
    #####: 3324:			c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(LEFT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_mem4_NT] + (memop(a));
    #####: 3325:			if (c + 0 < p->cost[_stmt_NT]) {
    #####: 3326:				p->cost[_stmt_NT] = c + 0;
    #####: 3327:				p->rule._stmt = 32;
        -: 3328:			}
        -: 3329:		}
        -: 3330:		/* stmt: ASGNU4(addr,rc) */
    #####: 3331:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_rc_NT] + 1;
    #####: 3332:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 3333:			p->cost[_stmt_NT] = c + 0;
    #####: 3334:			p->rule._stmt = 43;
        -: 3335:		}
    #####: 3336:		break;
        -: 3337:	case 4151: /* ASGNP4 */
    #####: 3338:		_label(LEFT_CHILD(a));
    #####: 3339:		_label(RIGHT_CHILD(a));
    #####: 3340:		if (	/* stmt: ASGNP4(VREGP,reg) */
        -: 3341:			LEFT_CHILD(a)->op == 711 /* VREGP */
        -: 3342:		) {
    #####: 3343:			c = ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
    #####: 3344:			if (c + 0 < p->cost[_stmt_NT]) {
    #####: 3345:				p->cost[_stmt_NT] = c + 0;
    #####: 3346:				p->rule._stmt = 7;
        -: 3347:			}
        -: 3348:		}
    #####: 3349:		if (	/* stmt: ASGNP4(addr,ADDP4(mem4,con1)) */
        -: 3350:			RIGHT_CHILD(a)->op == 4407 /* ADDP4 */
        -: 3351:		) {
    #####: 3352:			c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(LEFT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_mem4_NT] + ((struct _state *)(RIGHT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_con1_NT] + (memop(a));
    #####: 3353:			if (c + 0 < p->cost[_stmt_NT]) {
    #####: 3354:				p->cost[_stmt_NT] = c + 0;
    #####: 3355:				p->rule._stmt = 17;
        -: 3356:			}
        -: 3357:		}
    #####: 3358:		if (	/* stmt: ASGNP4(addr,SUBP4(mem4,con1)) */
        -: 3359:			RIGHT_CHILD(a)->op == 4423 /* SUBP4 */
        -: 3360:		) {
    #####: 3361:			c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(LEFT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_mem4_NT] + ((struct _state *)(RIGHT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_con1_NT] + (memop(a));
    #####: 3362:			if (c + 0 < p->cost[_stmt_NT]) {
    #####: 3363:				p->cost[_stmt_NT] = c + 0;
    #####: 3364:				p->rule._stmt = 20;
        -: 3365:			}
        -: 3366:		}
        -: 3367:		/* stmt: ASGNP4(addr,rc) */
    #####: 3368:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_rc_NT] + 1;
    #####: 3369:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 3370:			p->cost[_stmt_NT] = c + 0;
    #####: 3371:			p->rule._stmt = 44;
        -: 3372:		}
    #####: 3373:		break;
        -: 3374:	case 4161: /* INDIRF4 */
    #####: 3375:		_label(LEFT_CHILD(a));
    #####: 3376:		if (	/* freg: INDIRF4(VREGP) */
        -: 3377:			LEFT_CHILD(a)->op == 711 /* VREGP */
        -: 3378:		) {
    #####: 3379:			if (mayrecalc(a)) {
    #####: 3380:				struct _state *q = a->syms[RX]->u.t.cse->x.state;
    #####: 3381:				if (q->cost[_stmt_NT] == 0) {
    #####: 3382:					p->cost[_stmt_NT] = 0;
    #####: 3383:					p->rule._stmt = q->rule._stmt;
        -: 3384:				}
    #####: 3385:				if (q->cost[_reg_NT] == 0) {
    #####: 3386:					p->cost[_reg_NT] = 0;
    #####: 3387:					p->rule._reg = q->rule._reg;
        -: 3388:				}
    #####: 3389:				if (q->cost[_freg_NT] == 0) {
    #####: 3390:					p->cost[_freg_NT] = 0;
    #####: 3391:					p->rule._freg = q->rule._freg;
        -: 3392:				}
    #####: 3393:				if (q->cost[_cnst_NT] == 0) {
    #####: 3394:					p->cost[_cnst_NT] = 0;
    #####: 3395:					p->rule._cnst = q->rule._cnst;
        -: 3396:				}
    #####: 3397:				if (q->cost[_con_NT] == 0) {
    #####: 3398:					p->cost[_con_NT] = 0;
    #####: 3399:					p->rule._con = q->rule._con;
        -: 3400:				}
    #####: 3401:				if (q->cost[_acon_NT] == 0) {
    #####: 3402:					p->cost[_acon_NT] = 0;
    #####: 3403:					p->rule._acon = q->rule._acon;
        -: 3404:				}
    #####: 3405:				if (q->cost[_baseaddr_NT] == 0) {
    #####: 3406:					p->cost[_baseaddr_NT] = 0;
    #####: 3407:					p->rule._baseaddr = q->rule._baseaddr;
        -: 3408:				}
    #####: 3409:				if (q->cost[_base_NT] == 0) {
    #####: 3410:					p->cost[_base_NT] = 0;
    #####: 3411:					p->rule._base = q->rule._base;
        -: 3412:				}
    #####: 3413:				if (q->cost[_index_NT] == 0) {
    #####: 3414:					p->cost[_index_NT] = 0;
    #####: 3415:					p->rule._index = q->rule._index;
        -: 3416:				}
    #####: 3417:				if (q->cost[_con1_NT] == 0) {
    #####: 3418:					p->cost[_con1_NT] = 0;
    #####: 3419:					p->rule._con1 = q->rule._con1;
        -: 3420:				}
    #####: 3421:				if (q->cost[_con2_NT] == 0) {
    #####: 3422:					p->cost[_con2_NT] = 0;
    #####: 3423:					p->rule._con2 = q->rule._con2;
        -: 3424:				}
    #####: 3425:				if (q->cost[_con3_NT] == 0) {
    #####: 3426:					p->cost[_con3_NT] = 0;
    #####: 3427:					p->rule._con3 = q->rule._con3;
        -: 3428:				}
    #####: 3429:				if (q->cost[_con0_NT] == 0) {
    #####: 3430:					p->cost[_con0_NT] = 0;
    #####: 3431:					p->rule._con0 = q->rule._con0;
        -: 3432:				}
    #####: 3433:				if (q->cost[_addr_NT] == 0) {
    #####: 3434:					p->cost[_addr_NT] = 0;
    #####: 3435:					p->rule._addr = q->rule._addr;
        -: 3436:				}
    #####: 3437:				if (q->cost[_mem1_NT] == 0) {
    #####: 3438:					p->cost[_mem1_NT] = 0;
    #####: 3439:					p->rule._mem1 = q->rule._mem1;
        -: 3440:				}
    #####: 3441:				if (q->cost[_mem2_NT] == 0) {
    #####: 3442:					p->cost[_mem2_NT] = 0;
    #####: 3443:					p->rule._mem2 = q->rule._mem2;
        -: 3444:				}
    #####: 3445:				if (q->cost[_mem4_NT] == 0) {
    #####: 3446:					p->cost[_mem4_NT] = 0;
    #####: 3447:					p->rule._mem4 = q->rule._mem4;
        -: 3448:				}
    #####: 3449:				if (q->cost[_rc_NT] == 0) {
    #####: 3450:					p->cost[_rc_NT] = 0;
    #####: 3451:					p->rule._rc = q->rule._rc;
        -: 3452:				}
    #####: 3453:				if (q->cost[_mr_NT] == 0) {
    #####: 3454:					p->cost[_mr_NT] = 0;
    #####: 3455:					p->rule._mr = q->rule._mr;
        -: 3456:				}
    #####: 3457:				if (q->cost[_mr1_NT] == 0) {
    #####: 3458:					p->cost[_mr1_NT] = 0;
    #####: 3459:					p->rule._mr1 = q->rule._mr1;
        -: 3460:				}
    #####: 3461:				if (q->cost[_mr2_NT] == 0) {
    #####: 3462:					p->cost[_mr2_NT] = 0;
    #####: 3463:					p->rule._mr2 = q->rule._mr2;
        -: 3464:				}
    #####: 3465:				if (q->cost[_mrc_NT] == 0) {
    #####: 3466:					p->cost[_mrc_NT] = 0;
    #####: 3467:					p->rule._mrc = q->rule._mrc;
        -: 3468:				}
    #####: 3469:				if (q->cost[_rc5_NT] == 0) {
    #####: 3470:					p->cost[_rc5_NT] = 0;
    #####: 3471:					p->rule._rc5 = q->rule._rc5;
        -: 3472:				}
    #####: 3473:				if (q->cost[_mrca_NT] == 0) {
    #####: 3474:					p->cost[_mrca_NT] = 0;
    #####: 3475:					p->rule._mrca = q->rule._mrca;
        -: 3476:				}
    #####: 3477:				if (q->cost[_memf_NT] == 0) {
    #####: 3478:					p->cost[_memf_NT] = 0;
    #####: 3479:					p->rule._memf = q->rule._memf;
        -: 3480:				}
    #####: 3481:				if (q->cost[_flt_NT] == 0) {
    #####: 3482:					p->cost[_flt_NT] = 0;
    #####: 3483:					p->rule._flt = q->rule._flt;
        -: 3484:				}
    #####: 3485:				if (q->cost[_addrj_NT] == 0) {
    #####: 3486:					p->cost[_addrj_NT] = 0;
    #####: 3487:					p->rule._addrj = q->rule._addrj;
        -: 3488:				}
    #####: 3489:				if (q->cost[_cmpf_NT] == 0) {
    #####: 3490:					p->cost[_cmpf_NT] = 0;
    #####: 3491:					p->rule._cmpf = q->rule._cmpf;
        -: 3492:				}
        -: 3493:			}
    #####: 3494:			c = 0;
    #####: 3495:			if (c + 0 < p->cost[_freg_NT]) {
    #####: 3496:				p->cost[_freg_NT] = c + 0;
    #####: 3497:				p->rule._freg = 1;
    #####: 3498:				_closure_freg(a, c + 0);
        -: 3499:			}
        -: 3500:		}
        -: 3501:		/* memf: INDIRF4(addr) */
    #####: 3502:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + 0;
    #####: 3503:		if (c + 0 < p->cost[_memf_NT]) {
    #####: 3504:			p->cost[_memf_NT] = c + 0;
    #####: 3505:			p->rule._memf = 2;
    #####: 3506:			_closure_memf(a, c + 0);
        -: 3507:		}
        -: 3508:		/* cmpf: INDIRF4(addr) */
    #####: 3509:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + 0;
    #####: 3510:		if (c + 0 < p->cost[_cmpf_NT]) {
    #####: 3511:			p->cost[_cmpf_NT] = c + 0;
    #####: 3512:			p->rule._cmpf = 2;
        -: 3513:		}
    #####: 3514:		break;
        -: 3515:	case 4165: /* INDIRI4 */
    #####: 3516:		_label(LEFT_CHILD(a));
    #####: 3517:		if (	/* reg: INDIRI4(VREGP) */
        -: 3518:			LEFT_CHILD(a)->op == 711 /* VREGP */
        -: 3519:		) {
    #####: 3520:			if (mayrecalc(a)) {
    #####: 3521:				struct _state *q = a->syms[RX]->u.t.cse->x.state;
    #####: 3522:				if (q->cost[_stmt_NT] == 0) {
    #####: 3523:					p->cost[_stmt_NT] = 0;
    #####: 3524:					p->rule._stmt = q->rule._stmt;
        -: 3525:				}
    #####: 3526:				if (q->cost[_reg_NT] == 0) {
    #####: 3527:					p->cost[_reg_NT] = 0;
    #####: 3528:					p->rule._reg = q->rule._reg;
        -: 3529:				}
    #####: 3530:				if (q->cost[_freg_NT] == 0) {
    #####: 3531:					p->cost[_freg_NT] = 0;
    #####: 3532:					p->rule._freg = q->rule._freg;
        -: 3533:				}
    #####: 3534:				if (q->cost[_cnst_NT] == 0) {
    #####: 3535:					p->cost[_cnst_NT] = 0;
    #####: 3536:					p->rule._cnst = q->rule._cnst;
        -: 3537:				}
    #####: 3538:				if (q->cost[_con_NT] == 0) {
    #####: 3539:					p->cost[_con_NT] = 0;
    #####: 3540:					p->rule._con = q->rule._con;
        -: 3541:				}
    #####: 3542:				if (q->cost[_acon_NT] == 0) {
    #####: 3543:					p->cost[_acon_NT] = 0;
    #####: 3544:					p->rule._acon = q->rule._acon;
        -: 3545:				}
    #####: 3546:				if (q->cost[_baseaddr_NT] == 0) {
    #####: 3547:					p->cost[_baseaddr_NT] = 0;
    #####: 3548:					p->rule._baseaddr = q->rule._baseaddr;
        -: 3549:				}
    #####: 3550:				if (q->cost[_base_NT] == 0) {
    #####: 3551:					p->cost[_base_NT] = 0;
    #####: 3552:					p->rule._base = q->rule._base;
        -: 3553:				}
    #####: 3554:				if (q->cost[_index_NT] == 0) {
    #####: 3555:					p->cost[_index_NT] = 0;
    #####: 3556:					p->rule._index = q->rule._index;
        -: 3557:				}
    #####: 3558:				if (q->cost[_con1_NT] == 0) {
    #####: 3559:					p->cost[_con1_NT] = 0;
    #####: 3560:					p->rule._con1 = q->rule._con1;
        -: 3561:				}
    #####: 3562:				if (q->cost[_con2_NT] == 0) {
    #####: 3563:					p->cost[_con2_NT] = 0;
    #####: 3564:					p->rule._con2 = q->rule._con2;
        -: 3565:				}
    #####: 3566:				if (q->cost[_con3_NT] == 0) {
    #####: 3567:					p->cost[_con3_NT] = 0;
    #####: 3568:					p->rule._con3 = q->rule._con3;
        -: 3569:				}
    #####: 3570:				if (q->cost[_con0_NT] == 0) {
    #####: 3571:					p->cost[_con0_NT] = 0;
    #####: 3572:					p->rule._con0 = q->rule._con0;
        -: 3573:				}
    #####: 3574:				if (q->cost[_addr_NT] == 0) {
    #####: 3575:					p->cost[_addr_NT] = 0;
    #####: 3576:					p->rule._addr = q->rule._addr;
        -: 3577:				}
    #####: 3578:				if (q->cost[_mem1_NT] == 0) {
    #####: 3579:					p->cost[_mem1_NT] = 0;
    #####: 3580:					p->rule._mem1 = q->rule._mem1;
        -: 3581:				}
    #####: 3582:				if (q->cost[_mem2_NT] == 0) {
    #####: 3583:					p->cost[_mem2_NT] = 0;
    #####: 3584:					p->rule._mem2 = q->rule._mem2;
        -: 3585:				}
    #####: 3586:				if (q->cost[_mem4_NT] == 0) {
    #####: 3587:					p->cost[_mem4_NT] = 0;
    #####: 3588:					p->rule._mem4 = q->rule._mem4;
        -: 3589:				}
    #####: 3590:				if (q->cost[_rc_NT] == 0) {
    #####: 3591:					p->cost[_rc_NT] = 0;
    #####: 3592:					p->rule._rc = q->rule._rc;
        -: 3593:				}
    #####: 3594:				if (q->cost[_mr_NT] == 0) {
    #####: 3595:					p->cost[_mr_NT] = 0;
    #####: 3596:					p->rule._mr = q->rule._mr;
        -: 3597:				}
    #####: 3598:				if (q->cost[_mr1_NT] == 0) {
    #####: 3599:					p->cost[_mr1_NT] = 0;
    #####: 3600:					p->rule._mr1 = q->rule._mr1;
        -: 3601:				}
    #####: 3602:				if (q->cost[_mr2_NT] == 0) {
    #####: 3603:					p->cost[_mr2_NT] = 0;
    #####: 3604:					p->rule._mr2 = q->rule._mr2;
        -: 3605:				}
    #####: 3606:				if (q->cost[_mrc_NT] == 0) {
    #####: 3607:					p->cost[_mrc_NT] = 0;
    #####: 3608:					p->rule._mrc = q->rule._mrc;
        -: 3609:				}
    #####: 3610:				if (q->cost[_rc5_NT] == 0) {
    #####: 3611:					p->cost[_rc5_NT] = 0;
    #####: 3612:					p->rule._rc5 = q->rule._rc5;
        -: 3613:				}
    #####: 3614:				if (q->cost[_mrca_NT] == 0) {
    #####: 3615:					p->cost[_mrca_NT] = 0;
    #####: 3616:					p->rule._mrca = q->rule._mrca;
        -: 3617:				}
    #####: 3618:				if (q->cost[_memf_NT] == 0) {
    #####: 3619:					p->cost[_memf_NT] = 0;
    #####: 3620:					p->rule._memf = q->rule._memf;
        -: 3621:				}
    #####: 3622:				if (q->cost[_flt_NT] == 0) {
    #####: 3623:					p->cost[_flt_NT] = 0;
    #####: 3624:					p->rule._flt = q->rule._flt;
        -: 3625:				}
    #####: 3626:				if (q->cost[_addrj_NT] == 0) {
    #####: 3627:					p->cost[_addrj_NT] = 0;
    #####: 3628:					p->rule._addrj = q->rule._addrj;
        -: 3629:				}
    #####: 3630:				if (q->cost[_cmpf_NT] == 0) {
    #####: 3631:					p->cost[_cmpf_NT] = 0;
    #####: 3632:					p->rule._cmpf = q->rule._cmpf;
        -: 3633:				}
        -: 3634:			}
    #####: 3635:			c = 0;
    #####: 3636:			if (c + 0 < p->cost[_reg_NT]) {
    #####: 3637:				p->cost[_reg_NT] = c + 0;
    #####: 3638:				p->rule._reg = 5;
    #####: 3639:				_closure_reg(a, c + 0);
        -: 3640:			}
        -: 3641:		}
        -: 3642:		/* mem4: INDIRI4(addr) */
    #####: 3643:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + 0;
    #####: 3644:		if (c + 0 < p->cost[_mem4_NT]) {
    #####: 3645:			p->cost[_mem4_NT] = c + 0;
    #####: 3646:			p->rule._mem4 = 1;
    #####: 3647:			_closure_mem4(a, c + 0);
        -: 3648:		}
    #####: 3649:		break;
        -: 3650:	case 4166: /* INDIRU4 */
    #####: 3651:		_label(LEFT_CHILD(a));
    #####: 3652:		if (	/* reg: INDIRU4(VREGP) */
        -: 3653:			LEFT_CHILD(a)->op == 711 /* VREGP */
        -: 3654:		) {
    #####: 3655:			if (mayrecalc(a)) {
    #####: 3656:				struct _state *q = a->syms[RX]->u.t.cse->x.state;
    #####: 3657:				if (q->cost[_stmt_NT] == 0) {
    #####: 3658:					p->cost[_stmt_NT] = 0;
    #####: 3659:					p->rule._stmt = q->rule._stmt;
        -: 3660:				}
    #####: 3661:				if (q->cost[_reg_NT] == 0) {
    #####: 3662:					p->cost[_reg_NT] = 0;
    #####: 3663:					p->rule._reg = q->rule._reg;
        -: 3664:				}
    #####: 3665:				if (q->cost[_freg_NT] == 0) {
    #####: 3666:					p->cost[_freg_NT] = 0;
    #####: 3667:					p->rule._freg = q->rule._freg;
        -: 3668:				}
    #####: 3669:				if (q->cost[_cnst_NT] == 0) {
    #####: 3670:					p->cost[_cnst_NT] = 0;
    #####: 3671:					p->rule._cnst = q->rule._cnst;
        -: 3672:				}
    #####: 3673:				if (q->cost[_con_NT] == 0) {
    #####: 3674:					p->cost[_con_NT] = 0;
    #####: 3675:					p->rule._con = q->rule._con;
        -: 3676:				}
    #####: 3677:				if (q->cost[_acon_NT] == 0) {
    #####: 3678:					p->cost[_acon_NT] = 0;
    #####: 3679:					p->rule._acon = q->rule._acon;
        -: 3680:				}
    #####: 3681:				if (q->cost[_baseaddr_NT] == 0) {
    #####: 3682:					p->cost[_baseaddr_NT] = 0;
    #####: 3683:					p->rule._baseaddr = q->rule._baseaddr;
        -: 3684:				}
    #####: 3685:				if (q->cost[_base_NT] == 0) {
    #####: 3686:					p->cost[_base_NT] = 0;
    #####: 3687:					p->rule._base = q->rule._base;
        -: 3688:				}
    #####: 3689:				if (q->cost[_index_NT] == 0) {
    #####: 3690:					p->cost[_index_NT] = 0;
    #####: 3691:					p->rule._index = q->rule._index;
        -: 3692:				}
    #####: 3693:				if (q->cost[_con1_NT] == 0) {
    #####: 3694:					p->cost[_con1_NT] = 0;
    #####: 3695:					p->rule._con1 = q->rule._con1;
        -: 3696:				}
    #####: 3697:				if (q->cost[_con2_NT] == 0) {
    #####: 3698:					p->cost[_con2_NT] = 0;
    #####: 3699:					p->rule._con2 = q->rule._con2;
        -: 3700:				}
    #####: 3701:				if (q->cost[_con3_NT] == 0) {
    #####: 3702:					p->cost[_con3_NT] = 0;
    #####: 3703:					p->rule._con3 = q->rule._con3;
        -: 3704:				}
    #####: 3705:				if (q->cost[_con0_NT] == 0) {
    #####: 3706:					p->cost[_con0_NT] = 0;
    #####: 3707:					p->rule._con0 = q->rule._con0;
        -: 3708:				}
    #####: 3709:				if (q->cost[_addr_NT] == 0) {
    #####: 3710:					p->cost[_addr_NT] = 0;
    #####: 3711:					p->rule._addr = q->rule._addr;
        -: 3712:				}
    #####: 3713:				if (q->cost[_mem1_NT] == 0) {
    #####: 3714:					p->cost[_mem1_NT] = 0;
    #####: 3715:					p->rule._mem1 = q->rule._mem1;
        -: 3716:				}
    #####: 3717:				if (q->cost[_mem2_NT] == 0) {
    #####: 3718:					p->cost[_mem2_NT] = 0;
    #####: 3719:					p->rule._mem2 = q->rule._mem2;
        -: 3720:				}
    #####: 3721:				if (q->cost[_mem4_NT] == 0) {
    #####: 3722:					p->cost[_mem4_NT] = 0;
    #####: 3723:					p->rule._mem4 = q->rule._mem4;
        -: 3724:				}
    #####: 3725:				if (q->cost[_rc_NT] == 0) {
    #####: 3726:					p->cost[_rc_NT] = 0;
    #####: 3727:					p->rule._rc = q->rule._rc;
        -: 3728:				}
    #####: 3729:				if (q->cost[_mr_NT] == 0) {
    #####: 3730:					p->cost[_mr_NT] = 0;
    #####: 3731:					p->rule._mr = q->rule._mr;
        -: 3732:				}
    #####: 3733:				if (q->cost[_mr1_NT] == 0) {
    #####: 3734:					p->cost[_mr1_NT] = 0;
    #####: 3735:					p->rule._mr1 = q->rule._mr1;
        -: 3736:				}
    #####: 3737:				if (q->cost[_mr2_NT] == 0) {
    #####: 3738:					p->cost[_mr2_NT] = 0;
    #####: 3739:					p->rule._mr2 = q->rule._mr2;
        -: 3740:				}
    #####: 3741:				if (q->cost[_mrc_NT] == 0) {
    #####: 3742:					p->cost[_mrc_NT] = 0;
    #####: 3743:					p->rule._mrc = q->rule._mrc;
        -: 3744:				}
    #####: 3745:				if (q->cost[_rc5_NT] == 0) {
    #####: 3746:					p->cost[_rc5_NT] = 0;
    #####: 3747:					p->rule._rc5 = q->rule._rc5;
        -: 3748:				}
    #####: 3749:				if (q->cost[_mrca_NT] == 0) {
    #####: 3750:					p->cost[_mrca_NT] = 0;
    #####: 3751:					p->rule._mrca = q->rule._mrca;
        -: 3752:				}
    #####: 3753:				if (q->cost[_memf_NT] == 0) {
    #####: 3754:					p->cost[_memf_NT] = 0;
    #####: 3755:					p->rule._memf = q->rule._memf;
        -: 3756:				}
    #####: 3757:				if (q->cost[_flt_NT] == 0) {
    #####: 3758:					p->cost[_flt_NT] = 0;
    #####: 3759:					p->rule._flt = q->rule._flt;
        -: 3760:				}
    #####: 3761:				if (q->cost[_addrj_NT] == 0) {
    #####: 3762:					p->cost[_addrj_NT] = 0;
    #####: 3763:					p->rule._addrj = q->rule._addrj;
        -: 3764:				}
    #####: 3765:				if (q->cost[_cmpf_NT] == 0) {
    #####: 3766:					p->cost[_cmpf_NT] = 0;
    #####: 3767:					p->rule._cmpf = q->rule._cmpf;
        -: 3768:				}
        -: 3769:			}
    #####: 3770:			c = 0;
    #####: 3771:			if (c + 0 < p->cost[_reg_NT]) {
    #####: 3772:				p->cost[_reg_NT] = c + 0;
    #####: 3773:				p->rule._reg = 7;
    #####: 3774:				_closure_reg(a, c + 0);
        -: 3775:			}
        -: 3776:		}
        -: 3777:		/* mem4: INDIRU4(addr) */
    #####: 3778:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + 0;
    #####: 3779:		if (c + 0 < p->cost[_mem4_NT]) {
    #####: 3780:			p->cost[_mem4_NT] = c + 0;
    #####: 3781:			p->rule._mem4 = 2;
    #####: 3782:			_closure_mem4(a, c + 0);
        -: 3783:		}
    #####: 3784:		break;
        -: 3785:	case 4167: /* INDIRP4 */
    #####: 3786:		_label(LEFT_CHILD(a));
    #####: 3787:		if (	/* reg: INDIRP4(VREGP) */
        -: 3788:			LEFT_CHILD(a)->op == 711 /* VREGP */
        -: 3789:		) {
    #####: 3790:			if (mayrecalc(a)) {
    #####: 3791:				struct _state *q = a->syms[RX]->u.t.cse->x.state;
    #####: 3792:				if (q->cost[_stmt_NT] == 0) {
    #####: 3793:					p->cost[_stmt_NT] = 0;
    #####: 3794:					p->rule._stmt = q->rule._stmt;
        -: 3795:				}
    #####: 3796:				if (q->cost[_reg_NT] == 0) {
    #####: 3797:					p->cost[_reg_NT] = 0;
    #####: 3798:					p->rule._reg = q->rule._reg;
        -: 3799:				}
    #####: 3800:				if (q->cost[_freg_NT] == 0) {
    #####: 3801:					p->cost[_freg_NT] = 0;
    #####: 3802:					p->rule._freg = q->rule._freg;
        -: 3803:				}
    #####: 3804:				if (q->cost[_cnst_NT] == 0) {
    #####: 3805:					p->cost[_cnst_NT] = 0;
    #####: 3806:					p->rule._cnst = q->rule._cnst;
        -: 3807:				}
    #####: 3808:				if (q->cost[_con_NT] == 0) {
    #####: 3809:					p->cost[_con_NT] = 0;
    #####: 3810:					p->rule._con = q->rule._con;
        -: 3811:				}
    #####: 3812:				if (q->cost[_acon_NT] == 0) {
    #####: 3813:					p->cost[_acon_NT] = 0;
    #####: 3814:					p->rule._acon = q->rule._acon;
        -: 3815:				}
    #####: 3816:				if (q->cost[_baseaddr_NT] == 0) {
    #####: 3817:					p->cost[_baseaddr_NT] = 0;
    #####: 3818:					p->rule._baseaddr = q->rule._baseaddr;
        -: 3819:				}
    #####: 3820:				if (q->cost[_base_NT] == 0) {
    #####: 3821:					p->cost[_base_NT] = 0;
    #####: 3822:					p->rule._base = q->rule._base;
        -: 3823:				}
    #####: 3824:				if (q->cost[_index_NT] == 0) {
    #####: 3825:					p->cost[_index_NT] = 0;
    #####: 3826:					p->rule._index = q->rule._index;
        -: 3827:				}
    #####: 3828:				if (q->cost[_con1_NT] == 0) {
    #####: 3829:					p->cost[_con1_NT] = 0;
    #####: 3830:					p->rule._con1 = q->rule._con1;
        -: 3831:				}
    #####: 3832:				if (q->cost[_con2_NT] == 0) {
    #####: 3833:					p->cost[_con2_NT] = 0;
    #####: 3834:					p->rule._con2 = q->rule._con2;
        -: 3835:				}
    #####: 3836:				if (q->cost[_con3_NT] == 0) {
    #####: 3837:					p->cost[_con3_NT] = 0;
    #####: 3838:					p->rule._con3 = q->rule._con3;
        -: 3839:				}
    #####: 3840:				if (q->cost[_con0_NT] == 0) {
    #####: 3841:					p->cost[_con0_NT] = 0;
    #####: 3842:					p->rule._con0 = q->rule._con0;
        -: 3843:				}
    #####: 3844:				if (q->cost[_addr_NT] == 0) {
    #####: 3845:					p->cost[_addr_NT] = 0;
    #####: 3846:					p->rule._addr = q->rule._addr;
        -: 3847:				}
    #####: 3848:				if (q->cost[_mem1_NT] == 0) {
    #####: 3849:					p->cost[_mem1_NT] = 0;
    #####: 3850:					p->rule._mem1 = q->rule._mem1;
        -: 3851:				}
    #####: 3852:				if (q->cost[_mem2_NT] == 0) {
    #####: 3853:					p->cost[_mem2_NT] = 0;
    #####: 3854:					p->rule._mem2 = q->rule._mem2;
        -: 3855:				}
    #####: 3856:				if (q->cost[_mem4_NT] == 0) {
    #####: 3857:					p->cost[_mem4_NT] = 0;
    #####: 3858:					p->rule._mem4 = q->rule._mem4;
        -: 3859:				}
    #####: 3860:				if (q->cost[_rc_NT] == 0) {
    #####: 3861:					p->cost[_rc_NT] = 0;
    #####: 3862:					p->rule._rc = q->rule._rc;
        -: 3863:				}
    #####: 3864:				if (q->cost[_mr_NT] == 0) {
    #####: 3865:					p->cost[_mr_NT] = 0;
    #####: 3866:					p->rule._mr = q->rule._mr;
        -: 3867:				}
    #####: 3868:				if (q->cost[_mr1_NT] == 0) {
    #####: 3869:					p->cost[_mr1_NT] = 0;
    #####: 3870:					p->rule._mr1 = q->rule._mr1;
        -: 3871:				}
    #####: 3872:				if (q->cost[_mr2_NT] == 0) {
    #####: 3873:					p->cost[_mr2_NT] = 0;
    #####: 3874:					p->rule._mr2 = q->rule._mr2;
        -: 3875:				}
    #####: 3876:				if (q->cost[_mrc_NT] == 0) {
    #####: 3877:					p->cost[_mrc_NT] = 0;
    #####: 3878:					p->rule._mrc = q->rule._mrc;
        -: 3879:				}
    #####: 3880:				if (q->cost[_rc5_NT] == 0) {
    #####: 3881:					p->cost[_rc5_NT] = 0;
    #####: 3882:					p->rule._rc5 = q->rule._rc5;
        -: 3883:				}
    #####: 3884:				if (q->cost[_mrca_NT] == 0) {
    #####: 3885:					p->cost[_mrca_NT] = 0;
    #####: 3886:					p->rule._mrca = q->rule._mrca;
        -: 3887:				}
    #####: 3888:				if (q->cost[_memf_NT] == 0) {
    #####: 3889:					p->cost[_memf_NT] = 0;
    #####: 3890:					p->rule._memf = q->rule._memf;
        -: 3891:				}
    #####: 3892:				if (q->cost[_flt_NT] == 0) {
    #####: 3893:					p->cost[_flt_NT] = 0;
    #####: 3894:					p->rule._flt = q->rule._flt;
        -: 3895:				}
    #####: 3896:				if (q->cost[_addrj_NT] == 0) {
    #####: 3897:					p->cost[_addrj_NT] = 0;
    #####: 3898:					p->rule._addrj = q->rule._addrj;
        -: 3899:				}
    #####: 3900:				if (q->cost[_cmpf_NT] == 0) {
    #####: 3901:					p->cost[_cmpf_NT] = 0;
    #####: 3902:					p->rule._cmpf = q->rule._cmpf;
        -: 3903:				}
        -: 3904:			}
    #####: 3905:			c = 0;
    #####: 3906:			if (c + 0 < p->cost[_reg_NT]) {
    #####: 3907:				p->cost[_reg_NT] = c + 0;
    #####: 3908:				p->rule._reg = 6;
    #####: 3909:				_closure_reg(a, c + 0);
        -: 3910:			}
        -: 3911:		}
        -: 3912:		/* mem4: INDIRP4(addr) */
    #####: 3913:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + 0;
    #####: 3914:		if (c + 0 < p->cost[_mem4_NT]) {
    #####: 3915:			p->cost[_mem4_NT] = c + 0;
    #####: 3916:			p->rule._mem4 = 3;
    #####: 3917:			_closure_mem4(a, c + 0);
        -: 3918:		}
    #####: 3919:		break;
        -: 3920:	case 4209: /* CVFF4 */
    #####: 3921:		_label(LEFT_CHILD(a));
    #####: 3922:		if (	/* memf: CVFF4(INDIRF8(addr)) */
        -: 3923:			LEFT_CHILD(a)->op == 8257 /* INDIRF8 */
        -: 3924:		) {
    #####: 3925:			c = ((struct _state *)(LEFT_CHILD(LEFT_CHILD(a))->x.state))->cost[_addr_NT] + 0;
    #####: 3926:			if (c + 0 < p->cost[_memf_NT]) {
    #####: 3927:				p->cost[_memf_NT] = c + 0;
    #####: 3928:				p->rule._memf = 4;
    #####: 3929:				_closure_memf(a, c + 0);
        -: 3930:			}
        -: 3931:		}
        -: 3932:		/* freg: CVFF4(freg) */
    #####: 3933:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_freg_NT] + 12;
    #####: 3934:		if (c + 0 < p->cost[_freg_NT]) {
    #####: 3935:			p->cost[_freg_NT] = c + 0;
    #####: 3936:			p->rule._freg = 15;
    #####: 3937:			_closure_freg(a, c + 0);
        -: 3938:		}
    #####: 3939:		break;
        -: 3940:	case 4213: /* CVFI4 */
    #####: 3941:		_label(LEFT_CHILD(a));
        -: 3942:		/* reg: CVFI4(freg) */
    #####: 3943:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_freg_NT] + 31;
    #####: 3944:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 3945:			p->cost[_reg_NT] = c + 0;
    #####: 3946:			p->rule._reg = 63;
    #####: 3947:			_closure_reg(a, c + 0);
        -: 3948:		}
    #####: 3949:		break;
        -: 3950:	case 4225: /* CVIF4 */
    #####: 3951:		_label(LEFT_CHILD(a));
    #####: 3952:		if (	/* freg: CVIF4(INDIRI4(addr)) */
        -: 3953:			LEFT_CHILD(a)->op == 4165 /* INDIRI4 */
        -: 3954:		) {
    #####: 3955:			c = ((struct _state *)(LEFT_CHILD(LEFT_CHILD(a))->x.state))->cost[_addr_NT] + 10;
    #####: 3956:			if (c + 0 < p->cost[_freg_NT]) {
    #####: 3957:				p->cost[_freg_NT] = c + 0;
    #####: 3958:				p->rule._freg = 18;
    #####: 3959:				_closure_freg(a, c + 0);
        -: 3960:			}
        -: 3961:		}
        -: 3962:		/* freg: CVIF4(reg) */
    #####: 3963:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + 12;
    #####: 3964:		if (c + 0 < p->cost[_freg_NT]) {
    #####: 3965:			p->cost[_freg_NT] = c + 0;
    #####: 3966:			p->rule._freg = 19;
    #####: 3967:			_closure_freg(a, c + 0);
        -: 3968:		}
    #####: 3969:		break;
        -: 3970:	case 4229: /* CVII4 */
    #####: 3971:		_label(LEFT_CHILD(a));
    #####: 3972:		if (	/* reg: CVII4(INDIRI1(addr)) */
        -: 3973:			LEFT_CHILD(a)->op == 1093 /* INDIRI1 */
        -: 3974:		) {
    #####: 3975:			c = ((struct _state *)(LEFT_CHILD(LEFT_CHILD(a))->x.state))->cost[_addr_NT] + 3;
    #####: 3976:			if (c + 0 < p->cost[_reg_NT]) {
    #####: 3977:				p->cost[_reg_NT] = c + 0;
    #####: 3978:				p->rule._reg = 51;
    #####: 3979:				_closure_reg(a, c + 0);
        -: 3980:			}
        -: 3981:		}
    #####: 3982:		if (	/* reg: CVII4(INDIRI2(addr)) */
        -: 3983:			LEFT_CHILD(a)->op == 2117 /* INDIRI2 */
        -: 3984:		) {
    #####: 3985:			c = ((struct _state *)(LEFT_CHILD(LEFT_CHILD(a))->x.state))->cost[_addr_NT] + 3;
    #####: 3986:			if (c + 0 < p->cost[_reg_NT]) {
    #####: 3987:				p->cost[_reg_NT] = c + 0;
    #####: 3988:				p->rule._reg = 52;
    #####: 3989:				_closure_reg(a, c + 0);
        -: 3990:			}
        -: 3991:		}
        -: 3992:		/* reg: CVII4(reg) */
    #####: 3993:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + 3;
    #####: 3994:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 3995:			p->cost[_reg_NT] = c + 0;
    #####: 3996:			p->rule._reg = 55;
    #####: 3997:			_closure_reg(a, c + 0);
        -: 3998:		}
    #####: 3999:		break;
        -: 4000:	case 4230: /* CVIU4 */
    #####: 4001:		_label(LEFT_CHILD(a));
        -: 4002:		/* reg: CVIU4(reg) */
    #####: 4003:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + 3;
    #####: 4004:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 4005:			p->cost[_reg_NT] = c + 0;
    #####: 4006:			p->rule._reg = 56;
    #####: 4007:			_closure_reg(a, c + 0);
        -: 4008:		}
    #####: 4009:		break;
        -: 4010:	case 4246: /* CVPU4 */
    #####: 4011:		_label(LEFT_CHILD(a));
        -: 4012:		/* reg: CVPU4(reg) */
    #####: 4013:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + (move(a));
    #####: 4014:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 4015:			p->cost[_reg_NT] = c + 0;
    #####: 4016:			p->rule._reg = 49;
    #####: 4017:			_closure_reg(a, c + 0);
        -: 4018:		}
    #####: 4019:		break;
        -: 4020:	case 4247: /* CVPP4 */
    #####: 4021:		break;
        -: 4022:	case 4277: /* CVUI4 */
    #####: 4023:		_label(LEFT_CHILD(a));
        -: 4024:		/* reg: CVUI4(reg) */
    #####: 4025:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + 3;
    #####: 4026:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 4027:			p->cost[_reg_NT] = c + 0;
    #####: 4028:			p->rule._reg = 57;
    #####: 4029:			_closure_reg(a, c + 0);
        -: 4030:		}
    #####: 4031:		break;
        -: 4032:	case 4278: /* CVUU4 */
    #####: 4033:		_label(LEFT_CHILD(a));
    #####: 4034:		if (	/* reg: CVUU4(INDIRU1(addr)) */
        -: 4035:			LEFT_CHILD(a)->op == 1094 /* INDIRU1 */
        -: 4036:		) {
    #####: 4037:			c = ((struct _state *)(LEFT_CHILD(LEFT_CHILD(a))->x.state))->cost[_addr_NT] + 3;
    #####: 4038:			if (c + 0 < p->cost[_reg_NT]) {
    #####: 4039:				p->cost[_reg_NT] = c + 0;
    #####: 4040:				p->rule._reg = 53;
    #####: 4041:				_closure_reg(a, c + 0);
        -: 4042:			}
        -: 4043:		}
    #####: 4044:		if (	/* reg: CVUU4(INDIRU2(addr)) */
        -: 4045:			LEFT_CHILD(a)->op == 2118 /* INDIRU2 */
        -: 4046:		) {
    #####: 4047:			c = ((struct _state *)(LEFT_CHILD(LEFT_CHILD(a))->x.state))->cost[_addr_NT] + 3;
    #####: 4048:			if (c + 0 < p->cost[_reg_NT]) {
    #####: 4049:				p->cost[_reg_NT] = c + 0;
    #####: 4050:				p->rule._reg = 54;
    #####: 4051:				_closure_reg(a, c + 0);
        -: 4052:			}
        -: 4053:		}
        -: 4054:		/* reg: CVUU4(reg) */
    #####: 4055:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + 3;
    #####: 4056:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 4057:			p->cost[_reg_NT] = c + 0;
    #####: 4058:			p->rule._reg = 58;
    #####: 4059:			_closure_reg(a, c + 0);
        -: 4060:		}
    #####: 4061:		break;
        -: 4062:	case 4279: /* CVUP4 */
    #####: 4063:		_label(LEFT_CHILD(a));
        -: 4064:		/* reg: CVUP4(reg) */
    #####: 4065:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + (move(a));
    #####: 4066:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 4067:			p->cost[_reg_NT] = c + 0;
    #####: 4068:			p->rule._reg = 50;
    #####: 4069:			_closure_reg(a, c + 0);
        -: 4070:		}
    #####: 4071:		break;
        -: 4072:	case 4289: /* NEGF4 */
    #####: 4073:		_label(LEFT_CHILD(a));
        -: 4074:		/* freg: NEGF4(freg) */
    #####: 4075:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_freg_NT] + 0;
    #####: 4076:		if (c + 0 < p->cost[_freg_NT]) {
    #####: 4077:			p->cost[_freg_NT] = c + 0;
    #####: 4078:			p->rule._freg = 5;
    #####: 4079:			_closure_freg(a, c + 0);
        -: 4080:		}
    #####: 4081:		break;
        -: 4082:	case 4293: /* NEGI4 */
    #####: 4083:		_label(LEFT_CHILD(a));
        -: 4084:		/* reg: NEGI4(reg) */
    #####: 4085:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + 2;
    #####: 4086:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 4087:			p->cost[_reg_NT] = c + 0;
    #####: 4088:			p->rule._reg = 37;
    #####: 4089:			_closure_reg(a, c + 0);
        -: 4090:		}
    #####: 4091:		break;
        -: 4092:	case 4305: /* CALLF4 */
    #####: 4093:		_label(LEFT_CHILD(a));
        -: 4094:		/* freg: CALLF4(addrj) */
    #####: 4095:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addrj_NT] + (hasargs(a));
    #####: 4096:		if (c + 0 < p->cost[_freg_NT]) {
    #####: 4097:			p->cost[_freg_NT] = c + 0;
    #####: 4098:			p->rule._freg = 37;
    #####: 4099:			_closure_freg(a, c + 0);
        -: 4100:		}
        -: 4101:		/* freg: CALLF4(addrj) */
    #####: 4102:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addrj_NT] + 1;
    #####: 4103:		if (c + 0 < p->cost[_freg_NT]) {
    #####: 4104:			p->cost[_freg_NT] = c + 0;
    #####: 4105:			p->rule._freg = 38;
    #####: 4106:			_closure_freg(a, c + 0);
        -: 4107:		}
        -: 4108:		/* stmt: CALLF4(addrj) */
    #####: 4109:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addrj_NT] + (hasargs(a));
    #####: 4110:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 4111:			p->cost[_stmt_NT] = c + 0;
    #####: 4112:			p->rule._stmt = 101;
        -: 4113:		}
        -: 4114:		/* stmt: CALLF4(addrj) */
    #####: 4115:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addrj_NT] + 1;
    #####: 4116:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 4117:			p->cost[_stmt_NT] = c + 0;
    #####: 4118:			p->rule._stmt = 102;
        -: 4119:		}
    #####: 4120:		break;
        -: 4121:	case 4309: /* CALLI4 */
    #####: 4122:		_label(LEFT_CHILD(a));
        -: 4123:		/* reg: CALLI4(addrj) */
    #####: 4124:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addrj_NT] + (hasargs(a));
    #####: 4125:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 4126:			p->cost[_reg_NT] = c + 0;
    #####: 4127:			p->rule._reg = 64;
    #####: 4128:			_closure_reg(a, c + 0);
        -: 4129:		}
        -: 4130:		/* reg: CALLI4(addrj) */
    #####: 4131:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addrj_NT] + 1;
    #####: 4132:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 4133:			p->cost[_reg_NT] = c + 0;
    #####: 4134:			p->rule._reg = 67;
    #####: 4135:			_closure_reg(a, c + 0);
        -: 4136:		}
    #####: 4137:		break;
        -: 4138:	case 4310: /* CALLU4 */
    #####: 4139:		_label(LEFT_CHILD(a));
        -: 4140:		/* reg: CALLU4(addrj) */
    #####: 4141:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addrj_NT] + (hasargs(a));
    #####: 4142:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 4143:			p->cost[_reg_NT] = c + 0;
    #####: 4144:			p->rule._reg = 65;
    #####: 4145:			_closure_reg(a, c + 0);
        -: 4146:		}
        -: 4147:		/* reg: CALLU4(addrj) */
    #####: 4148:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addrj_NT] + 1;
    #####: 4149:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 4150:			p->cost[_reg_NT] = c + 0;
    #####: 4151:			p->rule._reg = 68;
    #####: 4152:			_closure_reg(a, c + 0);
        -: 4153:		}
    #####: 4154:		break;
        -: 4155:	case 4311: /* CALLP4 */
    #####: 4156:		_label(LEFT_CHILD(a));
        -: 4157:		/* reg: CALLP4(addrj) */
    #####: 4158:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addrj_NT] + (hasargs(a));
    #####: 4159:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 4160:			p->cost[_reg_NT] = c + 0;
    #####: 4161:			p->rule._reg = 66;
    #####: 4162:			_closure_reg(a, c + 0);
        -: 4163:		}
        -: 4164:		/* reg: CALLP4(addrj) */
    #####: 4165:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addrj_NT] + 1;
    #####: 4166:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 4167:			p->cost[_reg_NT] = c + 0;
    #####: 4168:			p->rule._reg = 69;
    #####: 4169:			_closure_reg(a, c + 0);
        -: 4170:		}
    #####: 4171:		break;
        -: 4172:	case 4321: /* LOADF4 */
    #####: 4173:		break;
        -: 4174:	case 4325: /* LOADI4 */
    #####: 4175:		_label(LEFT_CHILD(a));
        -: 4176:		/* reg: LOADI4(reg) */
    #####: 4177:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + (move(a));
    #####: 4178:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 4179:			p->cost[_reg_NT] = c + 0;
    #####: 4180:			p->rule._reg = 18;
    #####: 4181:			_closure_reg(a, c + 0);
        -: 4182:		}
    #####: 4183:		break;
        -: 4184:	case 4326: /* LOADU4 */
    #####: 4185:		_label(LEFT_CHILD(a));
        -: 4186:		/* reg: LOADU4(reg) */
    #####: 4187:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + (move(a));
    #####: 4188:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 4189:			p->cost[_reg_NT] = c + 0;
    #####: 4190:			p->rule._reg = 21;
    #####: 4191:			_closure_reg(a, c + 0);
        -: 4192:		}
    #####: 4193:		break;
        -: 4194:	case 4327: /* LOADP4 */
    #####: 4195:		_label(LEFT_CHILD(a));
        -: 4196:		/* reg: LOADP4(reg) */
    #####: 4197:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + (move(a));
    #####: 4198:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 4199:			p->cost[_reg_NT] = c + 0;
    #####: 4200:			p->rule._reg = 22;
    #####: 4201:			_closure_reg(a, c + 0);
        -: 4202:		}
    #####: 4203:		break;
        -: 4204:	case 4337: /* RETF4 */
    #####: 4205:		_label(LEFT_CHILD(a));
        -: 4206:		/* stmt: RETF4(freg) */
    #####: 4207:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_freg_NT] + 0;
    #####: 4208:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 4209:			p->cost[_stmt_NT] = c + 0;
    #####: 4210:			p->rule._stmt = 108;
        -: 4211:		}
    #####: 4212:		break;
        -: 4213:	case 4341: /* RETI4 */
    #####: 4214:		_label(LEFT_CHILD(a));
        -: 4215:		/* stmt: RETI4(reg) */
    #####: 4216:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
    #####: 4217:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 4218:			p->cost[_stmt_NT] = c + 0;
    #####: 4219:			p->rule._stmt = 105;
        -: 4220:		}
    #####: 4221:		break;
        -: 4222:	case 4342: /* RETU4 */
    #####: 4223:		_label(LEFT_CHILD(a));
        -: 4224:		/* stmt: RETU4(reg) */
    #####: 4225:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
    #####: 4226:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 4227:			p->cost[_stmt_NT] = c + 0;
    #####: 4228:			p->rule._stmt = 106;
        -: 4229:		}
    #####: 4230:		break;
        -: 4231:	case 4343: /* RETP4 */
    #####: 4232:		_label(LEFT_CHILD(a));
        -: 4233:		/* stmt: RETP4(reg) */
    #####: 4234:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
    #####: 4235:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 4236:			p->cost[_stmt_NT] = c + 0;
    #####: 4237:			p->rule._stmt = 107;
        -: 4238:		}
    #####: 4239:		break;
        -: 4240:	case 4359: /* ADDRGP4 */
        -: 4241:		/* acon: ADDRGP4 */
    #####: 4242:		if (0 + 0 < p->cost[_acon_NT]) {
    #####: 4243:			p->cost[_acon_NT] = 0 + 0;
    #####: 4244:			p->rule._acon = 1;
        -: 4245:		}
        -: 4246:		/* baseaddr: ADDRGP4 */
    #####: 4247:		if (0 + 0 < p->cost[_baseaddr_NT]) {
    #####: 4248:			p->cost[_baseaddr_NT] = 0 + 0;
    #####: 4249:			p->rule._baseaddr = 1;
    #####: 4250:			_closure_baseaddr(a, 0 + 0);
        -: 4251:		}
        -: 4252:		/* mrca: ADDRGP4 */
    #####: 4253:		if (0 + 0 < p->cost[_mrca_NT]) {
    #####: 4254:			p->cost[_mrca_NT] = 0 + 0;
    #####: 4255:			p->rule._mrca = 3;
        -: 4256:		}
        -: 4257:		/* addrj: ADDRGP4 */
    #####: 4258:		if (0 + 0 < p->cost[_addrj_NT]) {
    #####: 4259:			p->cost[_addrj_NT] = 0 + 0;
    #####: 4260:			p->rule._addrj = 1;
        -: 4261:		}
    #####: 4262:		break;
        -: 4263:	case 4375: /* ADDRFP4 */
        -: 4264:		/* base: ADDRFP4 */
    #####: 4265:		if (0 + 0 < p->cost[_base_NT]) {
    #####: 4266:			p->cost[_base_NT] = 0 + 0;
    #####: 4267:			p->rule._base = 5;
    #####: 4268:			_closure_base(a, 0 + 0);
        -: 4269:		}
    #####: 4270:		break;
        -: 4271:	case 4391: /* ADDRLP4 */
        -: 4272:		/* base: ADDRLP4 */
    #####: 4273:		if (0 + 0 < p->cost[_base_NT]) {
    #####: 4274:			p->cost[_base_NT] = 0 + 0;
    #####: 4275:			p->rule._base = 6;
    #####: 4276:			_closure_base(a, 0 + 0);
        -: 4277:		}
    #####: 4278:		break;
        -: 4279:	case 4401: /* ADDF4 */
    #####: 4280:		_label(LEFT_CHILD(a));
    #####: 4281:		_label(RIGHT_CHILD(a));
        -: 4282:		/* freg: ADDF4(freg,flt) */
    #####: 4283:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_freg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_flt_NT] + 0;
    #####: 4284:		if (c + 0 < p->cost[_freg_NT]) {
    #####: 4285:			p->cost[_freg_NT] = c + 0;
    #####: 4286:			p->rule._freg = 6;
    #####: 4287:			_closure_freg(a, c + 0);
        -: 4288:		}
    #####: 4289:		break;
        -: 4290:	case 4405: /* ADDI4 */
    #####: 4291:		_label(LEFT_CHILD(a));
    #####: 4292:		_label(RIGHT_CHILD(a));
        -: 4293:		/* base: ADDI4(reg,acon) */
    #####: 4294:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_acon_NT] + 0;
    #####: 4295:		if (c + 0 < p->cost[_base_NT]) {
    #####: 4296:			p->cost[_base_NT] = c + 0;
    #####: 4297:			p->rule._base = 2;
    #####: 4298:			_closure_base(a, c + 0);
        -: 4299:		}
        -: 4300:		/* addr: ADDI4(index,baseaddr) */
    #####: 4301:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_index_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_baseaddr_NT] + 0;
    #####: 4302:		if (c + 0 < p->cost[_addr_NT]) {
    #####: 4303:			p->cost[_addr_NT] = c + 0;
    #####: 4304:			p->rule._addr = 3;
    #####: 4305:			_closure_addr(a, c + 0);
        -: 4306:		}
        -: 4307:		/* addr: ADDI4(reg,baseaddr) */
    #####: 4308:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_baseaddr_NT] + 0;
    #####: 4309:		if (c + 0 < p->cost[_addr_NT]) {
    #####: 4310:			p->cost[_addr_NT] = c + 0;
    #####: 4311:			p->rule._addr = 6;
    #####: 4312:			_closure_addr(a, c + 0);
        -: 4313:		}
        -: 4314:		/* addr: ADDI4(index,reg) */
    #####: 4315:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_index_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
    #####: 4316:		if (c + 0 < p->cost[_addr_NT]) {
    #####: 4317:			p->cost[_addr_NT] = c + 0;
    #####: 4318:			p->rule._addr = 9;
    #####: 4319:			_closure_addr(a, c + 0);
        -: 4320:		}
        -: 4321:		/* reg: ADDI4(reg,mrc) */
    #####: 4322:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_mrc_NT] + 1;
    #####: 4323:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 4324:			p->cost[_reg_NT] = c + 0;
    #####: 4325:			p->rule._reg = 23;
    #####: 4326:			_closure_reg(a, c + 0);
        -: 4327:		}
    #####: 4328:		break;
        -: 4329:	case 4406: /* ADDU4 */
    #####: 4330:		_label(LEFT_CHILD(a));
    #####: 4331:		_label(RIGHT_CHILD(a));
        -: 4332:		/* base: ADDU4(reg,acon) */
    #####: 4333:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_acon_NT] + 0;
    #####: 4334:		if (c + 0 < p->cost[_base_NT]) {
    #####: 4335:			p->cost[_base_NT] = c + 0;
    #####: 4336:			p->rule._base = 4;
    #####: 4337:			_closure_base(a, c + 0);
        -: 4338:		}
        -: 4339:		/* addr: ADDU4(index,baseaddr) */
    #####: 4340:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_index_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_baseaddr_NT] + 0;
    #####: 4341:		if (c + 0 < p->cost[_addr_NT]) {
    #####: 4342:			p->cost[_addr_NT] = c + 0;
    #####: 4343:			p->rule._addr = 5;
    #####: 4344:			_closure_addr(a, c + 0);
        -: 4345:		}
        -: 4346:		/* addr: ADDU4(reg,baseaddr) */
    #####: 4347:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_baseaddr_NT] + 0;
    #####: 4348:		if (c + 0 < p->cost[_addr_NT]) {
    #####: 4349:			p->cost[_addr_NT] = c + 0;
    #####: 4350:			p->rule._addr = 8;
    #####: 4351:			_closure_addr(a, c + 0);
        -: 4352:		}
        -: 4353:		/* addr: ADDU4(index,reg) */
    #####: 4354:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_index_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
    #####: 4355:		if (c + 0 < p->cost[_addr_NT]) {
    #####: 4356:			p->cost[_addr_NT] = c + 0;
    #####: 4357:			p->rule._addr = 11;
    #####: 4358:			_closure_addr(a, c + 0);
        -: 4359:		}
        -: 4360:		/* reg: ADDU4(reg,mrc) */
    #####: 4361:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_mrc_NT] + 1;
    #####: 4362:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 4363:			p->cost[_reg_NT] = c + 0;
    #####: 4364:			p->rule._reg = 25;
    #####: 4365:			_closure_reg(a, c + 0);
        -: 4366:		}
    #####: 4367:		break;
        -: 4368:	case 4407: /* ADDP4 */
    #####: 4369:		_label(LEFT_CHILD(a));
    #####: 4370:		_label(RIGHT_CHILD(a));
        -: 4371:		/* base: ADDP4(reg,acon) */
    #####: 4372:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_acon_NT] + 0;
    #####: 4373:		if (c + 0 < p->cost[_base_NT]) {
    #####: 4374:			p->cost[_base_NT] = c + 0;
    #####: 4375:			p->rule._base = 3;
    #####: 4376:			_closure_base(a, c + 0);
        -: 4377:		}
        -: 4378:		/* addr: ADDP4(index,baseaddr) */
    #####: 4379:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_index_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_baseaddr_NT] + 0;
    #####: 4380:		if (c + 0 < p->cost[_addr_NT]) {
    #####: 4381:			p->cost[_addr_NT] = c + 0;
    #####: 4382:			p->rule._addr = 4;
    #####: 4383:			_closure_addr(a, c + 0);
        -: 4384:		}
        -: 4385:		/* addr: ADDP4(reg,baseaddr) */
    #####: 4386:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_baseaddr_NT] + 0;
    #####: 4387:		if (c + 0 < p->cost[_addr_NT]) {
    #####: 4388:			p->cost[_addr_NT] = c + 0;
    #####: 4389:			p->rule._addr = 7;
    #####: 4390:			_closure_addr(a, c + 0);
        -: 4391:		}
        -: 4392:		/* addr: ADDP4(index,reg) */
    #####: 4393:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_index_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
    #####: 4394:		if (c + 0 < p->cost[_addr_NT]) {
    #####: 4395:			p->cost[_addr_NT] = c + 0;
    #####: 4396:			p->rule._addr = 10;
    #####: 4397:			_closure_addr(a, c + 0);
        -: 4398:		}
        -: 4399:		/* reg: ADDP4(reg,mrc) */
    #####: 4400:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_mrc_NT] + 1;
    #####: 4401:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 4402:			p->cost[_reg_NT] = c + 0;
    #####: 4403:			p->rule._reg = 24;
    #####: 4404:			_closure_reg(a, c + 0);
        -: 4405:		}
    #####: 4406:		break;
        -: 4407:	case 4417: /* SUBF4 */
    #####: 4408:		_label(LEFT_CHILD(a));
    #####: 4409:		_label(RIGHT_CHILD(a));
        -: 4410:		/* freg: SUBF4(freg,flt) */
    #####: 4411:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_freg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_flt_NT] + 0;
    #####: 4412:		if (c + 0 < p->cost[_freg_NT]) {
    #####: 4413:			p->cost[_freg_NT] = c + 0;
    #####: 4414:			p->rule._freg = 12;
    #####: 4415:			_closure_freg(a, c + 0);
        -: 4416:		}
    #####: 4417:		break;
        -: 4418:	case 4421: /* SUBI4 */
    #####: 4419:		_label(LEFT_CHILD(a));
    #####: 4420:		_label(RIGHT_CHILD(a));
        -: 4421:		/* reg: SUBI4(reg,mrc) */
    #####: 4422:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_mrc_NT] + 1;
    #####: 4423:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 4424:			p->cost[_reg_NT] = c + 0;
    #####: 4425:			p->rule._reg = 26;
    #####: 4426:			_closure_reg(a, c + 0);
        -: 4427:		}
    #####: 4428:		break;
        -: 4429:	case 4422: /* SUBU4 */
    #####: 4430:		_label(LEFT_CHILD(a));
    #####: 4431:		_label(RIGHT_CHILD(a));
        -: 4432:		/* reg: SUBU4(reg,mrc) */
    #####: 4433:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_mrc_NT] + 1;
    #####: 4434:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 4435:			p->cost[_reg_NT] = c + 0;
    #####: 4436:			p->rule._reg = 28;
    #####: 4437:			_closure_reg(a, c + 0);
        -: 4438:		}
    #####: 4439:		break;
        -: 4440:	case 4423: /* SUBP4 */
    #####: 4441:		_label(LEFT_CHILD(a));
    #####: 4442:		_label(RIGHT_CHILD(a));
        -: 4443:		/* reg: SUBP4(reg,mrc) */
    #####: 4444:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_mrc_NT] + 1;
    #####: 4445:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 4446:			p->cost[_reg_NT] = c + 0;
    #####: 4447:			p->rule._reg = 27;
    #####: 4448:			_closure_reg(a, c + 0);
        -: 4449:		}
    #####: 4450:		break;
        -: 4451:	case 4437: /* LSHI4 */
    #####: 4452:		_label(LEFT_CHILD(a));
    #####: 4453:		_label(RIGHT_CHILD(a));
        -: 4454:		/* index: LSHI4(reg,con1) */
    #####: 4455:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_con1_NT] + 0;
    #####: 4456:		if (c + 0 < p->cost[_index_NT]) {
    #####: 4457:			p->cost[_index_NT] = c + 0;
    #####: 4458:			p->rule._index = 2;
    #####: 4459:			_closure_index(a, c + 0);
        -: 4460:		}
        -: 4461:		/* index: LSHI4(reg,con2) */
    #####: 4462:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_con2_NT] + 0;
    #####: 4463:		if (c + 0 < p->cost[_index_NT]) {
    #####: 4464:			p->cost[_index_NT] = c + 0;
    #####: 4465:			p->rule._index = 3;
    #####: 4466:			_closure_index(a, c + 0);
        -: 4467:		}
        -: 4468:		/* index: LSHI4(reg,con3) */
    #####: 4469:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_con3_NT] + 0;
    #####: 4470:		if (c + 0 < p->cost[_index_NT]) {
    #####: 4471:			p->cost[_index_NT] = c + 0;
    #####: 4472:			p->rule._index = 4;
    #####: 4473:			_closure_index(a, c + 0);
        -: 4474:		}
        -: 4475:		/* reg: LSHI4(reg,rc5) */
    #####: 4476:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_rc5_NT] + 2;
    #####: 4477:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 4478:			p->cost[_reg_NT] = c + 0;
    #####: 4479:			p->rule._reg = 38;
    #####: 4480:			_closure_reg(a, c + 0);
        -: 4481:		}
    #####: 4482:		break;
        -: 4483:	case 4438: /* LSHU4 */
    #####: 4484:		_label(LEFT_CHILD(a));
    #####: 4485:		_label(RIGHT_CHILD(a));
        -: 4486:		/* index: LSHU4(reg,con1) */
    #####: 4487:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_con1_NT] + 0;
    #####: 4488:		if (c + 0 < p->cost[_index_NT]) {
    #####: 4489:			p->cost[_index_NT] = c + 0;
    #####: 4490:			p->rule._index = 5;
    #####: 4491:			_closure_index(a, c + 0);
        -: 4492:		}
        -: 4493:		/* index: LSHU4(reg,con2) */
    #####: 4494:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_con2_NT] + 0;
    #####: 4495:		if (c + 0 < p->cost[_index_NT]) {
    #####: 4496:			p->cost[_index_NT] = c + 0;
    #####: 4497:			p->rule._index = 6;
    #####: 4498:			_closure_index(a, c + 0);
        -: 4499:		}
        -: 4500:		/* index: LSHU4(reg,con3) */
    #####: 4501:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_con3_NT] + 0;
    #####: 4502:		if (c + 0 < p->cost[_index_NT]) {
    #####: 4503:			p->cost[_index_NT] = c + 0;
    #####: 4504:			p->rule._index = 7;
    #####: 4505:			_closure_index(a, c + 0);
        -: 4506:		}
        -: 4507:		/* reg: LSHU4(reg,rc5) */
    #####: 4508:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_rc5_NT] + 2;
    #####: 4509:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 4510:			p->cost[_reg_NT] = c + 0;
    #####: 4511:			p->rule._reg = 39;
    #####: 4512:			_closure_reg(a, c + 0);
        -: 4513:		}
    #####: 4514:		break;
        -: 4515:	case 4453: /* MODI4 */
    #####: 4516:		_label(LEFT_CHILD(a));
    #####: 4517:		_label(RIGHT_CHILD(a));
        -: 4518:		/* reg: MODI4(reg,reg) */
    #####: 4519:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
    #####: 4520:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 4521:			p->cost[_reg_NT] = c + 0;
    #####: 4522:			p->rule._reg = 48;
    #####: 4523:			_closure_reg(a, c + 0);
        -: 4524:		}
    #####: 4525:		break;
        -: 4526:	case 4454: /* MODU4 */
    #####: 4527:		_label(LEFT_CHILD(a));
    #####: 4528:		_label(RIGHT_CHILD(a));
        -: 4529:		/* reg: MODU4(reg,reg) */
    #####: 4530:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
    #####: 4531:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 4532:			p->cost[_reg_NT] = c + 0;
    #####: 4533:			p->rule._reg = 46;
    #####: 4534:			_closure_reg(a, c + 0);
        -: 4535:		}
    #####: 4536:		break;
        -: 4537:	case 4469: /* RSHI4 */
    #####: 4538:		_label(LEFT_CHILD(a));
    #####: 4539:		_label(RIGHT_CHILD(a));
        -: 4540:		/* reg: RSHI4(reg,rc5) */
    #####: 4541:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_rc5_NT] + 2;
    #####: 4542:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 4543:			p->cost[_reg_NT] = c + 0;
    #####: 4544:			p->rule._reg = 40;
    #####: 4545:			_closure_reg(a, c + 0);
        -: 4546:		}
    #####: 4547:		break;
        -: 4548:	case 4470: /* RSHU4 */
    #####: 4549:		_label(LEFT_CHILD(a));
    #####: 4550:		_label(RIGHT_CHILD(a));
        -: 4551:		/* reg: RSHU4(reg,rc5) */
    #####: 4552:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_rc5_NT] + 2;
    #####: 4553:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 4554:			p->cost[_reg_NT] = c + 0;
    #####: 4555:			p->rule._reg = 41;
    #####: 4556:			_closure_reg(a, c + 0);
        -: 4557:		}
    #####: 4558:		break;
        -: 4559:	case 4485: /* BANDI4 */
    #####: 4560:		_label(LEFT_CHILD(a));
    #####: 4561:		_label(RIGHT_CHILD(a));
        -: 4562:		/* reg: BANDI4(reg,mrc) */
    #####: 4563:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_mrc_NT] + 1;
    #####: 4564:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 4565:			p->cost[_reg_NT] = c + 0;
    #####: 4566:			p->rule._reg = 29;
    #####: 4567:			_closure_reg(a, c + 0);
        -: 4568:		}
    #####: 4569:		break;
        -: 4570:	case 4486: /* BANDU4 */
    #####: 4571:		_label(LEFT_CHILD(a));
    #####: 4572:		_label(RIGHT_CHILD(a));
        -: 4573:		/* reg: BANDU4(reg,mrc) */
    #####: 4574:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_mrc_NT] + 1;
    #####: 4575:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 4576:			p->cost[_reg_NT] = c + 0;
    #####: 4577:			p->rule._reg = 32;
    #####: 4578:			_closure_reg(a, c + 0);
        -: 4579:		}
    #####: 4580:		break;
        -: 4581:	case 4501: /* BCOMI4 */
    #####: 4582:		_label(LEFT_CHILD(a));
        -: 4583:		/* reg: BCOMI4(reg) */
    #####: 4584:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + 2;
    #####: 4585:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 4586:			p->cost[_reg_NT] = c + 0;
    #####: 4587:			p->rule._reg = 35;
    #####: 4588:			_closure_reg(a, c + 0);
        -: 4589:		}
    #####: 4590:		break;
        -: 4591:	case 4502: /* BCOMU4 */
    #####: 4592:		_label(LEFT_CHILD(a));
        -: 4593:		/* reg: BCOMU4(reg) */
    #####: 4594:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + 2;
    #####: 4595:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 4596:			p->cost[_reg_NT] = c + 0;
    #####: 4597:			p->rule._reg = 36;
    #####: 4598:			_closure_reg(a, c + 0);
        -: 4599:		}
    #####: 4600:		break;
        -: 4601:	case 4517: /* BORI4 */
    #####: 4602:		_label(LEFT_CHILD(a));
    #####: 4603:		_label(RIGHT_CHILD(a));
        -: 4604:		/* reg: BORI4(reg,mrc) */
    #####: 4605:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_mrc_NT] + 1;
    #####: 4606:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 4607:			p->cost[_reg_NT] = c + 0;
    #####: 4608:			p->rule._reg = 30;
    #####: 4609:			_closure_reg(a, c + 0);
        -: 4610:		}
    #####: 4611:		break;
        -: 4612:	case 4518: /* BORU4 */
    #####: 4613:		_label(LEFT_CHILD(a));
    #####: 4614:		_label(RIGHT_CHILD(a));
        -: 4615:		/* reg: BORU4(reg,mrc) */
    #####: 4616:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_mrc_NT] + 1;
    #####: 4617:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 4618:			p->cost[_reg_NT] = c + 0;
    #####: 4619:			p->rule._reg = 33;
    #####: 4620:			_closure_reg(a, c + 0);
        -: 4621:		}
    #####: 4622:		break;
        -: 4623:	case 4533: /* BXORI4 */
    #####: 4624:		_label(LEFT_CHILD(a));
    #####: 4625:		_label(RIGHT_CHILD(a));
        -: 4626:		/* reg: BXORI4(reg,mrc) */
    #####: 4627:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_mrc_NT] + 1;
    #####: 4628:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 4629:			p->cost[_reg_NT] = c + 0;
    #####: 4630:			p->rule._reg = 31;
    #####: 4631:			_closure_reg(a, c + 0);
        -: 4632:		}
    #####: 4633:		break;
        -: 4634:	case 4534: /* BXORU4 */
    #####: 4635:		_label(LEFT_CHILD(a));
    #####: 4636:		_label(RIGHT_CHILD(a));
        -: 4637:		/* reg: BXORU4(reg,mrc) */
    #####: 4638:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_mrc_NT] + 1;
    #####: 4639:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 4640:			p->cost[_reg_NT] = c + 0;
    #####: 4641:			p->rule._reg = 34;
    #####: 4642:			_closure_reg(a, c + 0);
        -: 4643:		}
    #####: 4644:		break;
        -: 4645:	case 4545: /* DIVF4 */
    #####: 4646:		_label(LEFT_CHILD(a));
    #####: 4647:		_label(RIGHT_CHILD(a));
        -: 4648:		/* freg: DIVF4(freg,flt) */
    #####: 4649:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_freg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_flt_NT] + 0;
    #####: 4650:		if (c + 0 < p->cost[_freg_NT]) {
    #####: 4651:			p->cost[_freg_NT] = c + 0;
    #####: 4652:			p->rule._freg = 8;
    #####: 4653:			_closure_freg(a, c + 0);
        -: 4654:		}
    #####: 4655:		break;
        -: 4656:	case 4549: /* DIVI4 */
    #####: 4657:		_label(LEFT_CHILD(a));
    #####: 4658:		_label(RIGHT_CHILD(a));
        -: 4659:		/* reg: DIVI4(reg,reg) */
    #####: 4660:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
    #####: 4661:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 4662:			p->cost[_reg_NT] = c + 0;
    #####: 4663:			p->rule._reg = 47;
    #####: 4664:			_closure_reg(a, c + 0);
        -: 4665:		}
    #####: 4666:		break;
        -: 4667:	case 4550: /* DIVU4 */
    #####: 4668:		_label(LEFT_CHILD(a));
    #####: 4669:		_label(RIGHT_CHILD(a));
        -: 4670:		/* reg: DIVU4(reg,reg) */
    #####: 4671:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
    #####: 4672:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 4673:			p->cost[_reg_NT] = c + 0;
    #####: 4674:			p->rule._reg = 45;
    #####: 4675:			_closure_reg(a, c + 0);
        -: 4676:		}
    #####: 4677:		break;
        -: 4678:	case 4561: /* MULF4 */
    #####: 4679:		_label(LEFT_CHILD(a));
    #####: 4680:		_label(RIGHT_CHILD(a));
        -: 4681:		/* freg: MULF4(freg,flt) */
    #####: 4682:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_freg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_flt_NT] + 0;
    #####: 4683:		if (c + 0 < p->cost[_freg_NT]) {
    #####: 4684:			p->cost[_freg_NT] = c + 0;
    #####: 4685:			p->rule._freg = 10;
    #####: 4686:			_closure_freg(a, c + 0);
        -: 4687:		}
    #####: 4688:		break;
        -: 4689:	case 4565: /* MULI4 */
    #####: 4690:		_label(LEFT_CHILD(a));
    #####: 4691:		_label(RIGHT_CHILD(a));
        -: 4692:		/* reg: MULI4(reg,mrc) */
    #####: 4693:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_mrc_NT] + 14;
    #####: 4694:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 4695:			p->cost[_reg_NT] = c + 0;
    #####: 4696:			p->rule._reg = 42;
    #####: 4697:			_closure_reg(a, c + 0);
        -: 4698:		}
        -: 4699:		/* reg: MULI4(con,mr) */
    #####: 4700:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_con_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_mr_NT] + 13;
    #####: 4701:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 4702:			p->cost[_reg_NT] = c + 0;
    #####: 4703:			p->rule._reg = 43;
    #####: 4704:			_closure_reg(a, c + 0);
        -: 4705:		}
    #####: 4706:		break;
        -: 4707:	case 4566: /* MULU4 */
    #####: 4708:		_label(LEFT_CHILD(a));
    #####: 4709:		_label(RIGHT_CHILD(a));
        -: 4710:		/* reg: MULU4(reg,mr) */
    #####: 4711:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_mr_NT] + 13;
    #####: 4712:		if (c + 0 < p->cost[_reg_NT]) {
    #####: 4713:			p->cost[_reg_NT] = c + 0;
    #####: 4714:			p->rule._reg = 44;
    #####: 4715:			_closure_reg(a, c + 0);
        -: 4716:		}
    #####: 4717:		break;
        -: 4718:	case 4577: /* EQF4 */
    #####: 4719:		_label(LEFT_CHILD(a));
    #####: 4720:		_label(RIGHT_CHILD(a));
        -: 4721:		/* stmt: EQF4(cmpf,freg) */
    #####: 4722:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_cmpf_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_freg_NT] + 0;
    #####: 4723:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 4724:			p->cost[_stmt_NT] = c + 0;
    #####: 4725:			p->rule._stmt = 93;
        -: 4726:		}
    #####: 4727:		break;
        -: 4728:	case 4581: /* EQI4 */
    #####: 4729:		_label(LEFT_CHILD(a));
    #####: 4730:		_label(RIGHT_CHILD(a));
        -: 4731:		/* stmt: EQI4(mem4,rc) */
    #####: 4732:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_mem4_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_rc_NT] + 5;
    #####: 4733:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 4734:			p->cost[_stmt_NT] = c + 0;
    #####: 4735:			p->rule._stmt = 58;
        -: 4736:		}
        -: 4737:		/* stmt: EQI4(reg,mrc) */
    #####: 4738:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_mrc_NT] + 4;
    #####: 4739:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 4740:			p->cost[_stmt_NT] = c + 0;
    #####: 4741:			p->rule._stmt = 68;
        -: 4742:		}
    #####: 4743:		if (	/* stmt: EQI4(BANDU4(mr,con),con0) */
        -: 4744:			LEFT_CHILD(a)->op == 4486 /* BANDU4 */
        -: 4745:		) {
    #####: 4746:			c = ((struct _state *)(LEFT_CHILD(LEFT_CHILD(a))->x.state))->cost[_mr_NT] + ((struct _state *)(RIGHT_CHILD(LEFT_CHILD(a))->x.state))->cost[_con_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_con0_NT] + 3;
    #####: 4747:			if (c + 0 < p->cost[_stmt_NT]) {
    #####: 4748:				p->cost[_stmt_NT] = c + 0;
    #####: 4749:				p->rule._stmt = 80;
        -: 4750:			}
        -: 4751:		}
    #####: 4752:		if (	/* stmt: EQI4(BANDU4(CVII2(INDIRI2(addr)),con),con0) */
        -: 4753:			LEFT_CHILD(a)->op == 4486 && /* BANDU4 */
        -: 4754:			LEFT_CHILD(LEFT_CHILD(a))->op == 2181 && /* CVII2 */
        -: 4755:			LEFT_CHILD(LEFT_CHILD(LEFT_CHILD(a)))->op == 2117 /* INDIRI2 */
        -: 4756:		) {
    #####: 4757:			c = ((struct _state *)(LEFT_CHILD(LEFT_CHILD(LEFT_CHILD(LEFT_CHILD(a))))->x.state))->cost[_addr_NT] + ((struct _state *)(RIGHT_CHILD(LEFT_CHILD(a))->x.state))->cost[_con_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_con0_NT] + 0;
    #####: 4758:			if (c + 0 < p->cost[_stmt_NT]) {
    #####: 4759:				p->cost[_stmt_NT] = c + 0;
    #####: 4760:				p->rule._stmt = 82;
        -: 4761:			}
        -: 4762:		}
    #####: 4763:		if (	/* stmt: EQI4(BANDU4(CVIU2(INDIRI2(addr)),con),con0) */
        -: 4764:			LEFT_CHILD(a)->op == 4486 && /* BANDU4 */
        -: 4765:			LEFT_CHILD(LEFT_CHILD(a))->op == 2182 && /* CVIU2 */
        -: 4766:			LEFT_CHILD(LEFT_CHILD(LEFT_CHILD(a)))->op == 2117 /* INDIRI2 */
        -: 4767:		) {
    #####: 4768:			c = ((struct _state *)(LEFT_CHILD(LEFT_CHILD(LEFT_CHILD(LEFT_CHILD(a))))->x.state))->cost[_addr_NT] + ((struct _state *)(RIGHT_CHILD(LEFT_CHILD(a))->x.state))->cost[_con_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_con0_NT] + 0;
    #####: 4769:			if (c + 0 < p->cost[_stmt_NT]) {
    #####: 4770:				p->cost[_stmt_NT] = c + 0;
    #####: 4771:				p->rule._stmt = 84;
        -: 4772:			}
        -: 4773:		}
    #####: 4774:		if (	/* stmt: EQI4(BANDU4(CVII1(INDIRI1(addr)),con),con0) */
        -: 4775:			LEFT_CHILD(a)->op == 4486 && /* BANDU4 */
        -: 4776:			LEFT_CHILD(LEFT_CHILD(a))->op == 1157 && /* CVII1 */
        -: 4777:			LEFT_CHILD(LEFT_CHILD(LEFT_CHILD(a)))->op == 1093 /* INDIRI1 */
        -: 4778:		) {
    #####: 4779:			c = ((struct _state *)(LEFT_CHILD(LEFT_CHILD(LEFT_CHILD(LEFT_CHILD(a))))->x.state))->cost[_addr_NT] + ((struct _state *)(RIGHT_CHILD(LEFT_CHILD(a))->x.state))->cost[_con_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_con0_NT] + 0;
    #####: 4780:			if (c + 0 < p->cost[_stmt_NT]) {
    #####: 4781:				p->cost[_stmt_NT] = c + 0;
    #####: 4782:				p->rule._stmt = 86;
        -: 4783:			}
        -: 4784:		}
    #####: 4785:		break;
        -: 4786:	case 4582: /* EQU4 */
    #####: 4787:		_label(LEFT_CHILD(a));
    #####: 4788:		_label(RIGHT_CHILD(a));
        -: 4789:		/* stmt: EQU4(reg,mrc) */
    #####: 4790:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_mrc_NT] + 4;
    #####: 4791:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 4792:			p->cost[_stmt_NT] = c + 0;
    #####: 4793:			p->rule._stmt = 74;
        -: 4794:		}
    #####: 4795:		break;
        -: 4796:	case 4593: /* GEF4 */
    #####: 4797:		_label(LEFT_CHILD(a));
    #####: 4798:		_label(RIGHT_CHILD(a));
        -: 4799:		/* stmt: GEF4(cmpf,freg) */
    #####: 4800:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_cmpf_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_freg_NT] + 0;
    #####: 4801:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 4802:			p->cost[_stmt_NT] = c + 0;
    #####: 4803:			p->rule._stmt = 94;
        -: 4804:		}
    #####: 4805:		break;
        -: 4806:	case 4597: /* GEI4 */
    #####: 4807:		_label(LEFT_CHILD(a));
    #####: 4808:		_label(RIGHT_CHILD(a));
        -: 4809:		/* stmt: GEI4(mem4,rc) */
    #####: 4810:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_mem4_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_rc_NT] + 5;
    #####: 4811:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 4812:			p->cost[_stmt_NT] = c + 0;
    #####: 4813:			p->rule._stmt = 59;
        -: 4814:		}
        -: 4815:		/* stmt: GEI4(reg,mrc) */
    #####: 4816:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_mrc_NT] + 4;
    #####: 4817:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 4818:			p->cost[_stmt_NT] = c + 0;
    #####: 4819:			p->rule._stmt = 69;
        -: 4820:		}
    #####: 4821:		break;
        -: 4822:	case 4598: /* GEU4 */
    #####: 4823:		_label(LEFT_CHILD(a));
    #####: 4824:		_label(RIGHT_CHILD(a));
        -: 4825:		/* stmt: GEU4(mem4,rc) */
    #####: 4826:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_mem4_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_rc_NT] + 5;
    #####: 4827:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 4828:			p->cost[_stmt_NT] = c + 0;
    #####: 4829:			p->rule._stmt = 64;
        -: 4830:		}
        -: 4831:		/* stmt: GEU4(reg,mrc) */
    #####: 4832:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_mrc_NT] + 4;
    #####: 4833:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 4834:			p->cost[_stmt_NT] = c + 0;
    #####: 4835:			p->rule._stmt = 75;
        -: 4836:		}
    #####: 4837:		break;
        -: 4838:	case 4609: /* GTF4 */
    #####: 4839:		_label(LEFT_CHILD(a));
    #####: 4840:		_label(RIGHT_CHILD(a));
        -: 4841:		/* stmt: GTF4(cmpf,freg) */
    #####: 4842:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_cmpf_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_freg_NT] + 0;
    #####: 4843:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 4844:			p->cost[_stmt_NT] = c + 0;
    #####: 4845:			p->rule._stmt = 95;
        -: 4846:		}
    #####: 4847:		break;
        -: 4848:	case 4613: /* GTI4 */
    #####: 4849:		_label(LEFT_CHILD(a));
    #####: 4850:		_label(RIGHT_CHILD(a));
        -: 4851:		/* stmt: GTI4(mem4,rc) */
    #####: 4852:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_mem4_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_rc_NT] + 5;
    #####: 4853:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 4854:			p->cost[_stmt_NT] = c + 0;
    #####: 4855:			p->rule._stmt = 60;
        -: 4856:		}
        -: 4857:		/* stmt: GTI4(reg,mrc) */
    #####: 4858:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_mrc_NT] + 4;
    #####: 4859:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 4860:			p->cost[_stmt_NT] = c + 0;
    #####: 4861:			p->rule._stmt = 70;
        -: 4862:		}
    #####: 4863:		break;
        -: 4864:	case 4614: /* GTU4 */
    #####: 4865:		_label(LEFT_CHILD(a));
    #####: 4866:		_label(RIGHT_CHILD(a));
        -: 4867:		/* stmt: GTU4(mem4,rc) */
    #####: 4868:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_mem4_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_rc_NT] + 5;
    #####: 4869:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 4870:			p->cost[_stmt_NT] = c + 0;
    #####: 4871:			p->rule._stmt = 65;
        -: 4872:		}
        -: 4873:		/* stmt: GTU4(reg,mrc) */
    #####: 4874:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_mrc_NT] + 4;
    #####: 4875:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 4876:			p->cost[_stmt_NT] = c + 0;
    #####: 4877:			p->rule._stmt = 76;
        -: 4878:		}
    #####: 4879:		break;
        -: 4880:	case 4625: /* LEF4 */
    #####: 4881:		_label(LEFT_CHILD(a));
    #####: 4882:		_label(RIGHT_CHILD(a));
        -: 4883:		/* stmt: LEF4(cmpf,freg) */
    #####: 4884:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_cmpf_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_freg_NT] + 0;
    #####: 4885:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 4886:			p->cost[_stmt_NT] = c + 0;
    #####: 4887:			p->rule._stmt = 96;
        -: 4888:		}
    #####: 4889:		break;
        -: 4890:	case 4629: /* LEI4 */
    #####: 4891:		_label(LEFT_CHILD(a));
    #####: 4892:		_label(RIGHT_CHILD(a));
        -: 4893:		/* stmt: LEI4(mem4,rc) */
    #####: 4894:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_mem4_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_rc_NT] + 5;
    #####: 4895:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 4896:			p->cost[_stmt_NT] = c + 0;
    #####: 4897:			p->rule._stmt = 61;
        -: 4898:		}
        -: 4899:		/* stmt: LEI4(reg,mrc) */
    #####: 4900:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_mrc_NT] + 4;
    #####: 4901:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 4902:			p->cost[_stmt_NT] = c + 0;
    #####: 4903:			p->rule._stmt = 71;
        -: 4904:		}
    #####: 4905:		break;
        -: 4906:	case 4630: /* LEU4 */
    #####: 4907:		_label(LEFT_CHILD(a));
    #####: 4908:		_label(RIGHT_CHILD(a));
        -: 4909:		/* stmt: LEU4(mem4,rc) */
    #####: 4910:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_mem4_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_rc_NT] + 5;
    #####: 4911:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 4912:			p->cost[_stmt_NT] = c + 0;
    #####: 4913:			p->rule._stmt = 66;
        -: 4914:		}
        -: 4915:		/* stmt: LEU4(reg,mrc) */
    #####: 4916:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_mrc_NT] + 4;
    #####: 4917:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 4918:			p->cost[_stmt_NT] = c + 0;
    #####: 4919:			p->rule._stmt = 77;
        -: 4920:		}
    #####: 4921:		break;
        -: 4922:	case 4641: /* LTF4 */
    #####: 4923:		_label(LEFT_CHILD(a));
    #####: 4924:		_label(RIGHT_CHILD(a));
        -: 4925:		/* stmt: LTF4(cmpf,freg) */
    #####: 4926:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_cmpf_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_freg_NT] + 0;
    #####: 4927:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 4928:			p->cost[_stmt_NT] = c + 0;
    #####: 4929:			p->rule._stmt = 97;
        -: 4930:		}
    #####: 4931:		break;
        -: 4932:	case 4645: /* LTI4 */
    #####: 4933:		_label(LEFT_CHILD(a));
    #####: 4934:		_label(RIGHT_CHILD(a));
        -: 4935:		/* stmt: LTI4(mem4,rc) */
    #####: 4936:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_mem4_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_rc_NT] + 5;
    #####: 4937:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 4938:			p->cost[_stmt_NT] = c + 0;
    #####: 4939:			p->rule._stmt = 62;
        -: 4940:		}
        -: 4941:		/* stmt: LTI4(reg,mrc) */
    #####: 4942:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_mrc_NT] + 4;
    #####: 4943:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 4944:			p->cost[_stmt_NT] = c + 0;
    #####: 4945:			p->rule._stmt = 72;
        -: 4946:		}
    #####: 4947:		break;
        -: 4948:	case 4646: /* LTU4 */
    #####: 4949:		_label(LEFT_CHILD(a));
    #####: 4950:		_label(RIGHT_CHILD(a));
        -: 4951:		/* stmt: LTU4(mem4,rc) */
    #####: 4952:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_mem4_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_rc_NT] + 5;
    #####: 4953:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 4954:			p->cost[_stmt_NT] = c + 0;
    #####: 4955:			p->rule._stmt = 67;
        -: 4956:		}
        -: 4957:		/* stmt: LTU4(reg,mrc) */
    #####: 4958:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_mrc_NT] + 4;
    #####: 4959:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 4960:			p->cost[_stmt_NT] = c + 0;
    #####: 4961:			p->rule._stmt = 78;
        -: 4962:		}
    #####: 4963:		break;
        -: 4964:	case 4657: /* NEF4 */
    #####: 4965:		_label(LEFT_CHILD(a));
    #####: 4966:		_label(RIGHT_CHILD(a));
        -: 4967:		/* stmt: NEF4(cmpf,freg) */
    #####: 4968:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_cmpf_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_freg_NT] + 0;
    #####: 4969:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 4970:			p->cost[_stmt_NT] = c + 0;
    #####: 4971:			p->rule._stmt = 98;
        -: 4972:		}
    #####: 4973:		break;
        -: 4974:	case 4661: /* NEI4 */
    #####: 4975:		_label(LEFT_CHILD(a));
    #####: 4976:		_label(RIGHT_CHILD(a));
        -: 4977:		/* stmt: NEI4(mem4,rc) */
    #####: 4978:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_mem4_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_rc_NT] + 5;
    #####: 4979:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 4980:			p->cost[_stmt_NT] = c + 0;
    #####: 4981:			p->rule._stmt = 63;
        -: 4982:		}
        -: 4983:		/* stmt: NEI4(reg,mrc) */
    #####: 4984:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_mrc_NT] + 4;
    #####: 4985:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 4986:			p->cost[_stmt_NT] = c + 0;
    #####: 4987:			p->rule._stmt = 73;
        -: 4988:		}
    #####: 4989:		if (	/* stmt: NEI4(BANDU4(mr,con),con0) */
        -: 4990:			LEFT_CHILD(a)->op == 4486 /* BANDU4 */
        -: 4991:		) {
    #####: 4992:			c = ((struct _state *)(LEFT_CHILD(LEFT_CHILD(a))->x.state))->cost[_mr_NT] + ((struct _state *)(RIGHT_CHILD(LEFT_CHILD(a))->x.state))->cost[_con_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_con0_NT] + 0;
    #####: 4993:			if (c + 0 < p->cost[_stmt_NT]) {
    #####: 4994:				p->cost[_stmt_NT] = c + 0;
    #####: 4995:				p->rule._stmt = 81;
        -: 4996:			}
        -: 4997:		}
    #####: 4998:		if (	/* stmt: NEI4(BANDU4(CVII2(INDIRI2(addr)),con),con0) */
        -: 4999:			LEFT_CHILD(a)->op == 4486 && /* BANDU4 */
        -: 5000:			LEFT_CHILD(LEFT_CHILD(a))->op == 2181 && /* CVII2 */
        -: 5001:			LEFT_CHILD(LEFT_CHILD(LEFT_CHILD(a)))->op == 2117 /* INDIRI2 */
        -: 5002:		) {
    #####: 5003:			c = ((struct _state *)(LEFT_CHILD(LEFT_CHILD(LEFT_CHILD(LEFT_CHILD(a))))->x.state))->cost[_addr_NT] + ((struct _state *)(RIGHT_CHILD(LEFT_CHILD(a))->x.state))->cost[_con_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_con0_NT] + 0;
    #####: 5004:			if (c + 0 < p->cost[_stmt_NT]) {
    #####: 5005:				p->cost[_stmt_NT] = c + 0;
    #####: 5006:				p->rule._stmt = 83;
        -: 5007:			}
        -: 5008:		}
    #####: 5009:		if (	/* stmt: NEI4(BANDU4(CVIU2(INDIRI2(addr)),con),con0) */
        -: 5010:			LEFT_CHILD(a)->op == 4486 && /* BANDU4 */
        -: 5011:			LEFT_CHILD(LEFT_CHILD(a))->op == 2182 && /* CVIU2 */
        -: 5012:			LEFT_CHILD(LEFT_CHILD(LEFT_CHILD(a)))->op == 2117 /* INDIRI2 */
        -: 5013:		) {
    #####: 5014:			c = ((struct _state *)(LEFT_CHILD(LEFT_CHILD(LEFT_CHILD(LEFT_CHILD(a))))->x.state))->cost[_addr_NT] + ((struct _state *)(RIGHT_CHILD(LEFT_CHILD(a))->x.state))->cost[_con_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_con0_NT] + 0;
    #####: 5015:			if (c + 0 < p->cost[_stmt_NT]) {
    #####: 5016:				p->cost[_stmt_NT] = c + 0;
    #####: 5017:				p->rule._stmt = 85;
        -: 5018:			}
        -: 5019:		}
    #####: 5020:		break;
        -: 5021:	case 4662: /* NEU4 */
    #####: 5022:		_label(LEFT_CHILD(a));
    #####: 5023:		_label(RIGHT_CHILD(a));
        -: 5024:		/* stmt: NEU4(reg,mrc) */
    #####: 5025:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_mrc_NT] + 4;
    #####: 5026:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 5027:			p->cost[_stmt_NT] = c + 0;
    #####: 5028:			p->rule._stmt = 79;
        -: 5029:		}
    #####: 5030:		break;
        -: 5031:	case 8209: /* CNSTF8 */
    #####: 5032:		break;
        -: 5033:	case 8213: /* CNSTI8 */
        -: 5034:		/* cnst: CNSTI8 */
    #####: 5035:		if (0 + 0 < p->cost[_cnst_NT]) {
    #####: 5036:			p->cost[_cnst_NT] = 0 + 0;
    #####: 5037:			p->rule._cnst = 8;
    #####: 5038:			_closure_cnst(a, 0 + 0);
        -: 5039:		}
    #####: 5040:		break;
        -: 5041:	case 8214: /* CNSTU8 */
        -: 5042:		/* cnst: CNSTU8 */
    #####: 5043:		if (0 + 0 < p->cost[_cnst_NT]) {
    #####: 5044:			p->cost[_cnst_NT] = 0 + 0;
    #####: 5045:			p->rule._cnst = 9;
    #####: 5046:			_closure_cnst(a, 0 + 0);
        -: 5047:		}
    #####: 5048:		break;
        -: 5049:	case 8215: /* CNSTP8 */
        -: 5050:		/* cnst: CNSTP8 */
    #####: 5051:		if (0 + 0 < p->cost[_cnst_NT]) {
    #####: 5052:			p->cost[_cnst_NT] = 0 + 0;
    #####: 5053:			p->rule._cnst = 10;
    #####: 5054:			_closure_cnst(a, 0 + 0);
        -: 5055:		}
    #####: 5056:		break;
        -: 5057:	case 8225: /* ARGF8 */
    #####: 5058:		_label(LEFT_CHILD(a));
        -: 5059:		/* stmt: ARGF8(freg) */
    #####: 5060:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_freg_NT] + 0;
    #####: 5061:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 5062:			p->cost[_stmt_NT] = c + 0;
    #####: 5063:			p->rule._stmt = 53;
        -: 5064:		}
    #####: 5065:		break;
        -: 5066:	case 8229: /* ARGI8 */
    #####: 5067:		break;
        -: 5068:	case 8230: /* ARGU8 */
    #####: 5069:		break;
        -: 5070:	case 8231: /* ARGP8 */
    #####: 5071:		break;
        -: 5072:	case 8241: /* ASGNF8 */
    #####: 5073:		_label(LEFT_CHILD(a));
    #####: 5074:		_label(RIGHT_CHILD(a));
    #####: 5075:		if (	/* stmt: ASGNF8(VREGP,reg) */
        -: 5076:			LEFT_CHILD(a)->op == 711 /* VREGP */
        -: 5077:		) {
    #####: 5078:			c = ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
    #####: 5079:			if (c + 0 < p->cost[_stmt_NT]) {
    #####: 5080:				p->cost[_stmt_NT] = c + 0;
    #####: 5081:				p->rule._stmt = 9;
        -: 5082:			}
        -: 5083:		}
        -: 5084:		/* stmt: ASGNF8(addr,freg) */
    #####: 5085:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_freg_NT] + 7;
    #####: 5086:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 5087:			p->cost[_stmt_NT] = c + 0;
    #####: 5088:			p->rule._stmt = 50;
        -: 5089:		}
    #####: 5090:		break;
        -: 5091:	case 8245: /* ASGNI8 */
    #####: 5092:		_label(LEFT_CHILD(a));
    #####: 5093:		_label(RIGHT_CHILD(a));
    #####: 5094:		if (	/* stmt: ASGNI8(VREGP,reg) */
        -: 5095:			LEFT_CHILD(a)->op == 711 /* VREGP */
        -: 5096:		) {
    #####: 5097:			c = ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
    #####: 5098:			if (c + 0 < p->cost[_stmt_NT]) {
    #####: 5099:				p->cost[_stmt_NT] = c + 0;
    #####: 5100:				p->rule._stmt = 10;
        -: 5101:			}
        -: 5102:		}
    #####: 5103:		break;
        -: 5104:	case 8246: /* ASGNU8 */
    #####: 5105:		_label(LEFT_CHILD(a));
    #####: 5106:		_label(RIGHT_CHILD(a));
    #####: 5107:		if (	/* stmt: ASGNU8(VREGP,reg) */
        -: 5108:			LEFT_CHILD(a)->op == 711 /* VREGP */
        -: 5109:		) {
    #####: 5110:			c = ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
    #####: 5111:			if (c + 0 < p->cost[_stmt_NT]) {
    #####: 5112:				p->cost[_stmt_NT] = c + 0;
    #####: 5113:				p->rule._stmt = 12;
        -: 5114:			}
        -: 5115:		}
    #####: 5116:		break;
        -: 5117:	case 8247: /* ASGNP8 */
    #####: 5118:		_label(LEFT_CHILD(a));
    #####: 5119:		_label(RIGHT_CHILD(a));
    #####: 5120:		if (	/* stmt: ASGNP8(VREGP,reg) */
        -: 5121:			LEFT_CHILD(a)->op == 711 /* VREGP */
        -: 5122:		) {
    #####: 5123:			c = ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
    #####: 5124:			if (c + 0 < p->cost[_stmt_NT]) {
    #####: 5125:				p->cost[_stmt_NT] = c + 0;
    #####: 5126:				p->rule._stmt = 11;
        -: 5127:			}
        -: 5128:		}
    #####: 5129:		break;
        -: 5130:	case 8257: /* INDIRF8 */
    #####: 5131:		_label(LEFT_CHILD(a));
    #####: 5132:		if (	/* freg: INDIRF8(VREGP) */
        -: 5133:			LEFT_CHILD(a)->op == 711 /* VREGP */
        -: 5134:		) {
    #####: 5135:			if (mayrecalc(a)) {
    #####: 5136:				struct _state *q = a->syms[RX]->u.t.cse->x.state;
    #####: 5137:				if (q->cost[_stmt_NT] == 0) {
    #####: 5138:					p->cost[_stmt_NT] = 0;
    #####: 5139:					p->rule._stmt = q->rule._stmt;
        -: 5140:				}
    #####: 5141:				if (q->cost[_reg_NT] == 0) {
    #####: 5142:					p->cost[_reg_NT] = 0;
    #####: 5143:					p->rule._reg = q->rule._reg;
        -: 5144:				}
    #####: 5145:				if (q->cost[_freg_NT] == 0) {
    #####: 5146:					p->cost[_freg_NT] = 0;
    #####: 5147:					p->rule._freg = q->rule._freg;
        -: 5148:				}
    #####: 5149:				if (q->cost[_cnst_NT] == 0) {
    #####: 5150:					p->cost[_cnst_NT] = 0;
    #####: 5151:					p->rule._cnst = q->rule._cnst;
        -: 5152:				}
    #####: 5153:				if (q->cost[_con_NT] == 0) {
    #####: 5154:					p->cost[_con_NT] = 0;
    #####: 5155:					p->rule._con = q->rule._con;
        -: 5156:				}
    #####: 5157:				if (q->cost[_acon_NT] == 0) {
    #####: 5158:					p->cost[_acon_NT] = 0;
    #####: 5159:					p->rule._acon = q->rule._acon;
        -: 5160:				}
    #####: 5161:				if (q->cost[_baseaddr_NT] == 0) {
    #####: 5162:					p->cost[_baseaddr_NT] = 0;
    #####: 5163:					p->rule._baseaddr = q->rule._baseaddr;
        -: 5164:				}
    #####: 5165:				if (q->cost[_base_NT] == 0) {
    #####: 5166:					p->cost[_base_NT] = 0;
    #####: 5167:					p->rule._base = q->rule._base;
        -: 5168:				}
    #####: 5169:				if (q->cost[_index_NT] == 0) {
    #####: 5170:					p->cost[_index_NT] = 0;
    #####: 5171:					p->rule._index = q->rule._index;
        -: 5172:				}
    #####: 5173:				if (q->cost[_con1_NT] == 0) {
    #####: 5174:					p->cost[_con1_NT] = 0;
    #####: 5175:					p->rule._con1 = q->rule._con1;
        -: 5176:				}
    #####: 5177:				if (q->cost[_con2_NT] == 0) {
    #####: 5178:					p->cost[_con2_NT] = 0;
    #####: 5179:					p->rule._con2 = q->rule._con2;
        -: 5180:				}
    #####: 5181:				if (q->cost[_con3_NT] == 0) {
    #####: 5182:					p->cost[_con3_NT] = 0;
    #####: 5183:					p->rule._con3 = q->rule._con3;
        -: 5184:				}
    #####: 5185:				if (q->cost[_con0_NT] == 0) {
    #####: 5186:					p->cost[_con0_NT] = 0;
    #####: 5187:					p->rule._con0 = q->rule._con0;
        -: 5188:				}
    #####: 5189:				if (q->cost[_addr_NT] == 0) {
    #####: 5190:					p->cost[_addr_NT] = 0;
    #####: 5191:					p->rule._addr = q->rule._addr;
        -: 5192:				}
    #####: 5193:				if (q->cost[_mem1_NT] == 0) {
    #####: 5194:					p->cost[_mem1_NT] = 0;
    #####: 5195:					p->rule._mem1 = q->rule._mem1;
        -: 5196:				}
    #####: 5197:				if (q->cost[_mem2_NT] == 0) {
    #####: 5198:					p->cost[_mem2_NT] = 0;
    #####: 5199:					p->rule._mem2 = q->rule._mem2;
        -: 5200:				}
    #####: 5201:				if (q->cost[_mem4_NT] == 0) {
    #####: 5202:					p->cost[_mem4_NT] = 0;
    #####: 5203:					p->rule._mem4 = q->rule._mem4;
        -: 5204:				}
    #####: 5205:				if (q->cost[_rc_NT] == 0) {
    #####: 5206:					p->cost[_rc_NT] = 0;
    #####: 5207:					p->rule._rc = q->rule._rc;
        -: 5208:				}
    #####: 5209:				if (q->cost[_mr_NT] == 0) {
    #####: 5210:					p->cost[_mr_NT] = 0;
    #####: 5211:					p->rule._mr = q->rule._mr;
        -: 5212:				}
    #####: 5213:				if (q->cost[_mr1_NT] == 0) {
    #####: 5214:					p->cost[_mr1_NT] = 0;
    #####: 5215:					p->rule._mr1 = q->rule._mr1;
        -: 5216:				}
    #####: 5217:				if (q->cost[_mr2_NT] == 0) {
    #####: 5218:					p->cost[_mr2_NT] = 0;
    #####: 5219:					p->rule._mr2 = q->rule._mr2;
        -: 5220:				}
    #####: 5221:				if (q->cost[_mrc_NT] == 0) {
    #####: 5222:					p->cost[_mrc_NT] = 0;
    #####: 5223:					p->rule._mrc = q->rule._mrc;
        -: 5224:				}
    #####: 5225:				if (q->cost[_rc5_NT] == 0) {
    #####: 5226:					p->cost[_rc5_NT] = 0;
    #####: 5227:					p->rule._rc5 = q->rule._rc5;
        -: 5228:				}
    #####: 5229:				if (q->cost[_mrca_NT] == 0) {
    #####: 5230:					p->cost[_mrca_NT] = 0;
    #####: 5231:					p->rule._mrca = q->rule._mrca;
        -: 5232:				}
    #####: 5233:				if (q->cost[_memf_NT] == 0) {
    #####: 5234:					p->cost[_memf_NT] = 0;
    #####: 5235:					p->rule._memf = q->rule._memf;
        -: 5236:				}
    #####: 5237:				if (q->cost[_flt_NT] == 0) {
    #####: 5238:					p->cost[_flt_NT] = 0;
    #####: 5239:					p->rule._flt = q->rule._flt;
        -: 5240:				}
    #####: 5241:				if (q->cost[_addrj_NT] == 0) {
    #####: 5242:					p->cost[_addrj_NT] = 0;
    #####: 5243:					p->rule._addrj = q->rule._addrj;
        -: 5244:				}
    #####: 5245:				if (q->cost[_cmpf_NT] == 0) {
    #####: 5246:					p->cost[_cmpf_NT] = 0;
    #####: 5247:					p->rule._cmpf = q->rule._cmpf;
        -: 5248:				}
        -: 5249:			}
    #####: 5250:			c = 0;
    #####: 5251:			if (c + 0 < p->cost[_freg_NT]) {
    #####: 5252:				p->cost[_freg_NT] = c + 0;
    #####: 5253:				p->rule._freg = 2;
    #####: 5254:				_closure_freg(a, c + 0);
        -: 5255:			}
        -: 5256:		}
        -: 5257:		/* memf: INDIRF8(addr) */
    #####: 5258:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + 0;
    #####: 5259:		if (c + 0 < p->cost[_memf_NT]) {
    #####: 5260:			p->cost[_memf_NT] = c + 0;
    #####: 5261:			p->rule._memf = 1;
    #####: 5262:			_closure_memf(a, c + 0);
        -: 5263:		}
        -: 5264:		/* cmpf: INDIRF8(addr) */
    #####: 5265:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + 0;
    #####: 5266:		if (c + 0 < p->cost[_cmpf_NT]) {
    #####: 5267:			p->cost[_cmpf_NT] = c + 0;
    #####: 5268:			p->rule._cmpf = 1;
        -: 5269:		}
    #####: 5270:		break;
        -: 5271:	case 8261: /* INDIRI8 */
    #####: 5272:		_label(LEFT_CHILD(a));
    #####: 5273:		if (	/* reg: INDIRI8(VREGP) */
        -: 5274:			LEFT_CHILD(a)->op == 711 /* VREGP */
        -: 5275:		) {
    #####: 5276:			if (mayrecalc(a)) {
    #####: 5277:				struct _state *q = a->syms[RX]->u.t.cse->x.state;
    #####: 5278:				if (q->cost[_stmt_NT] == 0) {
    #####: 5279:					p->cost[_stmt_NT] = 0;
    #####: 5280:					p->rule._stmt = q->rule._stmt;
        -: 5281:				}
    #####: 5282:				if (q->cost[_reg_NT] == 0) {
    #####: 5283:					p->cost[_reg_NT] = 0;
    #####: 5284:					p->rule._reg = q->rule._reg;
        -: 5285:				}
    #####: 5286:				if (q->cost[_freg_NT] == 0) {
    #####: 5287:					p->cost[_freg_NT] = 0;
    #####: 5288:					p->rule._freg = q->rule._freg;
        -: 5289:				}
    #####: 5290:				if (q->cost[_cnst_NT] == 0) {
    #####: 5291:					p->cost[_cnst_NT] = 0;
    #####: 5292:					p->rule._cnst = q->rule._cnst;
        -: 5293:				}
    #####: 5294:				if (q->cost[_con_NT] == 0) {
    #####: 5295:					p->cost[_con_NT] = 0;
    #####: 5296:					p->rule._con = q->rule._con;
        -: 5297:				}
    #####: 5298:				if (q->cost[_acon_NT] == 0) {
    #####: 5299:					p->cost[_acon_NT] = 0;
    #####: 5300:					p->rule._acon = q->rule._acon;
        -: 5301:				}
    #####: 5302:				if (q->cost[_baseaddr_NT] == 0) {
    #####: 5303:					p->cost[_baseaddr_NT] = 0;
    #####: 5304:					p->rule._baseaddr = q->rule._baseaddr;
        -: 5305:				}
    #####: 5306:				if (q->cost[_base_NT] == 0) {
    #####: 5307:					p->cost[_base_NT] = 0;
    #####: 5308:					p->rule._base = q->rule._base;
        -: 5309:				}
    #####: 5310:				if (q->cost[_index_NT] == 0) {
    #####: 5311:					p->cost[_index_NT] = 0;
    #####: 5312:					p->rule._index = q->rule._index;
        -: 5313:				}
    #####: 5314:				if (q->cost[_con1_NT] == 0) {
    #####: 5315:					p->cost[_con1_NT] = 0;
    #####: 5316:					p->rule._con1 = q->rule._con1;
        -: 5317:				}
    #####: 5318:				if (q->cost[_con2_NT] == 0) {
    #####: 5319:					p->cost[_con2_NT] = 0;
    #####: 5320:					p->rule._con2 = q->rule._con2;
        -: 5321:				}
    #####: 5322:				if (q->cost[_con3_NT] == 0) {
    #####: 5323:					p->cost[_con3_NT] = 0;
    #####: 5324:					p->rule._con3 = q->rule._con3;
        -: 5325:				}
    #####: 5326:				if (q->cost[_con0_NT] == 0) {
    #####: 5327:					p->cost[_con0_NT] = 0;
    #####: 5328:					p->rule._con0 = q->rule._con0;
        -: 5329:				}
    #####: 5330:				if (q->cost[_addr_NT] == 0) {
    #####: 5331:					p->cost[_addr_NT] = 0;
    #####: 5332:					p->rule._addr = q->rule._addr;
        -: 5333:				}
    #####: 5334:				if (q->cost[_mem1_NT] == 0) {
    #####: 5335:					p->cost[_mem1_NT] = 0;
    #####: 5336:					p->rule._mem1 = q->rule._mem1;
        -: 5337:				}
    #####: 5338:				if (q->cost[_mem2_NT] == 0) {
    #####: 5339:					p->cost[_mem2_NT] = 0;
    #####: 5340:					p->rule._mem2 = q->rule._mem2;
        -: 5341:				}
    #####: 5342:				if (q->cost[_mem4_NT] == 0) {
    #####: 5343:					p->cost[_mem4_NT] = 0;
    #####: 5344:					p->rule._mem4 = q->rule._mem4;
        -: 5345:				}
    #####: 5346:				if (q->cost[_rc_NT] == 0) {
    #####: 5347:					p->cost[_rc_NT] = 0;
    #####: 5348:					p->rule._rc = q->rule._rc;
        -: 5349:				}
    #####: 5350:				if (q->cost[_mr_NT] == 0) {
    #####: 5351:					p->cost[_mr_NT] = 0;
    #####: 5352:					p->rule._mr = q->rule._mr;
        -: 5353:				}
    #####: 5354:				if (q->cost[_mr1_NT] == 0) {
    #####: 5355:					p->cost[_mr1_NT] = 0;
    #####: 5356:					p->rule._mr1 = q->rule._mr1;
        -: 5357:				}
    #####: 5358:				if (q->cost[_mr2_NT] == 0) {
    #####: 5359:					p->cost[_mr2_NT] = 0;
    #####: 5360:					p->rule._mr2 = q->rule._mr2;
        -: 5361:				}
    #####: 5362:				if (q->cost[_mrc_NT] == 0) {
    #####: 5363:					p->cost[_mrc_NT] = 0;
    #####: 5364:					p->rule._mrc = q->rule._mrc;
        -: 5365:				}
    #####: 5366:				if (q->cost[_rc5_NT] == 0) {
    #####: 5367:					p->cost[_rc5_NT] = 0;
    #####: 5368:					p->rule._rc5 = q->rule._rc5;
        -: 5369:				}
    #####: 5370:				if (q->cost[_mrca_NT] == 0) {
    #####: 5371:					p->cost[_mrca_NT] = 0;
    #####: 5372:					p->rule._mrca = q->rule._mrca;
        -: 5373:				}
    #####: 5374:				if (q->cost[_memf_NT] == 0) {
    #####: 5375:					p->cost[_memf_NT] = 0;
    #####: 5376:					p->rule._memf = q->rule._memf;
        -: 5377:				}
    #####: 5378:				if (q->cost[_flt_NT] == 0) {
    #####: 5379:					p->cost[_flt_NT] = 0;
    #####: 5380:					p->rule._flt = q->rule._flt;
        -: 5381:				}
    #####: 5382:				if (q->cost[_addrj_NT] == 0) {
    #####: 5383:					p->cost[_addrj_NT] = 0;
    #####: 5384:					p->rule._addrj = q->rule._addrj;
        -: 5385:				}
    #####: 5386:				if (q->cost[_cmpf_NT] == 0) {
    #####: 5387:					p->cost[_cmpf_NT] = 0;
    #####: 5388:					p->rule._cmpf = q->rule._cmpf;
        -: 5389:				}
        -: 5390:			}
    #####: 5391:			c = 0;
    #####: 5392:			if (c + 0 < p->cost[_reg_NT]) {
    #####: 5393:				p->cost[_reg_NT] = c + 0;
    #####: 5394:				p->rule._reg = 8;
    #####: 5395:				_closure_reg(a, c + 0);
        -: 5396:			}
        -: 5397:		}
    #####: 5398:		break;
        -: 5399:	case 8262: /* INDIRU8 */
    #####: 5400:		_label(LEFT_CHILD(a));
    #####: 5401:		if (	/* reg: INDIRU8(VREGP) */
        -: 5402:			LEFT_CHILD(a)->op == 711 /* VREGP */
        -: 5403:		) {
    #####: 5404:			if (mayrecalc(a)) {
    #####: 5405:				struct _state *q = a->syms[RX]->u.t.cse->x.state;
    #####: 5406:				if (q->cost[_stmt_NT] == 0) {
    #####: 5407:					p->cost[_stmt_NT] = 0;
    #####: 5408:					p->rule._stmt = q->rule._stmt;
        -: 5409:				}
    #####: 5410:				if (q->cost[_reg_NT] == 0) {
    #####: 5411:					p->cost[_reg_NT] = 0;
    #####: 5412:					p->rule._reg = q->rule._reg;
        -: 5413:				}
    #####: 5414:				if (q->cost[_freg_NT] == 0) {
    #####: 5415:					p->cost[_freg_NT] = 0;
    #####: 5416:					p->rule._freg = q->rule._freg;
        -: 5417:				}
    #####: 5418:				if (q->cost[_cnst_NT] == 0) {
    #####: 5419:					p->cost[_cnst_NT] = 0;
    #####: 5420:					p->rule._cnst = q->rule._cnst;
        -: 5421:				}
    #####: 5422:				if (q->cost[_con_NT] == 0) {
    #####: 5423:					p->cost[_con_NT] = 0;
    #####: 5424:					p->rule._con = q->rule._con;
        -: 5425:				}
    #####: 5426:				if (q->cost[_acon_NT] == 0) {
    #####: 5427:					p->cost[_acon_NT] = 0;
    #####: 5428:					p->rule._acon = q->rule._acon;
        -: 5429:				}
    #####: 5430:				if (q->cost[_baseaddr_NT] == 0) {
    #####: 5431:					p->cost[_baseaddr_NT] = 0;
    #####: 5432:					p->rule._baseaddr = q->rule._baseaddr;
        -: 5433:				}
    #####: 5434:				if (q->cost[_base_NT] == 0) {
    #####: 5435:					p->cost[_base_NT] = 0;
    #####: 5436:					p->rule._base = q->rule._base;
        -: 5437:				}
    #####: 5438:				if (q->cost[_index_NT] == 0) {
    #####: 5439:					p->cost[_index_NT] = 0;
    #####: 5440:					p->rule._index = q->rule._index;
        -: 5441:				}
    #####: 5442:				if (q->cost[_con1_NT] == 0) {
    #####: 5443:					p->cost[_con1_NT] = 0;
    #####: 5444:					p->rule._con1 = q->rule._con1;
        -: 5445:				}
    #####: 5446:				if (q->cost[_con2_NT] == 0) {
    #####: 5447:					p->cost[_con2_NT] = 0;
    #####: 5448:					p->rule._con2 = q->rule._con2;
        -: 5449:				}
    #####: 5450:				if (q->cost[_con3_NT] == 0) {
    #####: 5451:					p->cost[_con3_NT] = 0;
    #####: 5452:					p->rule._con3 = q->rule._con3;
        -: 5453:				}
    #####: 5454:				if (q->cost[_con0_NT] == 0) {
    #####: 5455:					p->cost[_con0_NT] = 0;
    #####: 5456:					p->rule._con0 = q->rule._con0;
        -: 5457:				}
    #####: 5458:				if (q->cost[_addr_NT] == 0) {
    #####: 5459:					p->cost[_addr_NT] = 0;
    #####: 5460:					p->rule._addr = q->rule._addr;
        -: 5461:				}
    #####: 5462:				if (q->cost[_mem1_NT] == 0) {
    #####: 5463:					p->cost[_mem1_NT] = 0;
    #####: 5464:					p->rule._mem1 = q->rule._mem1;
        -: 5465:				}
    #####: 5466:				if (q->cost[_mem2_NT] == 0) {
    #####: 5467:					p->cost[_mem2_NT] = 0;
    #####: 5468:					p->rule._mem2 = q->rule._mem2;
        -: 5469:				}
    #####: 5470:				if (q->cost[_mem4_NT] == 0) {
    #####: 5471:					p->cost[_mem4_NT] = 0;
    #####: 5472:					p->rule._mem4 = q->rule._mem4;
        -: 5473:				}
    #####: 5474:				if (q->cost[_rc_NT] == 0) {
    #####: 5475:					p->cost[_rc_NT] = 0;
    #####: 5476:					p->rule._rc = q->rule._rc;
        -: 5477:				}
    #####: 5478:				if (q->cost[_mr_NT] == 0) {
    #####: 5479:					p->cost[_mr_NT] = 0;
    #####: 5480:					p->rule._mr = q->rule._mr;
        -: 5481:				}
    #####: 5482:				if (q->cost[_mr1_NT] == 0) {
    #####: 5483:					p->cost[_mr1_NT] = 0;
    #####: 5484:					p->rule._mr1 = q->rule._mr1;
        -: 5485:				}
    #####: 5486:				if (q->cost[_mr2_NT] == 0) {
    #####: 5487:					p->cost[_mr2_NT] = 0;
    #####: 5488:					p->rule._mr2 = q->rule._mr2;
        -: 5489:				}
    #####: 5490:				if (q->cost[_mrc_NT] == 0) {
    #####: 5491:					p->cost[_mrc_NT] = 0;
    #####: 5492:					p->rule._mrc = q->rule._mrc;
        -: 5493:				}
    #####: 5494:				if (q->cost[_rc5_NT] == 0) {
    #####: 5495:					p->cost[_rc5_NT] = 0;
    #####: 5496:					p->rule._rc5 = q->rule._rc5;
        -: 5497:				}
    #####: 5498:				if (q->cost[_mrca_NT] == 0) {
    #####: 5499:					p->cost[_mrca_NT] = 0;
    #####: 5500:					p->rule._mrca = q->rule._mrca;
        -: 5501:				}
    #####: 5502:				if (q->cost[_memf_NT] == 0) {
    #####: 5503:					p->cost[_memf_NT] = 0;
    #####: 5504:					p->rule._memf = q->rule._memf;
        -: 5505:				}
    #####: 5506:				if (q->cost[_flt_NT] == 0) {
    #####: 5507:					p->cost[_flt_NT] = 0;
    #####: 5508:					p->rule._flt = q->rule._flt;
        -: 5509:				}
    #####: 5510:				if (q->cost[_addrj_NT] == 0) {
    #####: 5511:					p->cost[_addrj_NT] = 0;
    #####: 5512:					p->rule._addrj = q->rule._addrj;
        -: 5513:				}
    #####: 5514:				if (q->cost[_cmpf_NT] == 0) {
    #####: 5515:					p->cost[_cmpf_NT] = 0;
    #####: 5516:					p->rule._cmpf = q->rule._cmpf;
        -: 5517:				}
        -: 5518:			}
    #####: 5519:			c = 0;
    #####: 5520:			if (c + 0 < p->cost[_reg_NT]) {
    #####: 5521:				p->cost[_reg_NT] = c + 0;
    #####: 5522:				p->rule._reg = 10;
    #####: 5523:				_closure_reg(a, c + 0);
        -: 5524:			}
        -: 5525:		}
    #####: 5526:		break;
        -: 5527:	case 8263: /* INDIRP8 */
    #####: 5528:		_label(LEFT_CHILD(a));
    #####: 5529:		if (	/* reg: INDIRP8(VREGP) */
        -: 5530:			LEFT_CHILD(a)->op == 711 /* VREGP */
        -: 5531:		) {
    #####: 5532:			if (mayrecalc(a)) {
    #####: 5533:				struct _state *q = a->syms[RX]->u.t.cse->x.state;
    #####: 5534:				if (q->cost[_stmt_NT] == 0) {
    #####: 5535:					p->cost[_stmt_NT] = 0;
    #####: 5536:					p->rule._stmt = q->rule._stmt;
        -: 5537:				}
    #####: 5538:				if (q->cost[_reg_NT] == 0) {
    #####: 5539:					p->cost[_reg_NT] = 0;
    #####: 5540:					p->rule._reg = q->rule._reg;
        -: 5541:				}
    #####: 5542:				if (q->cost[_freg_NT] == 0) {
    #####: 5543:					p->cost[_freg_NT] = 0;
    #####: 5544:					p->rule._freg = q->rule._freg;
        -: 5545:				}
    #####: 5546:				if (q->cost[_cnst_NT] == 0) {
    #####: 5547:					p->cost[_cnst_NT] = 0;
    #####: 5548:					p->rule._cnst = q->rule._cnst;
        -: 5549:				}
    #####: 5550:				if (q->cost[_con_NT] == 0) {
    #####: 5551:					p->cost[_con_NT] = 0;
    #####: 5552:					p->rule._con = q->rule._con;
        -: 5553:				}
    #####: 5554:				if (q->cost[_acon_NT] == 0) {
    #####: 5555:					p->cost[_acon_NT] = 0;
    #####: 5556:					p->rule._acon = q->rule._acon;
        -: 5557:				}
    #####: 5558:				if (q->cost[_baseaddr_NT] == 0) {
    #####: 5559:					p->cost[_baseaddr_NT] = 0;
    #####: 5560:					p->rule._baseaddr = q->rule._baseaddr;
        -: 5561:				}
    #####: 5562:				if (q->cost[_base_NT] == 0) {
    #####: 5563:					p->cost[_base_NT] = 0;
    #####: 5564:					p->rule._base = q->rule._base;
        -: 5565:				}
    #####: 5566:				if (q->cost[_index_NT] == 0) {
    #####: 5567:					p->cost[_index_NT] = 0;
    #####: 5568:					p->rule._index = q->rule._index;
        -: 5569:				}
    #####: 5570:				if (q->cost[_con1_NT] == 0) {
    #####: 5571:					p->cost[_con1_NT] = 0;
    #####: 5572:					p->rule._con1 = q->rule._con1;
        -: 5573:				}
    #####: 5574:				if (q->cost[_con2_NT] == 0) {
    #####: 5575:					p->cost[_con2_NT] = 0;
    #####: 5576:					p->rule._con2 = q->rule._con2;
        -: 5577:				}
    #####: 5578:				if (q->cost[_con3_NT] == 0) {
    #####: 5579:					p->cost[_con3_NT] = 0;
    #####: 5580:					p->rule._con3 = q->rule._con3;
        -: 5581:				}
    #####: 5582:				if (q->cost[_con0_NT] == 0) {
    #####: 5583:					p->cost[_con0_NT] = 0;
    #####: 5584:					p->rule._con0 = q->rule._con0;
        -: 5585:				}
    #####: 5586:				if (q->cost[_addr_NT] == 0) {
    #####: 5587:					p->cost[_addr_NT] = 0;
    #####: 5588:					p->rule._addr = q->rule._addr;
        -: 5589:				}
    #####: 5590:				if (q->cost[_mem1_NT] == 0) {
    #####: 5591:					p->cost[_mem1_NT] = 0;
    #####: 5592:					p->rule._mem1 = q->rule._mem1;
        -: 5593:				}
    #####: 5594:				if (q->cost[_mem2_NT] == 0) {
    #####: 5595:					p->cost[_mem2_NT] = 0;
    #####: 5596:					p->rule._mem2 = q->rule._mem2;
        -: 5597:				}
    #####: 5598:				if (q->cost[_mem4_NT] == 0) {
    #####: 5599:					p->cost[_mem4_NT] = 0;
    #####: 5600:					p->rule._mem4 = q->rule._mem4;
        -: 5601:				}
    #####: 5602:				if (q->cost[_rc_NT] == 0) {
    #####: 5603:					p->cost[_rc_NT] = 0;
    #####: 5604:					p->rule._rc = q->rule._rc;
        -: 5605:				}
    #####: 5606:				if (q->cost[_mr_NT] == 0) {
    #####: 5607:					p->cost[_mr_NT] = 0;
    #####: 5608:					p->rule._mr = q->rule._mr;
        -: 5609:				}
    #####: 5610:				if (q->cost[_mr1_NT] == 0) {
    #####: 5611:					p->cost[_mr1_NT] = 0;
    #####: 5612:					p->rule._mr1 = q->rule._mr1;
        -: 5613:				}
    #####: 5614:				if (q->cost[_mr2_NT] == 0) {
    #####: 5615:					p->cost[_mr2_NT] = 0;
    #####: 5616:					p->rule._mr2 = q->rule._mr2;
        -: 5617:				}
    #####: 5618:				if (q->cost[_mrc_NT] == 0) {
    #####: 5619:					p->cost[_mrc_NT] = 0;
    #####: 5620:					p->rule._mrc = q->rule._mrc;
        -: 5621:				}
    #####: 5622:				if (q->cost[_rc5_NT] == 0) {
    #####: 5623:					p->cost[_rc5_NT] = 0;
    #####: 5624:					p->rule._rc5 = q->rule._rc5;
        -: 5625:				}
    #####: 5626:				if (q->cost[_mrca_NT] == 0) {
    #####: 5627:					p->cost[_mrca_NT] = 0;
    #####: 5628:					p->rule._mrca = q->rule._mrca;
        -: 5629:				}
    #####: 5630:				if (q->cost[_memf_NT] == 0) {
    #####: 5631:					p->cost[_memf_NT] = 0;
    #####: 5632:					p->rule._memf = q->rule._memf;
        -: 5633:				}
    #####: 5634:				if (q->cost[_flt_NT] == 0) {
    #####: 5635:					p->cost[_flt_NT] = 0;
    #####: 5636:					p->rule._flt = q->rule._flt;
        -: 5637:				}
    #####: 5638:				if (q->cost[_addrj_NT] == 0) {
    #####: 5639:					p->cost[_addrj_NT] = 0;
    #####: 5640:					p->rule._addrj = q->rule._addrj;
        -: 5641:				}
    #####: 5642:				if (q->cost[_cmpf_NT] == 0) {
    #####: 5643:					p->cost[_cmpf_NT] = 0;
    #####: 5644:					p->rule._cmpf = q->rule._cmpf;
        -: 5645:				}
        -: 5646:			}
    #####: 5647:			c = 0;
    #####: 5648:			if (c + 0 < p->cost[_reg_NT]) {
    #####: 5649:				p->cost[_reg_NT] = c + 0;
    #####: 5650:				p->rule._reg = 9;
    #####: 5651:				_closure_reg(a, c + 0);
        -: 5652:			}
        -: 5653:		}
    #####: 5654:		break;
        -: 5655:	case 8305: /* CVFF8 */
    #####: 5656:		_label(LEFT_CHILD(a));
    #####: 5657:		if (	/* memf: CVFF8(INDIRF4(addr)) */
        -: 5658:			LEFT_CHILD(a)->op == 4161 /* INDIRF4 */
        -: 5659:		) {
    #####: 5660:			c = ((struct _state *)(LEFT_CHILD(LEFT_CHILD(a))->x.state))->cost[_addr_NT] + 0;
    #####: 5661:			if (c + 0 < p->cost[_memf_NT]) {
    #####: 5662:				p->cost[_memf_NT] = c + 0;
    #####: 5663:				p->rule._memf = 3;
    #####: 5664:				_closure_memf(a, c + 0);
        -: 5665:			}
        -: 5666:		}
        -: 5667:		/* freg: CVFF8(freg) */
    #####: 5668:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_freg_NT] + 0;
    #####: 5669:		if (c + 0 < p->cost[_freg_NT]) {
    #####: 5670:			p->cost[_freg_NT] = c + 0;
    #####: 5671:			p->rule._freg = 14;
    #####: 5672:			_closure_freg(a, c + 0);
        -: 5673:		}
    #####: 5674:		if (	/* cmpf: CVFF8(INDIRF4(addr)) */
        -: 5675:			LEFT_CHILD(a)->op == 4161 /* INDIRF4 */
        -: 5676:		) {
    #####: 5677:			c = ((struct _state *)(LEFT_CHILD(LEFT_CHILD(a))->x.state))->cost[_addr_NT] + 0;
    #####: 5678:			if (c + 0 < p->cost[_cmpf_NT]) {
    #####: 5679:				p->cost[_cmpf_NT] = c + 0;
    #####: 5680:				p->rule._cmpf = 3;
        -: 5681:			}
        -: 5682:		}
    #####: 5683:		break;
        -: 5684:	case 8309: /* CVFI8 */
    #####: 5685:		break;
        -: 5686:	case 8321: /* CVIF8 */
    #####: 5687:		_label(LEFT_CHILD(a));
    #####: 5688:		if (	/* freg: CVIF8(INDIRI4(addr)) */
        -: 5689:			LEFT_CHILD(a)->op == 4165 /* INDIRI4 */
        -: 5690:		) {
    #####: 5691:			c = ((struct _state *)(LEFT_CHILD(LEFT_CHILD(a))->x.state))->cost[_addr_NT] + 10;
    #####: 5692:			if (c + 0 < p->cost[_freg_NT]) {
    #####: 5693:				p->cost[_freg_NT] = c + 0;
    #####: 5694:				p->rule._freg = 16;
    #####: 5695:				_closure_freg(a, c + 0);
        -: 5696:			}
        -: 5697:		}
        -: 5698:		/* freg: CVIF8(reg) */
    #####: 5699:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + 12;
    #####: 5700:		if (c + 0 < p->cost[_freg_NT]) {
    #####: 5701:			p->cost[_freg_NT] = c + 0;
    #####: 5702:			p->rule._freg = 17;
    #####: 5703:			_closure_freg(a, c + 0);
        -: 5704:		}
    #####: 5705:		break;
        -: 5706:	case 8325: /* CVII8 */
    #####: 5707:		break;
        -: 5708:	case 8326: /* CVIU8 */
    #####: 5709:		break;
        -: 5710:	case 8342: /* CVPU8 */
    #####: 5711:		break;
        -: 5712:	case 8343: /* CVPP8 */
    #####: 5713:		break;
        -: 5714:	case 8373: /* CVUI8 */
    #####: 5715:		break;
        -: 5716:	case 8374: /* CVUU8 */
    #####: 5717:		break;
        -: 5718:	case 8375: /* CVUP8 */
    #####: 5719:		break;
        -: 5720:	case 8385: /* NEGF8 */
    #####: 5721:		_label(LEFT_CHILD(a));
        -: 5722:		/* freg: NEGF8(freg) */
    #####: 5723:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_freg_NT] + 0;
    #####: 5724:		if (c + 0 < p->cost[_freg_NT]) {
    #####: 5725:			p->cost[_freg_NT] = c + 0;
    #####: 5726:			p->rule._freg = 4;
    #####: 5727:			_closure_freg(a, c + 0);
        -: 5728:		}
    #####: 5729:		break;
        -: 5730:	case 8389: /* NEGI8 */
    #####: 5731:		break;
        -: 5732:	case 8401: /* CALLF8 */
    #####: 5733:		_label(LEFT_CHILD(a));
        -: 5734:		/* freg: CALLF8(addrj) */
    #####: 5735:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addrj_NT] + (hasargs(a));
    #####: 5736:		if (c + 0 < p->cost[_freg_NT]) {
    #####: 5737:			p->cost[_freg_NT] = c + 0;
    #####: 5738:			p->rule._freg = 39;
    #####: 5739:			_closure_freg(a, c + 0);
        -: 5740:		}
        -: 5741:		/* freg: CALLF8(addrj) */
    #####: 5742:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addrj_NT] + 1;
    #####: 5743:		if (c + 0 < p->cost[_freg_NT]) {
    #####: 5744:			p->cost[_freg_NT] = c + 0;
    #####: 5745:			p->rule._freg = 40;
    #####: 5746:			_closure_freg(a, c + 0);
        -: 5747:		}
        -: 5748:		/* stmt: CALLF8(addrj) */
    #####: 5749:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addrj_NT] + (hasargs(a));
    #####: 5750:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 5751:			p->cost[_stmt_NT] = c + 0;
    #####: 5752:			p->rule._stmt = 103;
        -: 5753:		}
        -: 5754:		/* stmt: CALLF8(addrj) */
    #####: 5755:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addrj_NT] + 1;
    #####: 5756:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 5757:			p->cost[_stmt_NT] = c + 0;
    #####: 5758:			p->rule._stmt = 104;
        -: 5759:		}
    #####: 5760:		break;
        -: 5761:	case 8405: /* CALLI8 */
    #####: 5762:		break;
        -: 5763:	case 8406: /* CALLU8 */
    #####: 5764:		break;
        -: 5765:	case 8407: /* CALLP8 */
    #####: 5766:		break;
        -: 5767:	case 8417: /* LOADF8 */
    #####: 5768:		_label(LEFT_CHILD(a));
        -: 5769:		/* freg: LOADF8(memf) */
    #####: 5770:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_memf_NT] + 0;
    #####: 5771:		if (c + 0 < p->cost[_freg_NT]) {
    #####: 5772:			p->cost[_freg_NT] = c + 0;
    #####: 5773:			p->rule._freg = 36;
    #####: 5774:			_closure_freg(a, c + 0);
        -: 5775:		}
    #####: 5776:		break;
        -: 5777:	case 8421: /* LOADI8 */
    #####: 5778:		break;
        -: 5779:	case 8422: /* LOADU8 */
    #####: 5780:		break;
        -: 5781:	case 8423: /* LOADP8 */
    #####: 5782:		break;
        -: 5783:	case 8433: /* RETF8 */
    #####: 5784:		_label(LEFT_CHILD(a));
        -: 5785:		/* stmt: RETF8(freg) */
    #####: 5786:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_freg_NT] + 0;
    #####: 5787:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 5788:			p->cost[_stmt_NT] = c + 0;
    #####: 5789:			p->rule._stmt = 109;
        -: 5790:		}
    #####: 5791:		break;
        -: 5792:	case 8437: /* RETI8 */
    #####: 5793:		break;
        -: 5794:	case 8438: /* RETU8 */
    #####: 5795:		break;
        -: 5796:	case 8439: /* RETP8 */
    #####: 5797:		break;
        -: 5798:	case 8455: /* ADDRGP8 */
        -: 5799:		/* acon: ADDRGP8 */
    #####: 5800:		if (0 + 0 < p->cost[_acon_NT]) {
    #####: 5801:			p->cost[_acon_NT] = 0 + 0;
    #####: 5802:			p->rule._acon = 2;
        -: 5803:		}
        -: 5804:		/* mrca: ADDRGP8 */
    #####: 5805:		if (0 + 0 < p->cost[_mrca_NT]) {
    #####: 5806:			p->cost[_mrca_NT] = 0 + 0;
    #####: 5807:			p->rule._mrca = 4;
        -: 5808:		}
    #####: 5809:		break;
        -: 5810:	case 8471: /* ADDRFP8 */
    #####: 5811:		break;
        -: 5812:	case 8487: /* ADDRLP8 */
    #####: 5813:		break;
        -: 5814:	case 8497: /* ADDF8 */
    #####: 5815:		_label(LEFT_CHILD(a));
    #####: 5816:		_label(RIGHT_CHILD(a));
        -: 5817:		/* freg: ADDF8(freg,flt) */
    #####: 5818:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_freg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_flt_NT] + 0;
    #####: 5819:		if (c + 0 < p->cost[_freg_NT]) {
    #####: 5820:			p->cost[_freg_NT] = c + 0;
    #####: 5821:			p->rule._freg = 7;
    #####: 5822:			_closure_freg(a, c + 0);
        -: 5823:		}
    #####: 5824:		if (	/* freg: ADDF8(freg,CVIF8(INDIRI4(addr))) */
        -: 5825:			RIGHT_CHILD(a)->op == 8321 && /* CVIF8 */
        -: 5826:			LEFT_CHILD(RIGHT_CHILD(a))->op == 4165 /* INDIRI4 */
        -: 5827:		) {
    #####: 5828:			c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_freg_NT] + ((struct _state *)(LEFT_CHILD(LEFT_CHILD(RIGHT_CHILD(a)))->x.state))->cost[_addr_NT] + 0;
    #####: 5829:			if (c + 0 < p->cost[_freg_NT]) {
    #####: 5830:				p->cost[_freg_NT] = c + 0;
    #####: 5831:				p->rule._freg = 30;
    #####: 5832:				_closure_freg(a, c + 0);
        -: 5833:			}
        -: 5834:		}
    #####: 5835:		if (	/* freg: ADDF8(freg,CVIF8(CVII2(INDIRI2(addr)))) */
        -: 5836:			RIGHT_CHILD(a)->op == 8321 && /* CVIF8 */
        -: 5837:			LEFT_CHILD(RIGHT_CHILD(a))->op == 2181 && /* CVII2 */
        -: 5838:			LEFT_CHILD(LEFT_CHILD(RIGHT_CHILD(a)))->op == 2117 /* INDIRI2 */
        -: 5839:		) {
    #####: 5840:			c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_freg_NT] + ((struct _state *)(LEFT_CHILD(LEFT_CHILD(LEFT_CHILD(RIGHT_CHILD(a))))->x.state))->cost[_addr_NT] + 0;
    #####: 5841:			if (c + 0 < p->cost[_freg_NT]) {
    #####: 5842:				p->cost[_freg_NT] = c + 0;
    #####: 5843:				p->rule._freg = 31;
    #####: 5844:				_closure_freg(a, c + 0);
        -: 5845:			}
        -: 5846:		}
    #####: 5847:		if (	/* freg: ADDF8(freg,CVFF8(INDIRF4(addr))) */
        -: 5848:			RIGHT_CHILD(a)->op == 8305 && /* CVFF8 */
        -: 5849:			LEFT_CHILD(RIGHT_CHILD(a))->op == 4161 /* INDIRF4 */
        -: 5850:		) {
    #####: 5851:			c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_freg_NT] + ((struct _state *)(LEFT_CHILD(LEFT_CHILD(RIGHT_CHILD(a)))->x.state))->cost[_addr_NT] + 0;
    #####: 5852:			if (c + 0 < p->cost[_freg_NT]) {
    #####: 5853:				p->cost[_freg_NT] = c + 0;
    #####: 5854:				p->rule._freg = 32;
    #####: 5855:				_closure_freg(a, c + 0);
        -: 5856:			}
        -: 5857:		}
    #####: 5858:		break;
        -: 5859:	case 8501: /* ADDI8 */
    #####: 5860:		break;
        -: 5861:	case 8502: /* ADDU8 */
    #####: 5862:		break;
        -: 5863:	case 8503: /* ADDP8 */
    #####: 5864:		break;
        -: 5865:	case 8513: /* SUBF8 */
    #####: 5866:		_label(LEFT_CHILD(a));
    #####: 5867:		_label(RIGHT_CHILD(a));
        -: 5868:		/* freg: SUBF8(freg,flt) */
    #####: 5869:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_freg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_flt_NT] + 0;
    #####: 5870:		if (c + 0 < p->cost[_freg_NT]) {
    #####: 5871:			p->cost[_freg_NT] = c + 0;
    #####: 5872:			p->rule._freg = 13;
    #####: 5873:			_closure_freg(a, c + 0);
        -: 5874:		}
    #####: 5875:		if (	/* freg: SUBF8(freg,CVIF8(INDIRI4(addr))) */
        -: 5876:			RIGHT_CHILD(a)->op == 8321 && /* CVIF8 */
        -: 5877:			LEFT_CHILD(RIGHT_CHILD(a))->op == 4165 /* INDIRI4 */
        -: 5878:		) {
    #####: 5879:			c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_freg_NT] + ((struct _state *)(LEFT_CHILD(LEFT_CHILD(RIGHT_CHILD(a)))->x.state))->cost[_addr_NT] + 0;
    #####: 5880:			if (c + 0 < p->cost[_freg_NT]) {
    #####: 5881:				p->cost[_freg_NT] = c + 0;
    #####: 5882:				p->rule._freg = 26;
    #####: 5883:				_closure_freg(a, c + 0);
        -: 5884:			}
        -: 5885:		}
    #####: 5886:		if (	/* freg: SUBF8(CVIF8(INDIRI4(addr)),freg) */
        -: 5887:			LEFT_CHILD(a)->op == 8321 && /* CVIF8 */
        -: 5888:			LEFT_CHILD(LEFT_CHILD(a))->op == 4165 /* INDIRI4 */
        -: 5889:		) {
    #####: 5890:			c = ((struct _state *)(LEFT_CHILD(LEFT_CHILD(LEFT_CHILD(a)))->x.state))->cost[_addr_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_freg_NT] + 0;
    #####: 5891:			if (c + 0 < p->cost[_freg_NT]) {
    #####: 5892:				p->cost[_freg_NT] = c + 0;
    #####: 5893:				p->rule._freg = 27;
    #####: 5894:				_closure_freg(a, c + 0);
        -: 5895:			}
        -: 5896:		}
    #####: 5897:		if (	/* freg: SUBF8(freg,CVIF8(CVII2(INDIRI2(addr)))) */
        -: 5898:			RIGHT_CHILD(a)->op == 8321 && /* CVIF8 */
        -: 5899:			LEFT_CHILD(RIGHT_CHILD(a))->op == 2181 && /* CVII2 */
        -: 5900:			LEFT_CHILD(LEFT_CHILD(RIGHT_CHILD(a)))->op == 2117 /* INDIRI2 */
        -: 5901:		) {
    #####: 5902:			c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_freg_NT] + ((struct _state *)(LEFT_CHILD(LEFT_CHILD(LEFT_CHILD(RIGHT_CHILD(a))))->x.state))->cost[_addr_NT] + 0;
    #####: 5903:			if (c + 0 < p->cost[_freg_NT]) {
    #####: 5904:				p->cost[_freg_NT] = c + 0;
    #####: 5905:				p->rule._freg = 28;
    #####: 5906:				_closure_freg(a, c + 0);
        -: 5907:			}
        -: 5908:		}
    #####: 5909:		if (	/* freg: SUBF8(CVIF8(CVII2(INDIRI2(addr))),freg) */
        -: 5910:			LEFT_CHILD(a)->op == 8321 && /* CVIF8 */
        -: 5911:			LEFT_CHILD(LEFT_CHILD(a))->op == 2181 && /* CVII2 */
        -: 5912:			LEFT_CHILD(LEFT_CHILD(LEFT_CHILD(a)))->op == 2117 /* INDIRI2 */
        -: 5913:		) {
    #####: 5914:			c = ((struct _state *)(LEFT_CHILD(LEFT_CHILD(LEFT_CHILD(LEFT_CHILD(a))))->x.state))->cost[_addr_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_freg_NT] + 0;
    #####: 5915:			if (c + 0 < p->cost[_freg_NT]) {
    #####: 5916:				p->cost[_freg_NT] = c + 0;
    #####: 5917:				p->rule._freg = 29;
    #####: 5918:				_closure_freg(a, c + 0);
        -: 5919:			}
        -: 5920:		}
    #####: 5921:		if (	/* freg: SUBF8(freg,CVFF8(INDIRF4(addr))) */
        -: 5922:			RIGHT_CHILD(a)->op == 8305 && /* CVFF8 */
        -: 5923:			LEFT_CHILD(RIGHT_CHILD(a))->op == 4161 /* INDIRF4 */
        -: 5924:		) {
    #####: 5925:			c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_freg_NT] + ((struct _state *)(LEFT_CHILD(LEFT_CHILD(RIGHT_CHILD(a)))->x.state))->cost[_addr_NT] + 0;
    #####: 5926:			if (c + 0 < p->cost[_freg_NT]) {
    #####: 5927:				p->cost[_freg_NT] = c + 0;
    #####: 5928:				p->rule._freg = 33;
    #####: 5929:				_closure_freg(a, c + 0);
        -: 5930:			}
        -: 5931:		}
    #####: 5932:		break;
        -: 5933:	case 8517: /* SUBI8 */
    #####: 5934:		break;
        -: 5935:	case 8518: /* SUBU8 */
    #####: 5936:		break;
        -: 5937:	case 8519: /* SUBP8 */
    #####: 5938:		break;
        -: 5939:	case 8533: /* LSHI8 */
    #####: 5940:		break;
        -: 5941:	case 8534: /* LSHU8 */
    #####: 5942:		break;
        -: 5943:	case 8549: /* MODI8 */
    #####: 5944:		break;
        -: 5945:	case 8550: /* MODU8 */
    #####: 5946:		break;
        -: 5947:	case 8565: /* RSHI8 */
    #####: 5948:		break;
        -: 5949:	case 8566: /* RSHU8 */
    #####: 5950:		break;
        -: 5951:	case 8581: /* BANDI8 */
    #####: 5952:		break;
        -: 5953:	case 8582: /* BANDU8 */
    #####: 5954:		break;
        -: 5955:	case 8597: /* BCOMI8 */
    #####: 5956:		break;
        -: 5957:	case 8598: /* BCOMU8 */
    #####: 5958:		break;
        -: 5959:	case 8613: /* BORI8 */
    #####: 5960:		break;
        -: 5961:	case 8614: /* BORU8 */
    #####: 5962:		break;
        -: 5963:	case 8629: /* BXORI8 */
    #####: 5964:		break;
        -: 5965:	case 8630: /* BXORU8 */
    #####: 5966:		break;
        -: 5967:	case 8641: /* DIVF8 */
    #####: 5968:		_label(LEFT_CHILD(a));
    #####: 5969:		_label(RIGHT_CHILD(a));
        -: 5970:		/* freg: DIVF8(freg,flt) */
    #####: 5971:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_freg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_flt_NT] + 0;
    #####: 5972:		if (c + 0 < p->cost[_freg_NT]) {
    #####: 5973:			p->cost[_freg_NT] = c + 0;
    #####: 5974:			p->rule._freg = 9;
    #####: 5975:			_closure_freg(a, c + 0);
        -: 5976:		}
    #####: 5977:		if (	/* freg: DIVF8(freg,CVIF8(INDIRI4(addr))) */
        -: 5978:			RIGHT_CHILD(a)->op == 8321 && /* CVIF8 */
        -: 5979:			LEFT_CHILD(RIGHT_CHILD(a))->op == 4165 /* INDIRI4 */
        -: 5980:		) {
    #####: 5981:			c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_freg_NT] + ((struct _state *)(LEFT_CHILD(LEFT_CHILD(RIGHT_CHILD(a)))->x.state))->cost[_addr_NT] + 0;
    #####: 5982:			if (c + 0 < p->cost[_freg_NT]) {
    #####: 5983:				p->cost[_freg_NT] = c + 0;
    #####: 5984:				p->rule._freg = 20;
    #####: 5985:				_closure_freg(a, c + 0);
        -: 5986:			}
        -: 5987:		}
    #####: 5988:		if (	/* freg: DIVF8(CVIF8(INDIRI4(addr)),freg) */
        -: 5989:			LEFT_CHILD(a)->op == 8321 && /* CVIF8 */
        -: 5990:			LEFT_CHILD(LEFT_CHILD(a))->op == 4165 /* INDIRI4 */
        -: 5991:		) {
    #####: 5992:			c = ((struct _state *)(LEFT_CHILD(LEFT_CHILD(LEFT_CHILD(a)))->x.state))->cost[_addr_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_freg_NT] + 0;
    #####: 5993:			if (c + 0 < p->cost[_freg_NT]) {
    #####: 5994:				p->cost[_freg_NT] = c + 0;
    #####: 5995:				p->rule._freg = 21;
    #####: 5996:				_closure_freg(a, c + 0);
        -: 5997:			}
        -: 5998:		}
    #####: 5999:		if (	/* freg: DIVF8(freg,CVIF8(CVII2(INDIRI2(addr)))) */
        -: 6000:			RIGHT_CHILD(a)->op == 8321 && /* CVIF8 */
        -: 6001:			LEFT_CHILD(RIGHT_CHILD(a))->op == 2181 && /* CVII2 */
        -: 6002:			LEFT_CHILD(LEFT_CHILD(RIGHT_CHILD(a)))->op == 2117 /* INDIRI2 */
        -: 6003:		) {
    #####: 6004:			c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_freg_NT] + ((struct _state *)(LEFT_CHILD(LEFT_CHILD(LEFT_CHILD(RIGHT_CHILD(a))))->x.state))->cost[_addr_NT] + 0;
    #####: 6005:			if (c + 0 < p->cost[_freg_NT]) {
    #####: 6006:				p->cost[_freg_NT] = c + 0;
    #####: 6007:				p->rule._freg = 22;
    #####: 6008:				_closure_freg(a, c + 0);
        -: 6009:			}
        -: 6010:		}
    #####: 6011:		if (	/* freg: DIVF8(CVIF8(CVII2(INDIRI2(addr))),freg) */
        -: 6012:			LEFT_CHILD(a)->op == 8321 && /* CVIF8 */
        -: 6013:			LEFT_CHILD(LEFT_CHILD(a))->op == 2181 && /* CVII2 */
        -: 6014:			LEFT_CHILD(LEFT_CHILD(LEFT_CHILD(a)))->op == 2117 /* INDIRI2 */
        -: 6015:		) {
    #####: 6016:			c = ((struct _state *)(LEFT_CHILD(LEFT_CHILD(LEFT_CHILD(LEFT_CHILD(a))))->x.state))->cost[_addr_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_freg_NT] + 0;
    #####: 6017:			if (c + 0 < p->cost[_freg_NT]) {
    #####: 6018:				p->cost[_freg_NT] = c + 0;
    #####: 6019:				p->rule._freg = 23;
    #####: 6020:				_closure_freg(a, c + 0);
        -: 6021:			}
        -: 6022:		}
    #####: 6023:		if (	/* freg: DIVF8(freg,CVFF8(INDIRF4(addr))) */
        -: 6024:			RIGHT_CHILD(a)->op == 8305 && /* CVFF8 */
        -: 6025:			LEFT_CHILD(RIGHT_CHILD(a))->op == 4161 /* INDIRF4 */
        -: 6026:		) {
    #####: 6027:			c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_freg_NT] + ((struct _state *)(LEFT_CHILD(LEFT_CHILD(RIGHT_CHILD(a)))->x.state))->cost[_addr_NT] + 0;
    #####: 6028:			if (c + 0 < p->cost[_freg_NT]) {
    #####: 6029:				p->cost[_freg_NT] = c + 0;
    #####: 6030:				p->rule._freg = 35;
    #####: 6031:				_closure_freg(a, c + 0);
        -: 6032:			}
        -: 6033:		}
    #####: 6034:		break;
        -: 6035:	case 8645: /* DIVI8 */
    #####: 6036:		break;
        -: 6037:	case 8646: /* DIVU8 */
    #####: 6038:		break;
        -: 6039:	case 8657: /* MULF8 */
    #####: 6040:		_label(LEFT_CHILD(a));
    #####: 6041:		_label(RIGHT_CHILD(a));
        -: 6042:		/* freg: MULF8(freg,flt) */
    #####: 6043:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_freg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_flt_NT] + 0;
    #####: 6044:		if (c + 0 < p->cost[_freg_NT]) {
    #####: 6045:			p->cost[_freg_NT] = c + 0;
    #####: 6046:			p->rule._freg = 11;
    #####: 6047:			_closure_freg(a, c + 0);
        -: 6048:		}
    #####: 6049:		if (	/* freg: MULF8(freg,CVIF8(INDIRI4(addr))) */
        -: 6050:			RIGHT_CHILD(a)->op == 8321 && /* CVIF8 */
        -: 6051:			LEFT_CHILD(RIGHT_CHILD(a))->op == 4165 /* INDIRI4 */
        -: 6052:		) {
    #####: 6053:			c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_freg_NT] + ((struct _state *)(LEFT_CHILD(LEFT_CHILD(RIGHT_CHILD(a)))->x.state))->cost[_addr_NT] + 0;
    #####: 6054:			if (c + 0 < p->cost[_freg_NT]) {
    #####: 6055:				p->cost[_freg_NT] = c + 0;
    #####: 6056:				p->rule._freg = 24;
    #####: 6057:				_closure_freg(a, c + 0);
        -: 6058:			}
        -: 6059:		}
    #####: 6060:		if (	/* freg: MULF8(freg,CVIF8(CVII2(INDIRI2(addr)))) */
        -: 6061:			RIGHT_CHILD(a)->op == 8321 && /* CVIF8 */
        -: 6062:			LEFT_CHILD(RIGHT_CHILD(a))->op == 2181 && /* CVII2 */
        -: 6063:			LEFT_CHILD(LEFT_CHILD(RIGHT_CHILD(a)))->op == 2117 /* INDIRI2 */
        -: 6064:		) {
    #####: 6065:			c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_freg_NT] + ((struct _state *)(LEFT_CHILD(LEFT_CHILD(LEFT_CHILD(RIGHT_CHILD(a))))->x.state))->cost[_addr_NT] + 0;
    #####: 6066:			if (c + 0 < p->cost[_freg_NT]) {
    #####: 6067:				p->cost[_freg_NT] = c + 0;
    #####: 6068:				p->rule._freg = 25;
    #####: 6069:				_closure_freg(a, c + 0);
        -: 6070:			}
        -: 6071:		}
    #####: 6072:		if (	/* freg: MULF8(freg,CVFF8(INDIRF4(addr))) */
        -: 6073:			RIGHT_CHILD(a)->op == 8305 && /* CVFF8 */
        -: 6074:			LEFT_CHILD(RIGHT_CHILD(a))->op == 4161 /* INDIRF4 */
        -: 6075:		) {
    #####: 6076:			c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_freg_NT] + ((struct _state *)(LEFT_CHILD(LEFT_CHILD(RIGHT_CHILD(a)))->x.state))->cost[_addr_NT] + 0;
    #####: 6077:			if (c + 0 < p->cost[_freg_NT]) {
    #####: 6078:				p->cost[_freg_NT] = c + 0;
    #####: 6079:				p->rule._freg = 34;
    #####: 6080:				_closure_freg(a, c + 0);
        -: 6081:			}
        -: 6082:		}
    #####: 6083:		break;
        -: 6084:	case 8661: /* MULI8 */
    #####: 6085:		break;
        -: 6086:	case 8662: /* MULU8 */
    #####: 6087:		break;
        -: 6088:	case 8673: /* EQF8 */
    #####: 6089:		_label(LEFT_CHILD(a));
    #####: 6090:		_label(RIGHT_CHILD(a));
        -: 6091:		/* stmt: EQF8(cmpf,freg) */
    #####: 6092:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_cmpf_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_freg_NT] + 0;
    #####: 6093:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 6094:			p->cost[_stmt_NT] = c + 0;
    #####: 6095:			p->rule._stmt = 87;
        -: 6096:		}
    #####: 6097:		break;
        -: 6098:	case 8677: /* EQI8 */
    #####: 6099:		break;
        -: 6100:	case 8678: /* EQU8 */
    #####: 6101:		break;
        -: 6102:	case 8689: /* GEF8 */
    #####: 6103:		_label(LEFT_CHILD(a));
    #####: 6104:		_label(RIGHT_CHILD(a));
        -: 6105:		/* stmt: GEF8(cmpf,freg) */
    #####: 6106:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_cmpf_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_freg_NT] + 0;
    #####: 6107:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 6108:			p->cost[_stmt_NT] = c + 0;
    #####: 6109:			p->rule._stmt = 88;
        -: 6110:		}
    #####: 6111:		break;
        -: 6112:	case 8693: /* GEI8 */
    #####: 6113:		break;
        -: 6114:	case 8694: /* GEU8 */
    #####: 6115:		break;
        -: 6116:	case 8705: /* GTF8 */
    #####: 6117:		_label(LEFT_CHILD(a));
    #####: 6118:		_label(RIGHT_CHILD(a));
        -: 6119:		/* stmt: GTF8(cmpf,freg) */
    #####: 6120:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_cmpf_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_freg_NT] + 0;
    #####: 6121:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 6122:			p->cost[_stmt_NT] = c + 0;
    #####: 6123:			p->rule._stmt = 89;
        -: 6124:		}
    #####: 6125:		break;
        -: 6126:	case 8709: /* GTI8 */
    #####: 6127:		break;
        -: 6128:	case 8710: /* GTU8 */
    #####: 6129:		break;
        -: 6130:	case 8721: /* LEF8 */
    #####: 6131:		_label(LEFT_CHILD(a));
    #####: 6132:		_label(RIGHT_CHILD(a));
        -: 6133:		/* stmt: LEF8(cmpf,freg) */
    #####: 6134:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_cmpf_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_freg_NT] + 0;
    #####: 6135:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 6136:			p->cost[_stmt_NT] = c + 0;
    #####: 6137:			p->rule._stmt = 90;
        -: 6138:		}
    #####: 6139:		break;
        -: 6140:	case 8725: /* LEI8 */
    #####: 6141:		break;
        -: 6142:	case 8726: /* LEU8 */
    #####: 6143:		break;
        -: 6144:	case 8737: /* LTF8 */
    #####: 6145:		_label(LEFT_CHILD(a));
    #####: 6146:		_label(RIGHT_CHILD(a));
        -: 6147:		/* stmt: LTF8(cmpf,freg) */
    #####: 6148:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_cmpf_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_freg_NT] + 0;
    #####: 6149:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 6150:			p->cost[_stmt_NT] = c + 0;
    #####: 6151:			p->rule._stmt = 91;
        -: 6152:		}
    #####: 6153:		break;
        -: 6154:	case 8741: /* LTI8 */
    #####: 6155:		break;
        -: 6156:	case 8742: /* LTU8 */
    #####: 6157:		break;
        -: 6158:	case 8753: /* NEF8 */
    #####: 6159:		_label(LEFT_CHILD(a));
    #####: 6160:		_label(RIGHT_CHILD(a));
        -: 6161:		/* stmt: NEF8(cmpf,freg) */
    #####: 6162:		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_cmpf_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_freg_NT] + 0;
    #####: 6163:		if (c + 0 < p->cost[_stmt_NT]) {
    #####: 6164:			p->cost[_stmt_NT] = c + 0;
    #####: 6165:			p->rule._stmt = 92;
        -: 6166:		}
    #####: 6167:		break;
        -: 6168:	case 8757: /* NEI8 */
    #####: 6169:		break;
        -: 6170:	case 8758: /* NEU8 */
    #####: 6171:		break;
        -: 6172:	case 16401: /* CNSTF16 */
    #####: 6173:		break;
        -: 6174:	case 16417: /* ARGF16 */
    #####: 6175:		break;
        -: 6176:	case 16433: /* ASGNF16 */
    #####: 6177:		break;
        -: 6178:	case 16449: /* INDIRF16 */
    #####: 6179:		break;
        -: 6180:	case 16497: /* CVFF16 */
    #####: 6181:		break;
        -: 6182:	case 16513: /* CVIF16 */
    #####: 6183:		break;
        -: 6184:	case 16535: /* CVPP16 */
    #####: 6185:		break;
        -: 6186:	case 16567: /* CVUP16 */
    #####: 6187:		break;
        -: 6188:	case 16577: /* NEGF16 */
    #####: 6189:		break;
        -: 6190:	case 16593: /* CALLF16 */
    #####: 6191:		break;
        -: 6192:	case 16609: /* LOADF16 */
    #####: 6193:		break;
        -: 6194:	case 16625: /* RETF16 */
    #####: 6195:		break;
        -: 6196:	case 16689: /* ADDF16 */
    #####: 6197:		break;
        -: 6198:	case 16705: /* SUBF16 */
    #####: 6199:		break;
        -: 6200:	case 16833: /* DIVF16 */
    #####: 6201:		break;
        -: 6202:	case 16849: /* MULF16 */
    #####: 6203:		break;
        -: 6204:	case 16865: /* EQF16 */
    #####: 6205:		break;
        -: 6206:	case 16885: /* GEI16 */
    #####: 6207:		break;
        -: 6208:	case 16897: /* GTF16 */
    #####: 6209:		break;
        -: 6210:	case 16913: /* LEF16 */
    #####: 6211:		break;
        -: 6212:	case 16929: /* LTF16 */
    #####: 6213:		break;
        -: 6214:	case 16945: /* NEF16 */
    #####: 6215:		break;
        -: 6216:	default:
    #####: 6217:		fatal("_label", "Bad terminal %d\n", OP_LABEL(a));
        -: 6218:	}
        -: 6219:}
        -: 6220:
function _kids called 0 returned 0% blocks executed 0%
    #####: 6221:static void _kids(NODEPTR_TYPE p, int eruleno, NODEPTR_TYPE kids[]) {
    #####: 6222:	if (!p)
    #####: 6223:		fatal("_kids", "Null tree\n", 0);
    #####: 6224:	if (!kids)
    #####: 6225:		fatal("_kids", "Null kids\n", 0);
    #####: 6226:	switch (eruleno) {
        -: 6227:	case 220: /* stmt: LABELV */
        -: 6228:	case 217: /* addrj: ADDRGP4 */
        -: 6229:	case 174: /* mrca: ADDRGP8 */
        -: 6230:	case 173: /* mrca: ADDRGP4 */
        -: 6231:	case 148: /* rc5: CNSTI4 */
        -: 6232:	case 62: /* con3: CNSTU4 */
        -: 6233:	case 61: /* con3: CNSTI4 */
        -: 6234:	case 60: /* con2: CNSTU4 */
        -: 6235:	case 59: /* con2: CNSTI4 */
        -: 6236:	case 58: /* con1: CNSTU4 */
        -: 6237:	case 57: /* con1: CNSTI4 */
        -: 6238:	case 56: /* con0: CNSTU4 */
        -: 6239:	case 55: /* con0: CNSTI4 */
        -: 6240:	case 47: /* base: ADDRLP4 */
        -: 6241:	case 46: /* base: ADDRFP4 */
        -: 6242:	case 41: /* baseaddr: ADDRGP4 */
        -: 6243:	case 39: /* acon: ADDRGP8 */
        -: 6244:	case 38: /* acon: ADDRGP4 */
        -: 6245:	case 34: /* cnst: CNSTP8 */
        -: 6246:	case 33: /* cnst: CNSTU8 */
        -: 6247:	case 32: /* cnst: CNSTI8 */
        -: 6248:	case 31: /* cnst: CNSTP4 */
        -: 6249:	case 30: /* cnst: CNSTU4 */
        -: 6250:	case 29: /* cnst: CNSTI4 */
        -: 6251:	case 28: /* cnst: CNSTU2 */
        -: 6252:	case 27: /* cnst: CNSTI2 */
        -: 6253:	case 26: /* cnst: CNSTU1 */
        -: 6254:	case 25: /* cnst: CNSTI1 */
        -: 6255:	case 12: /* freg: INDIRF8(VREGP) */
        -: 6256:	case 11: /* freg: INDIRF4(VREGP) */
        -: 6257:	case 10: /* reg: INDIRU8(VREGP) */
        -: 6258:	case 9: /* reg: INDIRP8(VREGP) */
        -: 6259:	case 8: /* reg: INDIRI8(VREGP) */
        -: 6260:	case 7: /* reg: INDIRU4(VREGP) */
        -: 6261:	case 6: /* reg: INDIRP4(VREGP) */
        -: 6262:	case 5: /* reg: INDIRI4(VREGP) */
        -: 6263:	case 4: /* reg: INDIRU2(VREGP) */
        -: 6264:	case 3: /* reg: INDIRI2(VREGP) */
        -: 6265:	case 2: /* reg: INDIRU1(VREGP) */
        -: 6266:	case 1: /* reg: INDIRI1(VREGP) */
    #####: 6267:		break;
        -: 6268:	case 24: /* stmt: ASGNU8(VREGP,reg) */
        -: 6269:	case 23: /* stmt: ASGNP8(VREGP,reg) */
        -: 6270:	case 22: /* stmt: ASGNI8(VREGP,reg) */
        -: 6271:	case 21: /* stmt: ASGNF8(VREGP,reg) */
        -: 6272:	case 20: /* stmt: ASGNU4(VREGP,reg) */
        -: 6273:	case 19: /* stmt: ASGNP4(VREGP,reg) */
        -: 6274:	case 18: /* stmt: ASGNI4(VREGP,reg) */
        -: 6275:	case 17: /* stmt: ASGNF4(VREGP,reg) */
        -: 6276:	case 16: /* stmt: ASGNU2(VREGP,reg) */
        -: 6277:	case 15: /* stmt: ASGNI2(VREGP,reg) */
        -: 6278:	case 14: /* stmt: ASGNU1(VREGP,reg) */
        -: 6279:	case 13: /* stmt: ASGNI1(VREGP,reg) */
    #####: 6280:		kids[0] = RIGHT_CHILD(p);
    #####: 6281:		break;
        -: 6282:	case 254: /* cmpf: freg */
        -: 6283:	case 219: /* addrj: mem4 */
        -: 6284:	case 218: /* addrj: reg */
        -: 6285:	case 200: /* flt: freg */
        -: 6286:	case 199: /* flt: memf */
        -: 6287:	case 191: /* freg: memf */
        -: 6288:	case 172: /* mrca: rc */
        -: 6289:	case 171: /* mrca: mem4 */
        -: 6290:	case 149: /* rc5: reg */
        -: 6291:	case 98: /* reg: con */
        -: 6292:	case 97: /* reg: mr2 */
        -: 6293:	case 96: /* reg: mr1 */
        -: 6294:	case 95: /* reg: mr */
        -: 6295:	case 94: /* reg: addr */
        -: 6296:	case 93: /* mrc: rc */
        -: 6297:	case 92: /* mrc: mem2 */
        -: 6298:	case 91: /* mrc: mem1 */
        -: 6299:	case 90: /* mrc: mem4 */
        -: 6300:	case 89: /* mr2: mem2 */
        -: 6301:	case 88: /* mr2: reg */
        -: 6302:	case 87: /* mr1: mem1 */
        -: 6303:	case 86: /* mr1: reg */
        -: 6304:	case 85: /* mr: mem4 */
        -: 6305:	case 84: /* mr: reg */
        -: 6306:	case 83: /* rc: con */
        -: 6307:	case 82: /* rc: reg */
        -: 6308:	case 74: /* addr: index */
        -: 6309:	case 64: /* addr: baseaddr */
        -: 6310:	case 63: /* addr: base */
        -: 6311:	case 48: /* index: reg */
        -: 6312:	case 42: /* base: reg */
        -: 6313:	case 40: /* acon: cnst */
        -: 6314:	case 37: /* stmt: freg */
        -: 6315:	case 36: /* stmt: reg */
        -: 6316:	case 35: /* con: cnst */
    #####: 6317:		kids[0] = p;
    #####: 6318:		break;
        -: 6319:	case 266: /* stmt: NEF4(cmpf,freg) */
        -: 6320:	case 265: /* stmt: LTF4(cmpf,freg) */
        -: 6321:	case 264: /* stmt: LEF4(cmpf,freg) */
        -: 6322:	case 263: /* stmt: GTF4(cmpf,freg) */
        -: 6323:	case 262: /* stmt: GEF4(cmpf,freg) */
        -: 6324:	case 261: /* stmt: EQF4(cmpf,freg) */
        -: 6325:	case 260: /* stmt: NEF8(cmpf,freg) */
        -: 6326:	case 259: /* stmt: LTF8(cmpf,freg) */
        -: 6327:	case 258: /* stmt: LEF8(cmpf,freg) */
        -: 6328:	case 257: /* stmt: GTF8(cmpf,freg) */
        -: 6329:	case 256: /* stmt: GEF8(cmpf,freg) */
        -: 6330:	case 255: /* stmt: EQF8(cmpf,freg) */
        -: 6331:	case 243: /* stmt: NEU4(reg,mrc) */
        -: 6332:	case 242: /* stmt: LTU4(reg,mrc) */
        -: 6333:	case 241: /* stmt: LEU4(reg,mrc) */
        -: 6334:	case 240: /* stmt: GTU4(reg,mrc) */
        -: 6335:	case 239: /* stmt: GEU4(reg,mrc) */
        -: 6336:	case 238: /* stmt: EQU4(reg,mrc) */
        -: 6337:	case 237: /* stmt: NEI4(reg,mrc) */
        -: 6338:	case 236: /* stmt: LTI4(reg,mrc) */
        -: 6339:	case 235: /* stmt: LEI4(reg,mrc) */
        -: 6340:	case 234: /* stmt: GTI4(reg,mrc) */
        -: 6341:	case 233: /* stmt: GEI4(reg,mrc) */
        -: 6342:	case 232: /* stmt: EQI4(reg,mrc) */
        -: 6343:	case 231: /* stmt: LTU4(mem4,rc) */
        -: 6344:	case 230: /* stmt: LEU4(mem4,rc) */
        -: 6345:	case 229: /* stmt: GTU4(mem4,rc) */
        -: 6346:	case 228: /* stmt: GEU4(mem4,rc) */
        -: 6347:	case 227: /* stmt: NEI4(mem4,rc) */
        -: 6348:	case 226: /* stmt: LTI4(mem4,rc) */
        -: 6349:	case 225: /* stmt: LEI4(mem4,rc) */
        -: 6350:	case 224: /* stmt: GTI4(mem4,rc) */
        -: 6351:	case 223: /* stmt: GEI4(mem4,rc) */
        -: 6352:	case 222: /* stmt: EQI4(mem4,rc) */
        -: 6353:	case 208: /* freg: SUBF8(freg,flt) */
        -: 6354:	case 207: /* freg: SUBF4(freg,flt) */
        -: 6355:	case 206: /* freg: MULF8(freg,flt) */
        -: 6356:	case 205: /* freg: MULF4(freg,flt) */
        -: 6357:	case 204: /* freg: DIVF8(freg,flt) */
        -: 6358:	case 203: /* freg: DIVF4(freg,flt) */
        -: 6359:	case 202: /* freg: ADDF8(freg,flt) */
        -: 6360:	case 201: /* freg: ADDF4(freg,flt) */
        -: 6361:	case 193: /* stmt: ASGNF4(addr,freg) */
        -: 6362:	case 192: /* stmt: ASGNF8(addr,freg) */
        -: 6363:	case 181: /* stmt: ASGNP4(addr,rc) */
        -: 6364:	case 180: /* stmt: ASGNU4(addr,rc) */
        -: 6365:	case 179: /* stmt: ASGNU2(addr,rc) */
        -: 6366:	case 178: /* stmt: ASGNU1(addr,rc) */
        -: 6367:	case 177: /* stmt: ASGNI4(addr,rc) */
        -: 6368:	case 176: /* stmt: ASGNI2(addr,rc) */
        -: 6369:	case 175: /* stmt: ASGNI1(addr,rc) */
        -: 6370:	case 156: /* reg: MODI4(reg,reg) */
        -: 6371:	case 155: /* reg: DIVI4(reg,reg) */
        -: 6372:	case 154: /* reg: MODU4(reg,reg) */
        -: 6373:	case 153: /* reg: DIVU4(reg,reg) */
        -: 6374:	case 152: /* reg: MULU4(reg,mr) */
        -: 6375:	case 151: /* reg: MULI4(con,mr) */
        -: 6376:	case 150: /* reg: MULI4(reg,mrc) */
        -: 6377:	case 143: /* reg: RSHU4(reg,rc5) */
        -: 6378:	case 142: /* reg: RSHI4(reg,rc5) */
        -: 6379:	case 141: /* reg: LSHU4(reg,rc5) */
        -: 6380:	case 140: /* reg: LSHI4(reg,rc5) */
        -: 6381:	case 117: /* reg: BXORU4(reg,mrc) */
        -: 6382:	case 116: /* reg: BORU4(reg,mrc) */
        -: 6383:	case 115: /* reg: BANDU4(reg,mrc) */
        -: 6384:	case 114: /* reg: BXORI4(reg,mrc) */
        -: 6385:	case 113: /* reg: BORI4(reg,mrc) */
        -: 6386:	case 112: /* reg: BANDI4(reg,mrc) */
        -: 6387:	case 111: /* reg: SUBU4(reg,mrc) */
        -: 6388:	case 110: /* reg: SUBP4(reg,mrc) */
        -: 6389:	case 109: /* reg: SUBI4(reg,mrc) */
        -: 6390:	case 108: /* reg: ADDU4(reg,mrc) */
        -: 6391:	case 107: /* reg: ADDP4(reg,mrc) */
        -: 6392:	case 106: /* reg: ADDI4(reg,mrc) */
        -: 6393:	case 73: /* addr: ADDU4(index,reg) */
        -: 6394:	case 72: /* addr: ADDP4(index,reg) */
        -: 6395:	case 71: /* addr: ADDI4(index,reg) */
        -: 6396:	case 70: /* addr: ADDU4(reg,baseaddr) */
        -: 6397:	case 69: /* addr: ADDP4(reg,baseaddr) */
        -: 6398:	case 68: /* addr: ADDI4(reg,baseaddr) */
        -: 6399:	case 67: /* addr: ADDU4(index,baseaddr) */
        -: 6400:	case 66: /* addr: ADDP4(index,baseaddr) */
        -: 6401:	case 65: /* addr: ADDI4(index,baseaddr) */
        -: 6402:	case 54: /* index: LSHU4(reg,con3) */
        -: 6403:	case 53: /* index: LSHU4(reg,con2) */
        -: 6404:	case 52: /* index: LSHU4(reg,con1) */
        -: 6405:	case 51: /* index: LSHI4(reg,con3) */
        -: 6406:	case 50: /* index: LSHI4(reg,con2) */
        -: 6407:	case 49: /* index: LSHI4(reg,con1) */
        -: 6408:	case 45: /* base: ADDU4(reg,acon) */
        -: 6409:	case 44: /* base: ADDP4(reg,acon) */
        -: 6410:	case 43: /* base: ADDI4(reg,acon) */
    #####: 6411:		kids[0] = LEFT_CHILD(p);
    #####: 6412:		kids[1] = RIGHT_CHILD(p);
    #####: 6413:		break;
        -: 6414:	case 304: /* stmt: RETF8(freg) */
        -: 6415:	case 303: /* stmt: RETF4(freg) */
        -: 6416:	case 302: /* stmt: RETP4(reg) */
        -: 6417:	case 301: /* stmt: RETU4(reg) */
        -: 6418:	case 300: /* stmt: RETI4(reg) */
        -: 6419:	case 299: /* stmt: CALLF8(addrj) */
        -: 6420:	case 298: /* stmt: CALLF8(addrj) */
        -: 6421:	case 297: /* freg: CALLF8(addrj) */
        -: 6422:	case 296: /* freg: CALLF8(addrj) */
        -: 6423:	case 295: /* stmt: CALLF4(addrj) */
        -: 6424:	case 294: /* stmt: CALLF4(addrj) */
        -: 6425:	case 293: /* freg: CALLF4(addrj) */
        -: 6426:	case 292: /* freg: CALLF4(addrj) */
        -: 6427:	case 291: /* stmt: CALLV(addrj) */
        -: 6428:	case 290: /* stmt: CALLV(addrj) */
        -: 6429:	case 289: /* reg: CALLP4(addrj) */
        -: 6430:	case 288: /* reg: CALLU4(addrj) */
        -: 6431:	case 287: /* reg: CALLI4(addrj) */
        -: 6432:	case 286: /* reg: CALLP4(addrj) */
        -: 6433:	case 285: /* reg: CALLU4(addrj) */
        -: 6434:	case 284: /* reg: CALLI4(addrj) */
        -: 6435:	case 283: /* freg: LOADF8(memf) */
        -: 6436:	case 252: /* cmpf: INDIRF4(addr) */
        -: 6437:	case 251: /* cmpf: INDIRF8(addr) */
        -: 6438:	case 221: /* stmt: JUMPV(addrj) */
        -: 6439:	case 216: /* freg: CVIF4(reg) */
        -: 6440:	case 214: /* freg: CVIF8(reg) */
        -: 6441:	case 212: /* reg: CVFI4(freg) */
        -: 6442:	case 210: /* freg: CVFF4(freg) */
        -: 6443:	case 209: /* freg: CVFF8(freg) */
        -: 6444:	case 198: /* freg: NEGF4(freg) */
        -: 6445:	case 197: /* freg: NEGF8(freg) */
        -: 6446:	case 196: /* stmt: ARGF4(freg) */
        -: 6447:	case 195: /* stmt: ARGF8(freg) */
        -: 6448:	case 188: /* memf: INDIRF4(addr) */
        -: 6449:	case 187: /* memf: INDIRF8(addr) */
        -: 6450:	case 184: /* stmt: ARGP4(mrca) */
        -: 6451:	case 183: /* stmt: ARGU4(mrca) */
        -: 6452:	case 182: /* stmt: ARGI4(mrca) */
        -: 6453:	case 170: /* reg: CVUU2(reg) */
        -: 6454:	case 169: /* reg: CVUU1(reg) */
        -: 6455:	case 168: /* reg: CVII2(reg) */
        -: 6456:	case 167: /* reg: CVII1(reg) */
        -: 6457:	case 166: /* reg: CVUU4(reg) */
        -: 6458:	case 165: /* reg: CVUI4(reg) */
        -: 6459:	case 164: /* reg: CVIU4(reg) */
        -: 6460:	case 163: /* reg: CVII4(reg) */
        -: 6461:	case 158: /* reg: CVUP4(reg) */
        -: 6462:	case 157: /* reg: CVPU4(reg) */
        -: 6463:	case 136: /* reg: NEGI4(reg) */
        -: 6464:	case 135: /* reg: BCOMU4(reg) */
        -: 6465:	case 134: /* reg: BCOMI4(reg) */
        -: 6466:	case 105: /* reg: LOADP4(reg) */
        -: 6467:	case 104: /* reg: LOADU4(reg) */
        -: 6468:	case 103: /* reg: LOADU2(reg) */
        -: 6469:	case 102: /* reg: LOADU1(reg) */
        -: 6470:	case 101: /* reg: LOADI4(reg) */
        -: 6471:	case 100: /* reg: LOADI2(reg) */
        -: 6472:	case 99: /* reg: LOADI1(reg) */
        -: 6473:	case 81: /* mem4: INDIRP4(addr) */
        -: 6474:	case 80: /* mem4: INDIRU4(addr) */
        -: 6475:	case 79: /* mem4: INDIRI4(addr) */
        -: 6476:	case 78: /* mem2: INDIRU2(addr) */
        -: 6477:	case 77: /* mem2: INDIRI2(addr) */
        -: 6478:	case 76: /* mem1: INDIRU1(addr) */
        -: 6479:	case 75: /* mem1: INDIRI1(addr) */
    #####: 6480:		kids[0] = LEFT_CHILD(p);
    #####: 6481:		break;
        -: 6482:	case 147: /* stmt: ASGNI4(addr,RSHU4(mem4,rc5)) */
        -: 6483:	case 146: /* stmt: ASGNI4(addr,RSHI4(mem4,rc5)) */
        -: 6484:	case 145: /* stmt: ASGNI4(addr,LSHU4(mem4,rc5)) */
        -: 6485:	case 144: /* stmt: ASGNI4(addr,LSHI4(mem4,rc5)) */
        -: 6486:	case 133: /* stmt: ASGNU4(addr,BXORU4(mem4,rc)) */
        -: 6487:	case 132: /* stmt: ASGNU4(addr,BORU4(mem4,rc)) */
        -: 6488:	case 131: /* stmt: ASGNU4(addr,BANDU4(mem4,rc)) */
        -: 6489:	case 130: /* stmt: ASGNI4(addr,BXORI4(mem4,rc)) */
        -: 6490:	case 129: /* stmt: ASGNI4(addr,BORI4(mem4,rc)) */
        -: 6491:	case 128: /* stmt: ASGNI4(addr,BANDI4(mem4,rc)) */
        -: 6492:	case 127: /* stmt: ASGNU4(addr,SUBU4(mem4,rc)) */
        -: 6493:	case 126: /* stmt: ASGNU4(addr,ADDU4(mem4,rc)) */
        -: 6494:	case 125: /* stmt: ASGNI4(addr,SUBI4(mem4,rc)) */
        -: 6495:	case 124: /* stmt: ASGNI4(addr,ADDI4(mem4,rc)) */
        -: 6496:	case 123: /* stmt: ASGNP4(addr,SUBP4(mem4,con1)) */
        -: 6497:	case 122: /* stmt: ASGNI4(addr,SUBU4(mem4,con1)) */
        -: 6498:	case 121: /* stmt: ASGNI4(addr,SUBI4(mem4,con1)) */
        -: 6499:	case 120: /* stmt: ASGNP4(addr,ADDP4(mem4,con1)) */
        -: 6500:	case 119: /* stmt: ASGNI4(addr,ADDU4(mem4,con1)) */
        -: 6501:	case 118: /* stmt: ASGNI4(addr,ADDI4(mem4,con1)) */
    #####: 6502:		kids[0] = LEFT_CHILD(p);
    #####: 6503:		kids[1] = LEFT_CHILD(RIGHT_CHILD(p));
    #####: 6504:		kids[2] = RIGHT_CHILD(RIGHT_CHILD(p));
    #####: 6505:		break;
        -: 6506:	case 211: /* stmt: ASGNI4(addr,CVFI4(freg)) */
        -: 6507:	case 194: /* stmt: ASGNF4(addr,CVFF4(freg)) */
        -: 6508:	case 185: /* stmt: ASGNB(reg,INDIRB(reg)) */
        -: 6509:	case 139: /* stmt: ASGNI4(addr,NEGI4(mem4)) */
        -: 6510:	case 138: /* stmt: ASGNU4(addr,BCOMU4(mem4)) */
        -: 6511:	case 137: /* stmt: ASGNI4(addr,BCOMI4(mem4)) */
    #####: 6512:		kids[0] = LEFT_CHILD(p);
    #####: 6513:		kids[1] = LEFT_CHILD(RIGHT_CHILD(p));
    #####: 6514:		break;
        -: 6515:	case 253: /* cmpf: CVFF8(INDIRF4(addr)) */
        -: 6516:	case 215: /* freg: CVIF4(INDIRI4(addr)) */
        -: 6517:	case 213: /* freg: CVIF8(INDIRI4(addr)) */
        -: 6518:	case 190: /* memf: CVFF4(INDIRF8(addr)) */
        -: 6519:	case 189: /* memf: CVFF8(INDIRF4(addr)) */
        -: 6520:	case 186: /* stmt: ARGB(INDIRB(reg)) */
        -: 6521:	case 162: /* reg: CVUU4(INDIRU2(addr)) */
        -: 6522:	case 161: /* reg: CVUU4(INDIRU1(addr)) */
        -: 6523:	case 160: /* reg: CVII4(INDIRI2(addr)) */
        -: 6524:	case 159: /* reg: CVII4(INDIRI1(addr)) */
    #####: 6525:		kids[0] = LEFT_CHILD(LEFT_CHILD(p));
    #####: 6526:		break;
        -: 6527:	case 245: /* stmt: NEI4(BANDU4(mr,con),con0) */
        -: 6528:	case 244: /* stmt: EQI4(BANDU4(mr,con),con0) */
    #####: 6529:		kids[0] = LEFT_CHILD(LEFT_CHILD(p));
    #####: 6530:		kids[1] = RIGHT_CHILD(LEFT_CHILD(p));
    #####: 6531:		kids[2] = RIGHT_CHILD(p);
    #####: 6532:		break;
        -: 6533:	case 250: /* stmt: EQI4(BANDU4(CVII1(INDIRI1(addr)),con),con0) */
        -: 6534:	case 249: /* stmt: NEI4(BANDU4(CVIU2(INDIRI2(addr)),con),con0) */
        -: 6535:	case 248: /* stmt: EQI4(BANDU4(CVIU2(INDIRI2(addr)),con),con0) */
        -: 6536:	case 247: /* stmt: NEI4(BANDU4(CVII2(INDIRI2(addr)),con),con0) */
        -: 6537:	case 246: /* stmt: EQI4(BANDU4(CVII2(INDIRI2(addr)),con),con0) */
    #####: 6538:		kids[0] = LEFT_CHILD(LEFT_CHILD(LEFT_CHILD(LEFT_CHILD(p))));
    #####: 6539:		kids[1] = RIGHT_CHILD(LEFT_CHILD(p));
    #####: 6540:		kids[2] = RIGHT_CHILD(p);
    #####: 6541:		break;
        -: 6542:	case 282: /* freg: DIVF8(freg,CVFF8(INDIRF4(addr))) */
        -: 6543:	case 281: /* freg: MULF8(freg,CVFF8(INDIRF4(addr))) */
        -: 6544:	case 280: /* freg: SUBF8(freg,CVFF8(INDIRF4(addr))) */
        -: 6545:	case 279: /* freg: ADDF8(freg,CVFF8(INDIRF4(addr))) */
        -: 6546:	case 277: /* freg: ADDF8(freg,CVIF8(INDIRI4(addr))) */
        -: 6547:	case 273: /* freg: SUBF8(freg,CVIF8(INDIRI4(addr))) */
        -: 6548:	case 271: /* freg: MULF8(freg,CVIF8(INDIRI4(addr))) */
        -: 6549:	case 267: /* freg: DIVF8(freg,CVIF8(INDIRI4(addr))) */
    #####: 6550:		kids[0] = LEFT_CHILD(p);
    #####: 6551:		kids[1] = LEFT_CHILD(LEFT_CHILD(RIGHT_CHILD(p)));
    #####: 6552:		break;
        -: 6553:	case 274: /* freg: SUBF8(CVIF8(INDIRI4(addr)),freg) */
        -: 6554:	case 268: /* freg: DIVF8(CVIF8(INDIRI4(addr)),freg) */
    #####: 6555:		kids[0] = LEFT_CHILD(LEFT_CHILD(LEFT_CHILD(p)));
    #####: 6556:		kids[1] = RIGHT_CHILD(p);
    #####: 6557:		break;
        -: 6558:	case 278: /* freg: ADDF8(freg,CVIF8(CVII2(INDIRI2(addr)))) */
        -: 6559:	case 275: /* freg: SUBF8(freg,CVIF8(CVII2(INDIRI2(addr)))) */
        -: 6560:	case 272: /* freg: MULF8(freg,CVIF8(CVII2(INDIRI2(addr)))) */
        -: 6561:	case 269: /* freg: DIVF8(freg,CVIF8(CVII2(INDIRI2(addr)))) */
    #####: 6562:		kids[0] = LEFT_CHILD(p);
    #####: 6563:		kids[1] = LEFT_CHILD(LEFT_CHILD(LEFT_CHILD(RIGHT_CHILD(p))));
    #####: 6564:		break;
        -: 6565:	case 276: /* freg: SUBF8(CVIF8(CVII2(INDIRI2(addr))),freg) */
        -: 6566:	case 270: /* freg: DIVF8(CVIF8(CVII2(INDIRI2(addr))),freg) */
    #####: 6567:		kids[0] = LEFT_CHILD(LEFT_CHILD(LEFT_CHILD(LEFT_CHILD(p))));
    #####: 6568:		kids[1] = RIGHT_CHILD(p);
    #####: 6569:		break;
        -: 6570:	default:
    #####: 6571:		fatal("_kids", "Bad rule number %d\n", eruleno);
        -: 6572:	}
        -: 6573:}
        -: 6574:
function progbeg called 1 returned 100% blocks executed 97%
        1: 6575:static void progbeg(int argc, char *argv[]) {
        1: 6576:        int i;
        -: 6577:
        -: 6578:        {
        -: 6579:                union {
        -: 6580:                        char c;
        -: 6581:                        int i;
        1: 6582:                } u;
        1: 6583:                u.i = 0;
        1: 6584:                u.c = 1;
        1: 6585:                swap = ((int)(u.i == 1)) != IR->little_endian;
        -: 6586:        }
        1: 6587:        parseflags(argc, argv);
        7: 6588:        for (i = 0; i < argc; i++)
        6: 6589:                if (strcmp(argv[i], "-p") == 0 || strcmp(argv[i], "-pg") == 0)
    #####: 6590:                        pflag = 1;      
        1: 6591:        intreg[EAX]   = mkreg("%%eax", EAX, 1, IREG);
        1: 6592:        intreg[EDX]   = mkreg("%%edx", EDX, 1, IREG);
        1: 6593:        intreg[ECX]   = mkreg("%%ecx", ECX, 1, IREG);
        1: 6594:        intreg[EBX]   = mkreg("%%ebx", EBX, 1, IREG);
        1: 6595:        intreg[ESI]   = mkreg("%%esi", ESI, 1, IREG);
        1: 6596:        intreg[EDI]   = mkreg("%%edi", EDI, 1, IREG);
        1: 6597:        shortreg[EAX] = mkreg("%%ax", EAX, 1, IREG);
        1: 6598:        shortreg[ECX] = mkreg("%%cx", ECX, 1, IREG);
        1: 6599:        shortreg[EDX] = mkreg("%%dx", EDX, 1, IREG);
        1: 6600:        shortreg[EBX] = mkreg("%%bx", EBX, 1, IREG);
        1: 6601:        shortreg[ESI] = mkreg("%%si", ESI, 1, IREG);
        1: 6602:        shortreg[EDI] = mkreg("%%di", EDI, 1, IREG);
        1: 6603:        charreg[EAX]  = mkreg("%%al", EAX, 1, IREG);
        1: 6604:        charreg[ECX]  = mkreg("%%cl", ECX, 1, IREG);
        1: 6605:        charreg[EDX]  = mkreg("%%dl", EDX, 1, IREG);
        1: 6606:        charreg[EBX]  = mkreg("%%bl", EBX, 1, IREG);
        9: 6607:        for (i = 0; i < 8; i++)
        8: 6608:                fltreg[i] = mkreg("%d", i, 0, FREG);
        1: 6609:        charregw = mkwildcard(charreg);
        1: 6610:        shortregw = mkwildcard(shortreg);
        1: 6611:        intregw = mkwildcard(intreg);
        1: 6612:        fltregw = mkwildcard(fltreg);
        -: 6613:
        1: 6614:        tmask[IREG] = (1<<EDI) | (1<<ESI) | (1<<EBX)
        -: 6615:                    | (1<<EDX) | (1<<ECX) | (1<<EAX);
        1: 6616:        vmask[IREG] = 0;
        1: 6617:        tmask[FREG] = 0xff;
        1: 6618:        vmask[FREG] = 0;
        -: 6619:
        1: 6620:        cseg = 0;
        1: 6621:        quo = mkreg("%%eax", EAX, 1, IREG);
        1: 6622:        quo->x.regnode->mask |= 1<<EDX;
        1: 6623:        rem = mkreg("%%edx", EDX, 1, IREG);
        1: 6624:        rem->x.regnode->mask |= 1<<EAX;
        -: 6625:
        1: 6626:        stabprefix = ".LL";
        -: 6627:}
        -: 6628:
function rmap called 0 returned 0% blocks executed 0%
    #####: 6629:static Symbol rmap(int opk) {
    #####: 6630:        switch (optype(opk)) {
        -: 6631:        case B: case P:
    #####: 6632:                return intregw;
        -: 6633:        case I: case U:
    #####: 6634:                if (opsize(opk) == 1)
    #####: 6635:                        return charregw;
    #####: 6636:                else if (opsize(opk) == 2)
    #####: 6637:                        return shortregw;
        -: 6638:                else
    #####: 6639:                        return intregw;
        -: 6640:        case F:
    #####: 6641:                return fltregw;
        -: 6642:        default:
    #####: 6643:                return 0;
        -: 6644:        }
        -: 6645:}
        -: 6646:
        -: 6647:static Symbol prevg;
        -: 6648:
function globalend called 1 returned 100% blocks executed 40%
        1: 6649:static void globalend(void) {
        1: 6650:        if (prevg && prevg->type->size > 0)
    #####: 6651:                print(".size %s,%d\n", prevg->x.name, prevg->type->size);
        1: 6652:        prevg = NULL;
        -: 6653:}
        -: 6654:
function progend called 1 returned 100% blocks executed 100%
        1: 6655:static void progend(void) {
        1: 6656:        globalend();
        1: 6657:        (*IR->segment)(CODE);
        1: 6658:        print(".ident \"LCC: 4.1\"\n");
        -: 6659:}
        -: 6660:
function target called 0 returned 0% blocks executed 0%
    #####: 6661:static void target(Node p) {
    #####: 6662:        assert(p);
    #####: 6663:        switch (specific(p->op)) {
        -: 6664:        case RSH+I: case RSH+U: case LSH+I: case LSH+U:
    #####: 6665:                if (generic(p->kids[1]->op) != CNST
        -: 6666:                && !(   generic(p->kids[1]->op) == INDIR
        -: 6667:                     && specific(p->kids[1]->kids[0]->op) == VREG+P
        -: 6668:                     && p->kids[1]->syms[RX]->u.t.cse
        -: 6669:                     && generic(p->kids[1]->syms[RX]->u.t.cse->op) == CNST)) {
    #####: 6670:                        rtarget(p, 1, intreg[ECX]);
    #####: 6671:                        setreg(p, intreg[EAX]);
        -: 6672:                }
    #####: 6673:                break;
        -: 6674:        case MUL+U:
    #####: 6675:                setreg(p, quo);
    #####: 6676:                rtarget(p, 0, intreg[EAX]);
    #####: 6677:                break;
        -: 6678:        case DIV+I: case DIV+U:
    #####: 6679:                setreg(p, quo);
    #####: 6680:                rtarget(p, 0, intreg[EAX]);
    #####: 6681:                rtarget(p, 1, intreg[ECX]);
    #####: 6682:                break;
        -: 6683:        case MOD+I: case MOD+U:
    #####: 6684:                setreg(p, rem);
    #####: 6685:                rtarget(p, 0, intreg[EAX]);
    #####: 6686:                rtarget(p, 1, intreg[ECX]);
    #####: 6687:                break;
        -: 6688:        case ASGN+B:
    #####: 6689:                rtarget(p, 0, intreg[EDI]);
    #####: 6690:                rtarget(p->kids[1], 0, intreg[ESI]);
    #####: 6691:                break;
        -: 6692:        case ARG+B:
    #####: 6693:                rtarget(p->kids[0], 0, intreg[ESI]);
    #####: 6694:                break;
        -: 6695:        case CVF+I:
    #####: 6696:                setreg(p, intreg[EAX]);
    #####: 6697:                break;
        -: 6698:        case CALL+I: case CALL+U: case CALL+P: case CALL+V:
    #####: 6699:                setreg(p, intreg[EAX]);
    #####: 6700:                break;
        -: 6701:        case RET+I: case RET+U: case RET+P:
    #####: 6702:                rtarget(p, 0, intreg[EAX]);
    #####: 6703:                break;
        -: 6704:        }
        -: 6705:}
        -: 6706:
function clobber called 0 returned 0% blocks executed 0%
    #####: 6707:static void clobber(Node p) {
    #####: 6708:        static int nstack = 0;
        -: 6709:
    #####: 6710:        assert(p);
    #####: 6711:        nstack = ckstack(p, nstack);
    #####: 6712:        switch (specific(p->op)) {
        -: 6713:        case ASGN+B: case ARG+B:
    #####: 6714:                spill(1<<ECX | 1<<ESI | 1<<EDI, IREG, p);
    #####: 6715:                break;
        -: 6716:        case EQ+F: case LE+F: case GE+F: case LT+F: case GT+F: case NE+F:
    #####: 6717:                spill(1<<EAX, IREG, p);
    #####: 6718:                break;
        -: 6719:        case CALL+F:
    #####: 6720:                spill(1<<EDX | 1<<EAX | 1<<ECX, IREG, p);
    #####: 6721:                break;
        -: 6722:        case CALL+I: case CALL+U: case CALL+P: case CALL+V:
    #####: 6723:                spill(1<<EDX | 1<<ECX, IREG, p);
    #####: 6724:                break;
        -: 6725:        }
        -: 6726:}
        -: 6727:
function emit2 called 0 returned 0% blocks executed 0%
    #####: 6728:static void emit2(Node p) {
    #####: 6729:        int op = specific(p->op);
        -: 6730:#define preg(f) ((f)[getregnum(p->x.kids[0])]->x.name)
        -: 6731:
    #####: 6732:        if (op == CVI+I && opsize(p->op) == 4 && opsize(p->x.kids[0]->op) == 1)
    #####: 6733:                print("movsbl %s,%s\n", preg(charreg), p->syms[RX]->x.name);
    #####: 6734:        else if (op == CVI+U && opsize(p->op) == 4 && opsize(p->x.kids[0]->op) == 1)
    #####: 6735:                print("movsbl %s,%s\n", preg(charreg), p->syms[RX]->x.name);
    #####: 6736:        else if (op == CVI+I && opsize(p->op) == 4 && opsize(p->x.kids[0]->op) == 2)
    #####: 6737:                print("movswl %s,%s\n", preg(shortreg), p->syms[RX]->x.name);
    #####: 6738:        else if (op == CVI+U && opsize(p->op) == 4 && opsize(p->x.kids[0]->op) == 2)
    #####: 6739:                print("movswl %s,%s\n", preg(shortreg), p->syms[RX]->x.name);
    #####: 6740:        else if (op == CVU+I && opsize(p->op) == 4 && opsize(p->x.kids[0]->op) == 1)
    #####: 6741:                print("movzbl %s,%s\n", preg(charreg), p->syms[RX]->x.name);
    #####: 6742:        else if (op == CVU+U && opsize(p->op) == 4 && opsize(p->x.kids[0]->op) == 1)
    #####: 6743:                print("movzbl %s,%s\n", preg(charreg), p->syms[RX]->x.name);
    #####: 6744:        else if (op == CVU+I && opsize(p->op) == 4 && opsize(p->x.kids[0]->op) == 2)
    #####: 6745:                print("movzwl %s,%s\n", preg(shortreg), p->syms[RX]->x.name);
    #####: 6746:        else if (op == CVU+U && opsize(p->op) == 4 && opsize(p->x.kids[0]->op) == 2)
    #####: 6747:                print("movzwl %s,%s\n", preg(shortreg), p->syms[RX]->x.name);
    #####: 6748:        else if (generic(op) == CVI || generic(op) == CVU || generic(op) == LOAD) {
    #####: 6749:                char *dst = intreg[getregnum(p)]->x.name;
    #####: 6750:                char *src = preg(intreg);
    #####: 6751:                assert(opsize(p->op) <= opsize(p->x.kids[0]->op));
    #####: 6752:                if (dst != src)
    #####: 6753:                        print("movl %s,%s\n", src, dst);
        -: 6754:        }       
        -: 6755:}
        -: 6756:
function function called 0 returned 0% blocks executed 0%
    #####: 6757:static void function(Symbol f, Symbol caller[], Symbol callee[], int n) {
    #####: 6758:        int i;
        -: 6759:        
    #####: 6760:        globalend();
    #####: 6761:        print(".align 16\n");
    #####: 6762:        print(".type %s,@function\n", f->x.name);
    #####: 6763:        print("%s:\n", f->x.name);
    #####: 6764:        print("pushl %%ebp\n");
    #####: 6765:        if (pflag) {
    #####: 6766:                static int plab;
    #####: 6767:                print("movl %%esp,%%ebp\n");
    #####: 6768:                (*IR->segment)(DATA);
    #####: 6769:                print(".align 4\n.LP%d:\n.long 0\n", plab);
    #####: 6770:                (*IR->segment)(CODE);
    #####: 6771:                print("movl $.LP%d,%%edx\ncall mcount\n", plab);
    #####: 6772:                plab++;
        -: 6773:        }
    #####: 6774:        print("pushl %%ebx\n");
    #####: 6775:        print("pushl %%esi\n");
    #####: 6776:        print("pushl %%edi\n");
    #####: 6777:        print("movl %%esp,%%ebp\n");
        -: 6778:
    #####: 6779:        usedmask[0] = usedmask[1] = 0;
    #####: 6780:        freemask[0] = freemask[1] = ~0U;
    #####: 6781:        offset = 16 + 4;
    #####: 6782:        for (i = 0; callee[i]; i++) {
    #####: 6783:                Symbol p = callee[i];
    #####: 6784:                Symbol q = caller[i];
    #####: 6785:                assert(q);
    #####: 6786:                offset = roundup(offset, q->type->align);
    #####: 6787:                p->x.offset = q->x.offset = offset;
    #####: 6788:                p->x.name = q->x.name = stringf("%d", p->x.offset);
    #####: 6789:                p->sclass = q->sclass = AUTO;
    #####: 6790:                offset += roundup(q->type->size, 4);
        -: 6791:        }
    #####: 6792:        assert(caller[i] == 0);
    #####: 6793:        offset = maxoffset = 0;
    #####: 6794:        gencode(caller, callee);
    #####: 6795:        framesize = roundup(maxoffset, 4);
    #####: 6796:        if (framesize > 0)
    #####: 6797:                print("subl $%d,%%esp\n", framesize);
    #####: 6798:        emitcode();
    #####: 6799:        print("movl %%ebp,%%esp\n");
    #####: 6800:        print("popl %%edi\n");
    #####: 6801:        print("popl %%esi\n");
    #####: 6802:        print("popl %%ebx\n");
    #####: 6803:        print("popl %%ebp\n");
    #####: 6804:        print("ret\n");
    #####: 6805:        { int l = genlabel(1);
    #####: 6806:          print(".Lf%d:\n", l);
    #####: 6807:          print(".size %s,.Lf%d-%s\n", f->x.name, l, f->x.name);
        -: 6808:        }
        -: 6809:}
        -: 6810:
function defsymbol called 1 returned 100% blocks executed 40%
        1: 6811:static void defsymbol(Symbol p) {
        1: 6812:        if (p->scope >= LOCAL && p->sclass == STATIC)
    #####: 6813:                p->x.name = stringf("%s.%d", p->name, genlabel(1));
        1: 6814:        else if (p->generated)
    #####: 6815:                p->x.name = stringf(".LC%s", p->name);
        1: 6816:        else if (p->scope == GLOBAL || p->sclass == EXTERN)
        1: 6817:                p->x.name = stringf("%s", p->name);
        -: 6818:        else
    #####: 6819:                p->x.name = p->name;
        -: 6820:}
        -: 6821:
function segment called 1 returned 100% blocks executed 36%
        1: 6822:static void segment(int n) {
        1: 6823:        if (n == cseg)
    #####: 6824:                return;
        1: 6825:        cseg = n;
        1: 6826:        if (cseg == CODE)
        1: 6827:                print(".text\n");
    #####: 6828:        else if (cseg == BSS)
    #####: 6829:                print(".bss\n");
    #####: 6830:        else if (cseg == DATA || cseg == LIT)
    #####: 6831:                print(".data\n");
        -: 6832:}
        -: 6833:
function defconst called 0 returned 0% blocks executed 0%
    #####: 6834:static void defconst(int suffix, int size, Value v) {
    #####: 6835:        if (suffix == I && size == 1)
    #####: 6836:                print(".byte %d\n",   v.u);
    #####: 6837:        else if (suffix == I && size == 2)
    #####: 6838:                print(".word %d\n",   v.i);
    #####: 6839:        else if (suffix == I && size == 4)
    #####: 6840:                print(".long %d\n",   v.i);
    #####: 6841:        else if (suffix == U && size == 1)
    #####: 6842:                print(".byte %d\n", v.u);
    #####: 6843:        else if (suffix == U && size == 2)
    #####: 6844:                print(".word %d\n", v.u);
    #####: 6845:        else if (suffix == U && size == 4)
    #####: 6846:                print(".long %d\n", v.u);
    #####: 6847:        else if (suffix == P && size == 4)
    #####: 6848:                print(".long %d\n", v.p);
    #####: 6849:        else if (suffix == F && size == 4) {
    #####: 6850:                float f = v.d;
    #####: 6851:                print(".long %d\n", *(unsigned *)&f);
    #####: 6852:        } else if (suffix == F && size == 8) {
    #####: 6853:                double d = v.d;
    #####: 6854:                unsigned *p = (unsigned *)&d;
    #####: 6855:                print(".long %d\n.long %d\n", p[swap], p[!swap]);
        -: 6856:        }
    #####: 6857:        else assert(0);
        -: 6858:}
        -: 6859:
function defaddress called 0 returned 0% blocks executed 0%
    #####: 6860:static void defaddress(Symbol p) {
    #####: 6861:        print(".long %s\n", p->x.name);
        -: 6862:}
        -: 6863:
function defstring called 0 returned 0% blocks executed 0%
    #####: 6864:static void defstring(int n, char *str) {
    #####: 6865:        char *s;
        -: 6866:
    #####: 6867:        for (s = str; s < str + n; s++)
    #####: 6868:                print(".byte %d\n", (*s)&0377);
        -: 6869:}
        -: 6870:
function export called 0 returned 0% blocks executed 0%
    #####: 6871:static void export(Symbol p) {
    #####: 6872:        globalend();
    #####: 6873:        print(".globl %s\n", p->x.name);
        -: 6874:}
        -: 6875:
function import called 1 returned 100% blocks executed 100%
        1: 6876:static void import(Symbol p) {}
        -: 6877:
function global called 0 returned 0% blocks executed 0%
    #####: 6878:static void global(Symbol p) {
    #####: 6879:        globalend();
    #####: 6880:        print(".align %d\n", p->type->align > 4 ? 4 : p->type->align);
    #####: 6881:        if (!p->generated) {
    #####: 6882:                print(".type %s,@%s\n", p->x.name,
        -: 6883:                        isfunc(p->type) ? "function" : "object");
    #####: 6884:                if (p->type->size > 0)
    #####: 6885:                        print(".size %s,%d\n", p->x.name, p->type->size);
        -: 6886:                else
    #####: 6887:                        prevg = p;
        -: 6888:        }
    #####: 6889:        if (p->u.seg == BSS) {
    #####: 6890:                if (p->sclass == STATIC)
    #####: 6891:                        print(".lcomm %s,%d\n", p->x.name, p->type->size);
        -: 6892:                else
    #####: 6893:                        print(".comm %s,%d\n", p->x.name, p->type->size);
        -: 6894:        } else {
    #####: 6895:                print("%s:\n", p->x.name);
        -: 6896:        }
        -: 6897:}
        -: 6898:
function space called 0 returned 0% blocks executed 0%
    #####: 6899:static void space(int n) {
    #####: 6900:        if (cseg != BSS)
    #####: 6901:                print(".space %d\n", n);
        -: 6902:}
        -: 6903:
        -: 6904:Interface x86linuxIR = {
        -: 6905:        1, 1, 0,  /* char */
        -: 6906:        2, 2, 0,  /* short */
        -: 6907:        4, 4, 0,  /* int */
        -: 6908:        4, 4, 0,  /* long */
        -: 6909:        4, 4, 0,  /* long long */
        -: 6910:        4, 4, 1,  /* float */
        -: 6911:        8, 4, 1,  /* double */
        -: 6912:        8, 4, 1,  /* long double */
        -: 6913:        4, 4, 0,  /* T * */
        -: 6914:        0, 4, 0,  /* struct; so that ARGB keeps stack aligned */
        -: 6915:        1,        /* little_endian */
        -: 6916:        0,        /* mulops_calls */
        -: 6917:        0,        /* wants_callb */
        -: 6918:        1,        /* wants_argb */
        -: 6919:        0,        /* left_to_right */
        -: 6920:        0,        /* wants_dag */
        -: 6921:        0,        /* unsigned_char */
        -: 6922:        0, /* address */
        -: 6923:        blockbeg,
        -: 6924:        blockend,
        -: 6925:        defaddress,
        -: 6926:        defconst,
        -: 6927:        defstring,
        -: 6928:        defsymbol,
        -: 6929:        emit,
        -: 6930:        export,
        -: 6931:        function,
        -: 6932:        gen,
        -: 6933:        global,
        -: 6934:        import,
        -: 6935:        0, /* local */
        -: 6936:        progbeg,
        -: 6937:        progend,
        -: 6938:        segment,
        -: 6939:        space,
        -: 6940:        stabblock, stabend, 0, stabinit, stabline, stabsym, stabtype,
        -: 6941:        {1, rmap,
        -: 6942:            0, 0, 0,    /* blkfetch, blkstore, blkloop */
        -: 6943:            _label,
        -: 6944:            _rule,
        -: 6945:            _nts,
        -: 6946:            _kids,
        -: 6947:            _string,
        -: 6948:            _templates,
        -: 6949:            _isinstruction,
        -: 6950:            _ntname,
        -: 6951:            emit2,
        -: 6952:            0, /* doarg */
        -: 6953:            target,
        -: 6954:            clobber,
        -: 6955:        }
        -: 6956:};
        -: 6957:
function x86linux_init called 1 returned 100% blocks executed 56%
        1: 6958:void x86linux_init(int argc, char *argv[]) {
        1: 6959:        static int inited;
        -: 6960:        extern Interface x86IR;
        -: 6961:
        1: 6962:        if (inited)
    #####: 6963:                return;
        1: 6964:        inited = 1;
        -: 6965:#define xx(f) assert(!x86linuxIR.f); x86linuxIR.f = x86IR.f
        1: 6966:        xx(address);
        1: 6967:        xx(local);
        1: 6968:        xx(x.blkfetch);
        1: 6969:        xx(x.blkstore);
        1: 6970:        xx(x.blkloop);
        1: 6971:        xx(x.doarg);
        -: 6972:#undef xx
        -: 6973:}
